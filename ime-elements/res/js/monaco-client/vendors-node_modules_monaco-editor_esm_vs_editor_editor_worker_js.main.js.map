{"version":3,"file":"vendors-node_modules_monaco-editor_esm_vs_editor_editor_worker_js.main.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,aAAa,IAAI,aAAa,IAAI,aAAa;AACjF;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa,IAAI,aAAa,IAAI,aAAa,IAAI,2BAA2B;AAC7G;AACA;AACA;AACA;AACA,kCAAkC,aAAa,IAAI,gCAAgC,KAAK,gCAAgC;AACxH;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa,IAAI,gCAAgC,KAAK,gCAAgC,KAAK,wBAAwB;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B,EAAE,6BAA6B,EAAE,6BAA6B;AACtH;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B,EAAE,6BAA6B,EAAE,6BAA6B,EAAE,+CAA+C;AACvK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kDAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAQ;AACjC,yBAAyB,kDAAQ;AACjC,yBAAyB,kDAAQ;AACjC,yBAAyB,kDAAQ;AACjC,yBAAyB,kDAAQ;AACjC,yBAAyB,kDAAQ;AACjC,yBAAyB,kDAAQ;AACjC,yBAAyB,kDAAQ;AACjC,yBAAyB,kDAAQ;AACjC,yBAAyB,kDAAQ;AACjC,yBAAyB,kDAAQ;AACjC,yBAAyB,kDAAQ;AACjC,yBAAyB,kDAAQ;AACjC,yBAAyB,kDAAQ;AACjC,yBAAyB,kDAAQ;AACjC,yBAAyB,kDAAQ;AACjC,yBAAyB,kDAAQ;AACjC,yBAAyB,kDAAQ;AACjC,yBAAyB,kDAAQ;AACjC,yBAAyB,kDAAQ;AACjC,yBAAyB,kDAAQ;AACjC,yBAAyB,kDAAQ;AACjC;AACA;AACA;AACA,SAAS,gCAAgC;AACzC,KAAK,oCAAoC;AACzC,CAAC,sBAAsB;AACY;;;;;;;;;;;;;;;;;;;;ACpcU;AACL;AACD;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA,+BAA+B,+CAAS;AACxC,+BAA+B,+CAAS;AACxC;AACA;AACA;AACA;AACA;AACA,sCAAsC,sDAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAS;AACxC,+BAA+B,+CAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D,4BAA4B,oDAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAU;AACpC;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sDAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+CAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+CAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,4CAA4C;AACjF;AACA;AACA;AACA;AACA,sDAAsD,gCAAgC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sDAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gCAAgC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iBAAiB;AACrD,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sDAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;;;;;;;;;;;;;;;AC1qBnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsB;;;;;;;;;;;;;;;;;;;;;;;;ACdtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,sBAAsB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,SAAS,mBAAmB,YAAY;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACyM;;;;;;;;;;;;;;;;;;;;;;;ACzrB3I;AACxB;AACO;AACK;AACX;AACY;AACnD;AACA;AACA;AACA,SAAS,+CAAK;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8BAA8B,8CAAO;AACrC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,2BAA2B,0EAA8B;AACzD;AACA,0EAA0E,0EAA8B;AACxG,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qDAAU;AAC3C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,mEAAmE,WAAW;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,WAAW;AACtE;AACA;AACA;AACA,0DAA0D,UAAU;AACpE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4BAA4B,8DAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,+DAAkB;AACnE;AACA;AACA,sCAAsC,+DAAkB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,WAAW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA;AACA,kDAAkD,UAAU;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8DAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8DAAiB;AACzC,aAAa;AACb,SAAS;AACT;AACA;AAC2E;;;;;;;;;;;;;;;;;;;;ACvZP;AACrB;AACZ;AAC4F;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sEAAkB;AAC1C;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sEAAkB;AAC1C,mCAAmC,iBAAiB,yCAAyC,uBAAuB;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB,GAAG,4BAA4B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4CAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4CAAK;AAC1B;AACA;AACA;AACA,oDAAoD,0CAA0C;AAC9F;AACA;AACA;AACA;AACA;AACA,oDAAoD,0CAA0C;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wDAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0FAA8B;AAChE,yCAAyC,iFAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,8EAAkB;AAC3D;AACA;AACA;AACA,yCAAyC,8EAAkB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0FAA8B;AAChE,yCAAyC,iFAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA,wCAAwC,8BAA8B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmC;;;;;;;;;;;;;;;;;AC3RiC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sEAAkB,mBAAmB,mBAAmB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW,IAAI,kBAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sEAAkB,4BAA4B,mBAAmB;AACzF;AACA;AACA;AACA;AACA;AACA,wBAAwB,sEAAkB,4BAA4B,mBAAmB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uBAAuB;AACxD;AACA;AACA;AACA;AACA;AACA,iCAAiC,uBAAuB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuC;;;;;;;;;;;;;;;;;;;;ACtLoC;AAC5B;AACN;AACN;AACU;AAC7C;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wDAAW;AAChC;AACA;AACA;AACA;AACA;AACA,oBAAoB,iFAAqB;AACzC;AACA;AACA,qBAAqB,kDAAQ;AAC7B;AACA;AACA,eAAe,4CAAK;AACpB;AACA;AACA,eAAe,sDAAU;AACzB;AACA;AACA;AACA,qBAAqB,sDAAU;AAC/B;AACA;AACqC;;;;;;;;;;;;;;;;;;;;;;;;AC1CyC;AACV;AAC3B;AACyB;AAC/B;AACU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gEAAQ,OAAO,0EAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAU;AAClC;AACA,uCAAuC,kDAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kDAAQ;AACxC;AACA;AACA,gCAAgC,kDAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kDAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sDAAU;AACzC,kCAAkC,kDAAQ;AAC1C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4CAAK;AACpB;AACA;AACA,oBAAoB,sEAAkB;AACtC;AACA,iBAAiB,4CAAK;AACtB;AACA;AACA;AACA,+CAA+C,kDAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2EAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8D;;;;;;;;;;;;;;;;;ACpLrB;AACN;AACnC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4CAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4CAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4CAAK;AAC1B;AACA;AACA;AACA,yBAAyB,kDAAQ;AACjC;AACA;AACA,yBAAyB,kDAAQ;AACjC;AACA;AACA;AACA,kBAAkB,eAAe,GAAG,iBAAiB;AACrD;AACA;AACsB;;;;;;;;;;;;;;;;;;;;;;ACnHiD;AACG;AACf;AAC3D;AACA;AACA,6DAA6D,6DAAW,wBAAwB,6DAAW;AAC3G;AACA;AACA,6DAA6D,6DAAW,wBAAwB,6DAAW;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uEAAe;AACvB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wCAAwC,6DAAW,8CAA8C,6DAAW;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB,MAAM,eAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc,MAAM,aAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sEAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuF;;;;;;;;;;;;;;;;;;AChI5B;AAC6B;AAClD;AACtC;AACA,4CAA4C,8DAAe;AAC3D;AACA,mBAAmB,kEAAmB;AACtC;AACA,iCAAiC,8CAAO;AACxC,iCAAiC,8CAAO;AACxC,8BAA8B,8CAAO;AACrC,yBAAyB,uBAAuB;AAChD,6BAA6B,uBAAuB;AACpD;AACA,2BAA2B,kEAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2DAAY,OAAO,6DAAW,oCAAoC,6DAAW;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kEAAmB;AACxC;AACA;AACqC;;;;;;;;;;;;;;;;;ACnFsB;AAC6B;AACxF;AACA,kCAAkC,8DAAe;AACjD;AACA,mBAAmB,kEAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kEAAmB;AAC1C;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2DAAY,OAAO,6DAAW,kCAAkC,6DAAW;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kEAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8B;;;;;;;;;;;;;;;;;;;;;;;;;ACrI+B;AACP;AACkD;AACZ;AACpC;AACU;AACV;AACa;AACb;AACgB;AACxE;AACA,UAAU,yBAAyB;AACnC;AACA;AACA;AACA;AACA;AACA,IAAI,gEAAQ;AACZ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wDAAiB;AACzC;AACA;AACA,wBAAwB,wDAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8DAAgB;AAC7C;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,sCAAsC,uDAAM;AAC5C;AACA,sDAAsD,gDAAgD;AACtG,2BAA2B,2BAA2B,GAAG,+BAA+B,GAAG,+BAA+B;AAC1H,2CAA2C,aAAa,yDAAS,aAAa;AAC9E;AACA;AACA;AACA,iBAAiB,iEAAS,kCAAkC,oEAAgB;AAC5E;AACA;AACA,sDAAsD,gDAAgD;AACtG,2BAA2B,2BAA2B,GAAG,+BAA+B,GAAG,+BAA+B;AAC1H,+CAA+C,yDAAS;AACxD;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA,8DAA8D,yDAAS;AACvE;AACA;AACA;AACA,8DAA8D,yDAAS;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oEAAY,CAAC,iEAAS,kCAAkC,oEAAgB;AAClG,8BAA8B,4DAAY;AAC1C,8BAA8B,4DAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8DAAgB;AAC7C;AACA;AACA;AACA;AACA,eAAe,iEAAS,kCAAkC,oEAAgB;AAC1E,oCAAoC,uEAAe;AACnD,oBAAoB,kBAAkB;AACtC;AACA;AACA,uCAAuC,8EAAkB;AACzD;AACA;AACA,sCAAsC,8EAAkB;AACxD;AACA;AACA,8BAA8B,0BAA0B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yDAAS;AAChD,uCAAuC,yDAAS;AAChD;AACA;AACA,iCAAiC,6BAA6B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yDAAS;AAChD;AACA;AACA;AACA,uCAAuC,yDAAS;AAChD;AACA;AACA;AACA;AACA;AACA,6BAA6B,8DAAgB,OAAO,yDAAS;AAC7D;AACA;AACA,sBAAsB,yDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iFAAkB;AAC1D,uDAAuD,8EAAsB,gBAAgB,6DAAW,wBAAwB,8EAAsB,gBAAgB,6DAAW;AACjL;AACA,qBAAqB,sEAAY;AACjC;AACA;AACA,iBAAiB,kDAAO;AACxB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C,iBAAiB,kDAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iEAAS,kCAAkC,oEAAgB;AAC1E;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uEAAe;AACnD;AACA;AACA,qBAAqB,8DAAgB,OAAO,yDAAS,eAAe,yDAAS;AAC7E,4CAA4C,8EAAkB;AAC9D;AACA;AACA,KAAK;AACL;AACA;AAC6B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClQ+C;AACK;AAC7B;AACI;AACZ;AAC+C;AACL;AACd;AACb;AACkK;AAC5K;AACoB;AACN;AACa;AAC5E;AACA;AACA,+CAA+C,+FAAyB;AACxE,2CAA2C,iFAAkB;AAC7D;AACA;AACA,yCAAyC,8DAAM;AAC/C,yBAAyB,6DAAS;AAClC;AACA;AACA,yBAAyB,6DAAS;AAClC,sBAAsB,uEAAwB,OAAO,yDAAS,sCAAsC,yDAAS;AAC7G,0BAA0B,2DAAY,OAAO,iDAAK;AAClD;AACA;AACA;AACA;AACA,8BAA8B,iDAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,yEAAe,kBAAkB,qEAAW;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2DAAY;AAC5C,gCAAgC,2DAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yBAAyB,yFAAqB;AAC9C,yBAAyB,4GAAwC;AACjE;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA,+FAA+F,sEAAY,OAAO,6DAAW,qCAAqC,6DAAW;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gEAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gEAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,qBAAqB,6DAAS;AAC9B;AACA;AACA,sBAAsB,wEAAiB;AACvC;AACA,oFAAoF,sEAAY;AAChG;AACA,yBAAyB,6DAAS;AAClC,SAAS;AACT;AACA;AACA;AACA,6BAA6B,+EAAsB;AACnD,6BAA6B,+EAAsB;AACnD;AACA;AACA;AACA;AACA,gBAAgB,yFAAqB;AACrC,gBAAgB,wGAAoC;AACpD,gBAAgB,sFAAkB;AAClC,gBAAgB,+GAA2C;AAC3D,gDAAgD,2DAAY;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uEAAe;AACnC;AACA;AACA;AACA,2BAA2B,uEAAwB;AACnD;AACA;AACA;AACA;AACA;AACA,IAAI,gEAAQ;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0EAAkB;AACjC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yDAAS;AAC7C;AACA;AACA;AACA,oCAAoC,yDAAS;AAC7C;AACA;AACA;AACA,iBAAiB,uEAAwB;AACzC;AAC4F;;;;;;;;;;;;;;;;;;;;;;ACnOnB;AACjB;AACiB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sEAAY,OAAO,6DAAW,0EAA0E,6DAAW;AACrK;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sEAAY,OAAO,6DAAW,0EAA0E,6DAAW;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA,qCAAqC,6DAAW;AAChD;AACA;AACA;AACA,qCAAqC,6DAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,sEAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sEAAY;AACtC;AACA,0BAA0B,oEAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sEAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sEAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA,6CAA6C,6DAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI,4EAAoB;AACxB;AACA;AACA;AACA;AACA;AACA,+CAA+C,6DAAW;AAC1D;AACA;AACA;AACA,+CAA+C,6DAAW;AAC1D;AACA;AACA;AACA,+BAA+B,sEAAY,kDAAkD,oEAAU,iCAAiC,oEAAU;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACkL;;;;;;;;;;;;;;;;AC3UnH;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,8DAAQ,gCAAgC,8DAAQ;AACpG;AACA;AACA;AACA;AACwB;;;;;;;;;;;;;;;;;;;;;AC/B+F;AACxD;AACP;AACN;AACN;AACP;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6DAAW;AACzC;AACA;AACA;AACA;AACA,2CAA2C,iCAAiC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,UAAU;AACpC;AACA;AACA,kCAAkC,6DAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uDAAQ;AACjC;AACA,kBAAkB,iFAAqB;AACvC,qBAAqB,uDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA,eAAe,iDAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6DAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8EAAkB;AACxC,oBAAoB,+EAAmB;AACvC,qBAAqB,6DAAW;AAChC;AACA;AACA;AACA,uBAAuB,8DAAQ,kBAAkB,8DAAQ;AACzD,uBAAuB,8DAAQ,kBAAkB,8DAAQ;AACzD,uBAAuB,8DAAQ,uBAAuB,8DAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8DAAQ;AAC7B;AACA;AACA,0BAA0B,8DAAQ;AAClC;AACA;AACA,aAAa,kDAAO;AACpB;AACA;AACA,yBAAyB,8DAAQ,kBAAkB,8DAAQ;AAC3D;AACA;AACA,yBAAyB,8DAAQ,kBAAkB,8DAAQ;AAC3D;AACA;AACA,yBAAyB,8DAAQ,uBAAuB,8DAAQ;AAChE;AACA;AACA;AACA;AACA;AACA,0BAA0B,8DAAQ,uBAAuB,8DAAQ;AACjE;AACA;AACA;AACA;AACA;AACA;AACkC;;;;;;;;;;;;;;;;;;ACrL6B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8DAAQ,uBAAuB,8DAAQ;AAC/D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,sCAAsC;AACtF;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AAC+C;;;;;;;;;;;;;;;;;;;;;;;;ACzDa;AACA;AACT;AACwB;AACuB;AACzD;AACqC;AAC7B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yDAAS;AAC/C;AACA;AACA,sCAAsC,yDAAS;AAC/C;AACA;AACA;AACA,sCAAsC,yDAAS;AAC/C;AACA;AACA,sCAAsC,yDAAS;AAC/C;AACA,+BAA+B,sEAAwB,6DAA6D,0DAAY,OAAO,iDAAK;AAC5I;AACA;AACA;AACA;AACA,sBAAsB,iDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sEAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gEAAQ;AAChB,mBAAmB,0EAAkB;AACrC;AACA;AACA,SAAS;AACT,qBAAqB,4DAAS;AAC9B;AACA;AACA;AACA,2BAA2B,8DAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,YAAY;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mBAAmB;AACxD;AACA;AACA;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8DAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8DAAQ,mDAAmD,uBAAuB,GAAG,mBAAmB;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8DAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8DAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,YAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,YAAY;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gFAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+EAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiD;;;;;;;;;;;;;;;;ACjfjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgC;;;;;;;;;;;;;;;;;AClBuC;AAC2B;AAClG;AACA,2BAA2B,gFAAuB;AAClD,4BAA4B,2GAAwB;AACpD;AAC8B;;;;;;;;;;;;;;;;;;;;;ACNsC;AACnB;AACR;AACY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,yDAAS,gEAAgE,yDAAS;AACrI;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,yDAAS,2DAA2D,yDAAS;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,EAAE,4BAA4B,IAAI,6BAA6B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sEAAkB;AAC9C;AACA,4CAA4C,iDAAK,oFAAoF,iDAAK;AAC1I;AACA;AACA,4CAA4C,iDAAK;AACjD;AACA;AACA;AACA;AACA,sBAAsB,iDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yDAAS,+BAA+B,yDAAS;AAC/E,8BAA8B,yDAAS,+BAA+B,yDAAS;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,EAAE,iCAAiC,IAAI,kCAAkC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6DAAc;AACnC;AACA;AACoE;;;;;;;;;;;;;;;;AC9GR;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wDAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAK,OAAO,uDAAI;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB,EAAE;AAChK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,EAAE,qDAAqD,EAAE,qDAAqD,EAAE;AAC3L;AACA;AACA;AACA,2EAA2E,EAAE,qDAAqD,EAAE,qDAAqD,EAAE;AAC3L;AACA;AACA;AACA,4GAA4G,IAAI,UAAU,IAAI,iBAAiB,IAAI,UAAU,IAAI;AACjK;AACA;AACA;AACA,4GAA4G,IAAI,UAAU,IAAI,iBAAiB,IAAI,UAAU,IAAI;AACjK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwC;;;;;;;;;;;;;;;AClIxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,4BAA4B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;;;;;;;;;;;;;;;;;;;;;;;;;AC/EgD;AACvB;AACwB;AAC9B;AACH;AACN;AACQ;AACT;AACkE;AAC1G;AACA,aAAa,eAAe,4DAAQ;AACpC,aAAa,aAAa,4DAAQ;AAClC,aAAa,WAAW,4DAAQ;AAChC,aAAa,eAAe,4DAAQ;AACpC;AACA,eAAe,kEAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iFAAuB;AACxD,iBAAiB,0DAAO;AACxB,iBAAiB,mEAAO;AACxB;AACA,kBAAkB,uDAAQ;AAC1B,eAAe,iDAAK;AACpB,mBAAmB,yDAAS;AAC5B,4BAA4B,8EAAkB;AAC9C,wBAAwB,0EAAc;AACtC,mBAAmB,qEAAS;AAC5B,aAAa,oDAAG;AAChB,eAAe,gDAAK;AACpB;AACA;AACuC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpCwB;AACb;AACH;AACN;AACqB;AACmB;AACrB;AACyB;AAC5B;AACK;AACiB;AACb;AACC;AACoB;AACnB;AACyB;AAChC;AAC7D,0BAA0B,sEAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA,oDAAoD,uDAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kEAAa,kBAAkB,8EAAyB;AACnF;AACA,yBAAyB,iDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wDAAwD;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,kBAAkB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,8DAA8D;AAC7G,6CAA6C,0DAA0D;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uDAAQ;AACrB;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,oDAAG;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,eAAe,yFAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2EAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,4EAAkB,gBAAgB,4EAAkB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2EAAY;AAC/C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAK;AAC5B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,gCAAgC,0BAA0B;AAC1D,gBAAgB,iDAAK,gDAAgD,iDAAK;AAC1E,0CAA0C,iDAAK,eAAe,iDAAK,4CAA4C,iDAAK;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA,gBAAgB,iDAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA,4BAA4B,qEAAU;AACtC,8CAA8C,iDAAK;AACnD;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iCAAiC,sEAAsE;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAK;AAC5B;AACA;AACA;AACA;AACA,SAAS;AACT,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA,gBAAgB,iDAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA,yBAAyB,4EAAkB;AAC3C,0BAA0B,iDAAK;AAC/B;AACA,6BAA6B,uDAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,0BAA0B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iDAAK;AACxC;AACA,yBAAyB;AACzB;AACA;AACA;AACA,gCAAgC,uEAAkB;AAClD;AACA;AACA;AACA;AACA,0BAA0B,iCAAiC,sEAAsE;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wEAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0GAA4B;AAC3C;AACA,aAAa;AACb;AACA,yBAAyB,gEAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,4BAA4B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,8DAA8D;AAClH;AACA;AACA;AACA;AACA,uBAAuB,6FAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2EAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2EAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sEAAmB;AAC3C;AAC8B;;;;;;;;;;;;;;;ACvlB9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6BAA6B;AAC1D;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6BAA6B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AAC8B;;;;;;;;;;;;;;;;;;;;;ACtEW;AACc;AAC2F;AACrF;AACc;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iDAAiD;AACrF;AACA,+BAA+B,+DAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,yBAAyB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wEAAe;AAC3C;AACA;AACA;AACA;AACA;AACA,4BAA4B,wEAAe;AAC3C;AACA;AACA;AACA;AACA,+BAA+B,kEAAa,iBAAiB,oEAAmB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mEAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iDAAK;AAC/C;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,8CAA8C,wEAAmB,6BAA6B,wEAAmB;AACjH,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,oBAAoB,+EAAsB,6DAA6D;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oEAAoE;AACrE;AACA;AACA;AACA;AACA,mCAAmC,wEAAmB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,wEAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qEAAY;AACnD;AACA;AACA;AACA,qBAAqB,wEAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,wEAAmB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACc;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9LrE;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACA;AACA,CAAC,oEAAoE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACA;AACA,CAAC,0EAA0E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AACnD;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D;AAC3D;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA,CAAC,kEAAkE;AACnE;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA,CAAC,8DAA8D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACA;AACA;AACA,CAAC,0EAA0E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD;AACnD;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACu5B;;;;;;;;;;;;;;;;;ACzmBr3B;AACE;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mFAAkB;AACjD;AACA,KAAK,kBAAkB,sFAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsB;;;;;;;;;;;;;;;;ACpBgD;;;;;;;SCAtE;SACA;;SAEA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;;SAEA;SACA;;SAEA;SACA;SACA;;SAEA;SACA;;SAEA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;;;;;UClCA;UACA;UACA;UACA;UACA,+BAA+B,wCAAwC;UACvE;UACA;UACA;UACA;UACA,iBAAiB,qBAAqB;UACtC;UACA;UACA,kBAAkB,qBAAqB;UACvC;UACA;UACA,KAAK;UACL;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;;;;UC3BA;UACA;UACA;UACA;UACA,yCAAyC,wCAAwC;UACjF;UACA;UACA;;;;;UCPA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,EAAE;UACF;;;;;UCRA;UACA;UACA;UACA;UACA;;;;;UCJA;;;;;UCAA;UACA;UACA;UACA,uDAAuD,iBAAiB;UACxE;UACA,gDAAgD,aAAa;UAC7D;;;;;UCNA;UACA;UACA;UACA;UACA;UACA;UACA;;;;;UCNA;;UAEA;UACA;UACA;UACA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,aAAa;UACb;UACA;UACA;UACA;;UAEA;UACA;UACA;;UAEA;;UAEA;;;;;UCpCA;UACA;UACA;UACA;;;;;SEHA;SACA","sources":["webpack://example-client-webpack/./node_modules/monaco-editor/esm/vs/editor/editor.worker.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/base/common/color.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/base/common/diff/diff.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/base/common/diff/diffChange.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/base/common/keyCodes.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/base/common/worker/simpleWorker.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/core/lineRange.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/core/offsetRange.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/core/positionToOffset.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/core/textEdit.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/core/textLength.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/diff/defaultLinesDiffComputer/utils.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/diff/legacyLinesDiffComputer.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/diff/linesDiffComputer.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/diff/linesDiffComputers.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/diff/rangeMapping.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/languages/defaultDocumentColorsComputer.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/languages/supports/inplaceReplaceSupport.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/services/editorBaseApi.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/services/editorSimpleWorker.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/services/findSectionHeaders.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/services/unicodeTextModelHighlighter.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/common/standalone/standaloneEnums.js","webpack://example-client-webpack/./node_modules/vscode/vscode/src/vs/editor/editor.worker.js","webpack://example-client-webpack/./node_modules/vscode/workers/editor.worker.js","webpack://example-client-webpack/webpack/bootstrap","webpack://example-client-webpack/webpack/runtime/chunk loaded","webpack://example-client-webpack/webpack/runtime/define property getters","webpack://example-client-webpack/webpack/runtime/ensure chunk","webpack://example-client-webpack/webpack/runtime/get javascript chunk filename","webpack://example-client-webpack/webpack/runtime/hasOwnProperty shorthand","webpack://example-client-webpack/webpack/runtime/make namespace object","webpack://example-client-webpack/webpack/runtime/publicPath","webpack://example-client-webpack/webpack/runtime/importScripts chunk loading","webpack://example-client-webpack/webpack/runtime/startup chunk dependencies","webpack://example-client-webpack/webpack/before-startup","webpack://example-client-webpack/webpack/startup","webpack://example-client-webpack/webpack/after-startup"],"sourcesContent":["export * from 'vscode/workers/editor.worker'","import { CharCode } from './charCode.js';\nfunction roundFloat(number, decimalPoints) {\n    const decimal = Math.pow(10, decimalPoints);\n    return Math.round(number * decimal) / decimal;\n}\nclass RGBA {\n    constructor(r, g, b, a = 1) {\n        this._rgbaBrand = undefined;\n        this.r = Math.min(255, Math.max(0, r)) | 0;\n        this.g = Math.min(255, Math.max(0, g)) | 0;\n        this.b = Math.min(255, Math.max(0, b)) | 0;\n        this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);\n    }\n    static equals(a, b) {\n        return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;\n    }\n}\nclass HSLA {\n    constructor(h, s, l, a) {\n        this._hslaBrand = undefined;\n        this.h = Math.max(Math.min(360, h), 0) | 0;\n        this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);\n        this.l = roundFloat(Math.max(Math.min(1, l), 0), 3);\n        this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);\n    }\n    static equals(a, b) {\n        return a.h === b.h && a.s === b.s && a.l === b.l && a.a === b.a;\n    }\n    static fromRGBA(rgba) {\n        const r = rgba.r / 255;\n        const g = rgba.g / 255;\n        const b = rgba.b / 255;\n        const a = rgba.a;\n        const max = Math.max(r, g, b);\n        const min = Math.min(r, g, b);\n        let h = 0;\n        let s = 0;\n        const l = (min + max) / 2;\n        const chroma = max - min;\n        if (chroma > 0) {\n            s = Math.min((l <= 0.5 ? chroma / (2 * l) : chroma / (2 - (2 * l))), 1);\n            switch (max) {\n                case r:\n                    h = (g - b) / chroma + (g < b ? 6 : 0);\n                    break;\n                case g:\n                    h = (b - r) / chroma + 2;\n                    break;\n                case b:\n                    h = (r - g) / chroma + 4;\n                    break;\n            }\n            h *= 60;\n            h = Math.round(h);\n        }\n        return ( new HSLA(h, s, l, a));\n    }\n    static _hue2rgb(p, q, t) {\n        if (t < 0) {\n            t += 1;\n        }\n        if (t > 1) {\n            t -= 1;\n        }\n        if (t < 1 / 6) {\n            return p + (q - p) * 6 * t;\n        }\n        if (t < 1 / 2) {\n            return q;\n        }\n        if (t < 2 / 3) {\n            return p + (q - p) * (2 / 3 - t) * 6;\n        }\n        return p;\n    }\n    static toRGBA(hsla) {\n        const h = hsla.h / 360;\n        const { s, l, a } = hsla;\n        let r, g, b;\n        if (s === 0) {\n            r = g = b = l;\n        }\n        else {\n            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n            const p = 2 * l - q;\n            r = HSLA._hue2rgb(p, q, h + 1 / 3);\n            g = HSLA._hue2rgb(p, q, h);\n            b = HSLA._hue2rgb(p, q, h - 1 / 3);\n        }\n        return ( new RGBA(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), a));\n    }\n}\nclass HSVA {\n    constructor(h, s, v, a) {\n        this._hsvaBrand = undefined;\n        this.h = Math.max(Math.min(360, h), 0) | 0;\n        this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);\n        this.v = roundFloat(Math.max(Math.min(1, v), 0), 3);\n        this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);\n    }\n    static equals(a, b) {\n        return a.h === b.h && a.s === b.s && a.v === b.v && a.a === b.a;\n    }\n    static fromRGBA(rgba) {\n        const r = rgba.r / 255;\n        const g = rgba.g / 255;\n        const b = rgba.b / 255;\n        const cmax = Math.max(r, g, b);\n        const cmin = Math.min(r, g, b);\n        const delta = cmax - cmin;\n        const s = cmax === 0 ? 0 : (delta / cmax);\n        let m;\n        if (delta === 0) {\n            m = 0;\n        }\n        else if (cmax === r) {\n            m = ((((g - b) / delta) % 6) + 6) % 6;\n        }\n        else if (cmax === g) {\n            m = ((b - r) / delta) + 2;\n        }\n        else {\n            m = ((r - g) / delta) + 4;\n        }\n        return ( new HSVA(Math.round(m * 60), s, cmax, rgba.a));\n    }\n    static toRGBA(hsva) {\n        const { h, s, v, a } = hsva;\n        const c = v * s;\n        const x = c * (1 - Math.abs((h / 60) % 2 - 1));\n        const m = v - c;\n        let [r, g, b] = [0, 0, 0];\n        if (h < 60) {\n            r = c;\n            g = x;\n        }\n        else if (h < 120) {\n            r = x;\n            g = c;\n        }\n        else if (h < 180) {\n            g = c;\n            b = x;\n        }\n        else if (h < 240) {\n            g = x;\n            b = c;\n        }\n        else if (h < 300) {\n            r = x;\n            b = c;\n        }\n        else if (h <= 360) {\n            r = c;\n            b = x;\n        }\n        r = Math.round((r + m) * 255);\n        g = Math.round((g + m) * 255);\n        b = Math.round((b + m) * 255);\n        return ( new RGBA(r, g, b, a));\n    }\n}\nclass Color {\n    static fromHex(hex) {\n        return Color.Format.CSS.parseHex(hex) || Color.red;\n    }\n    static equals(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        if (!a || !b) {\n            return false;\n        }\n        return a.equals(b);\n    }\n    get hsla() {\n        if (this._hsla) {\n            return this._hsla;\n        }\n        else {\n            return HSLA.fromRGBA(this.rgba);\n        }\n    }\n    get hsva() {\n        if (this._hsva) {\n            return this._hsva;\n        }\n        return HSVA.fromRGBA(this.rgba);\n    }\n    constructor(arg) {\n        if (!arg) {\n            throw ( new Error('Color needs a value'));\n        }\n        else if (arg instanceof RGBA) {\n            this.rgba = arg;\n        }\n        else if (arg instanceof HSLA) {\n            this._hsla = arg;\n            this.rgba = HSLA.toRGBA(arg);\n        }\n        else if (arg instanceof HSVA) {\n            this._hsva = arg;\n            this.rgba = HSVA.toRGBA(arg);\n        }\n        else {\n            throw ( new Error('Invalid color ctor argument'));\n        }\n    }\n    equals(other) {\n        return !!other && RGBA.equals(this.rgba, other.rgba) && HSLA.equals(this.hsla, other.hsla) && HSVA.equals(this.hsva, other.hsva);\n    }\n    getRelativeLuminance() {\n        const R = Color._relativeLuminanceForComponent(this.rgba.r);\n        const G = Color._relativeLuminanceForComponent(this.rgba.g);\n        const B = Color._relativeLuminanceForComponent(this.rgba.b);\n        const luminance = 0.2126 * R + 0.7152 * G + 0.0722 * B;\n        return roundFloat(luminance, 4);\n    }\n    static _relativeLuminanceForComponent(color) {\n        const c = color / 255;\n        return (c <= 0.03928) ? c / 12.92 : Math.pow(((c + 0.055) / 1.055), 2.4);\n    }\n    getContrastRatio(another) {\n        const lum1 = this.getRelativeLuminance();\n        const lum2 = another.getRelativeLuminance();\n        return lum1 > lum2 ? (lum1 + 0.05) / (lum2 + 0.05) : (lum2 + 0.05) / (lum1 + 0.05);\n    }\n    isDarker() {\n        const yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1000;\n        return yiq < 128;\n    }\n    isLighter() {\n        const yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1000;\n        return yiq >= 128;\n    }\n    isLighterThan(another) {\n        const lum1 = this.getRelativeLuminance();\n        const lum2 = another.getRelativeLuminance();\n        return lum1 > lum2;\n    }\n    isDarkerThan(another) {\n        const lum1 = this.getRelativeLuminance();\n        const lum2 = another.getRelativeLuminance();\n        return lum1 < lum2;\n    }\n    lighten(factor) {\n        return ( new Color(( new HSLA(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * factor, this.hsla.a))));\n    }\n    darken(factor) {\n        return ( new Color(( new HSLA(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * factor, this.hsla.a))));\n    }\n    transparent(factor) {\n        const { r, g, b, a } = this.rgba;\n        return ( new Color(( new RGBA(r, g, b, a * factor))));\n    }\n    isTransparent() {\n        return this.rgba.a === 0;\n    }\n    isOpaque() {\n        return this.rgba.a === 1;\n    }\n    opposite() {\n        return ( new Color(( new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a))));\n    }\n    blend(c) {\n        const rgba = c.rgba;\n        const thisA = this.rgba.a;\n        const colorA = rgba.a;\n        const a = thisA + colorA * (1 - thisA);\n        if (a < 1e-6) {\n            return Color.transparent;\n        }\n        const r = this.rgba.r * thisA / a + rgba.r * colorA * (1 - thisA) / a;\n        const g = this.rgba.g * thisA / a + rgba.g * colorA * (1 - thisA) / a;\n        const b = this.rgba.b * thisA / a + rgba.b * colorA * (1 - thisA) / a;\n        return ( new Color(( new RGBA(r, g, b, a))));\n    }\n    makeOpaque(opaqueBackground) {\n        if (this.isOpaque() || opaqueBackground.rgba.a !== 1) {\n            return this;\n        }\n        const { r, g, b, a } = this.rgba;\n        return ( new Color(( new RGBA(\n            opaqueBackground.rgba.r - a * (opaqueBackground.rgba.r - r),\n            opaqueBackground.rgba.g - a * (opaqueBackground.rgba.g - g),\n            opaqueBackground.rgba.b - a * (opaqueBackground.rgba.b - b),\n            1\n        ))));\n    }\n    flatten(...backgrounds) {\n        const background = backgrounds.reduceRight((accumulator, color) => {\n            return Color._flatten(color, accumulator);\n        });\n        return Color._flatten(this, background);\n    }\n    static _flatten(foreground, background) {\n        const backgroundAlpha = 1 - foreground.rgba.a;\n        return ( new Color(( new RGBA(\n            backgroundAlpha * background.rgba.r + foreground.rgba.a * foreground.rgba.r,\n            backgroundAlpha * background.rgba.g + foreground.rgba.a * foreground.rgba.g,\n            backgroundAlpha * background.rgba.b + foreground.rgba.a * foreground.rgba.b\n        ))));\n    }\n    toString() {\n        if (!this._toString) {\n            this._toString = Color.Format.CSS.format(this);\n        }\n        return this._toString;\n    }\n    static getLighterColor(of, relative, factor) {\n        if (of.isLighterThan(relative)) {\n            return of;\n        }\n        factor = factor ? factor : 0.5;\n        const lum1 = of.getRelativeLuminance();\n        const lum2 = relative.getRelativeLuminance();\n        factor = factor * (lum2 - lum1) / lum2;\n        return ( of.lighten(factor));\n    }\n    static getDarkerColor(of, relative, factor) {\n        if (of.isDarkerThan(relative)) {\n            return of;\n        }\n        factor = factor ? factor : 0.5;\n        const lum1 = of.getRelativeLuminance();\n        const lum2 = relative.getRelativeLuminance();\n        factor = factor * (lum1 - lum2) / lum1;\n        return ( of.darken(factor));\n    }\n    static { this.white = ( new Color(( new RGBA(255, 255, 255, 1)))); }\n    static { this.black = ( new Color(( new RGBA(0, 0, 0, 1)))); }\n    static { this.red = ( new Color(( new RGBA(255, 0, 0, 1)))); }\n    static { this.blue = ( new Color(( new RGBA(0, 0, 255, 1)))); }\n    static { this.green = ( new Color(( new RGBA(0, 255, 0, 1)))); }\n    static { this.cyan = ( new Color(( new RGBA(0, 255, 255, 1)))); }\n    static { this.lightgrey = ( new Color(( new RGBA(211, 211, 211, 1)))); }\n    static { this.transparent = ( new Color(( new RGBA(0, 0, 0, 0)))); }\n}\n( (function(Color) {\n    ( (function(Format) {\n        ( (function(CSS) {\n            function formatRGB(color) {\n                if (color.rgba.a === 1) {\n                    return `rgb(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b})`;\n                }\n                return Color.Format.CSS.formatRGBA(color);\n            }\n            CSS.formatRGB = formatRGB;\n            function formatRGBA(color) {\n                return `rgba(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b}, ${+(color.rgba.a).toFixed(2)})`;\n            }\n            CSS.formatRGBA = formatRGBA;\n            function formatHSL(color) {\n                if (color.hsla.a === 1) {\n                    return `hsl(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%)`;\n                }\n                return Color.Format.CSS.formatHSLA(color);\n            }\n            CSS.formatHSL = formatHSL;\n            function formatHSLA(color) {\n                return `hsla(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%, ${color.hsla.a.toFixed(2)})`;\n            }\n            CSS.formatHSLA = formatHSLA;\n            function _toTwoDigitHex(n) {\n                const r = ( n.toString(16));\n                return r.length !== 2 ? '0' + r : r;\n            }\n            function formatHex(color) {\n                return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}`;\n            }\n            CSS.formatHex = formatHex;\n            function formatHexA(color, compact = false) {\n                if (compact && color.rgba.a === 1) {\n                    return Color.Format.CSS.formatHex(color);\n                }\n                return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}${_toTwoDigitHex(Math.round(color.rgba.a * 255))}`;\n            }\n            CSS.formatHexA = formatHexA;\n            function format(color) {\n                if (color.isOpaque()) {\n                    return Color.Format.CSS.formatHex(color);\n                }\n                return Color.Format.CSS.formatRGBA(color);\n            }\n            CSS.format = format;\n            function parseHex(hex) {\n                const length = hex.length;\n                if (length === 0) {\n                    return null;\n                }\n                if (hex.charCodeAt(0) !== CharCode.Hash) {\n                    return null;\n                }\n                if (length === 7) {\n                    const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));\n                    const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));\n                    const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));\n                    return ( new Color(( new RGBA(r, g, b, 1))));\n                }\n                if (length === 9) {\n                    const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));\n                    const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));\n                    const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));\n                    const a = 16 * _parseHexDigit(hex.charCodeAt(7)) + _parseHexDigit(hex.charCodeAt(8));\n                    return ( new Color(( new RGBA(r, g, b, a / 255))));\n                }\n                if (length === 4) {\n                    const r = _parseHexDigit(hex.charCodeAt(1));\n                    const g = _parseHexDigit(hex.charCodeAt(2));\n                    const b = _parseHexDigit(hex.charCodeAt(3));\n                    return ( new Color(( new RGBA(16 * r + r, 16 * g + g, 16 * b + b))));\n                }\n                if (length === 5) {\n                    const r = _parseHexDigit(hex.charCodeAt(1));\n                    const g = _parseHexDigit(hex.charCodeAt(2));\n                    const b = _parseHexDigit(hex.charCodeAt(3));\n                    const a = _parseHexDigit(hex.charCodeAt(4));\n                    return ( new Color(( new RGBA(16 * r + r, 16 * g + g, 16 * b + b, (16 * a + a) / 255))));\n                }\n                return null;\n            }\n            CSS.parseHex = parseHex;\n            function _parseHexDigit(charCode) {\n                switch (charCode) {\n                    case CharCode.Digit0: return 0;\n                    case CharCode.Digit1: return 1;\n                    case CharCode.Digit2: return 2;\n                    case CharCode.Digit3: return 3;\n                    case CharCode.Digit4: return 4;\n                    case CharCode.Digit5: return 5;\n                    case CharCode.Digit6: return 6;\n                    case CharCode.Digit7: return 7;\n                    case CharCode.Digit8: return 8;\n                    case CharCode.Digit9: return 9;\n                    case CharCode.a: return 10;\n                    case CharCode.A: return 10;\n                    case CharCode.b: return 11;\n                    case CharCode.B: return 11;\n                    case CharCode.c: return 12;\n                    case CharCode.C: return 12;\n                    case CharCode.d: return 13;\n                    case CharCode.D: return 13;\n                    case CharCode.e: return 14;\n                    case CharCode.E: return 14;\n                    case CharCode.f: return 15;\n                    case CharCode.F: return 15;\n                }\n                return 0;\n            }\n        })(Format.CSS || (Format.CSS = {})));\n    })(Color.Format || (Color.Format = {})));\n})(Color || (Color = {})));\nexport { Color, HSLA, HSVA, RGBA };\n","import { DiffChange } from './diffChange.js';\nimport { stringHash } from '../hash.js';\nimport { Constants } from '../uint.js';\nclass StringDiffSequence {\n    constructor(source) {\n        this.source = source;\n    }\n    getElements() {\n        const source = this.source;\n        const characters = ( new Int32Array(source.length));\n        for (let i = 0, len = source.length; i < len; i++) {\n            characters[i] = source.charCodeAt(i);\n        }\n        return characters;\n    }\n}\nfunction stringDiff(original, modified, pretty) {\n    return ( new LcsDiff(( new StringDiffSequence(original)), ( new StringDiffSequence(modified)))).ComputeDiff(pretty).changes;\n}\nclass Debug {\n    static Assert(condition, message) {\n        if (!condition) {\n            throw ( new Error(message));\n        }\n    }\n}\nclass MyArray {\n    static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n        for (let i = 0; i < length; i++) {\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n        }\n    }\n    static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n        for (let i = 0; i < length; i++) {\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n        }\n    }\n}\nvar LocalConstants;\n( (function(LocalConstants) {\n    LocalConstants[LocalConstants[\"MaxDifferencesHistory\"] = 1447] = \"MaxDifferencesHistory\";\n})(LocalConstants || (LocalConstants = {})));\nclass DiffChangeHelper {\n    constructor() {\n        this.m_changes = [];\n        this.m_originalStart = Constants.MAX_SAFE_SMALL_INTEGER;\n        this.m_modifiedStart = Constants.MAX_SAFE_SMALL_INTEGER;\n        this.m_originalCount = 0;\n        this.m_modifiedCount = 0;\n    }\n    MarkNextChange() {\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            this.m_changes.push(( new DiffChange(\n                this.m_originalStart,\n                this.m_originalCount,\n                this.m_modifiedStart,\n                this.m_modifiedCount\n            )));\n        }\n        this.m_originalCount = 0;\n        this.m_modifiedCount = 0;\n        this.m_originalStart = Constants.MAX_SAFE_SMALL_INTEGER;\n        this.m_modifiedStart = Constants.MAX_SAFE_SMALL_INTEGER;\n    }\n    AddOriginalElement(originalIndex, modifiedIndex) {\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n        this.m_originalCount++;\n    }\n    AddModifiedElement(originalIndex, modifiedIndex) {\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n        this.m_modifiedCount++;\n    }\n    getChanges() {\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            this.MarkNextChange();\n        }\n        return this.m_changes;\n    }\n    getReverseChanges() {\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            this.MarkNextChange();\n        }\n        this.m_changes.reverse();\n        return this.m_changes;\n    }\n}\nclass LcsDiff {\n    constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {\n        this.ContinueProcessingPredicate = continueProcessingPredicate;\n        this._originalSequence = originalSequence;\n        this._modifiedSequence = modifiedSequence;\n        const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);\n        const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);\n        this._hasStrings = (originalHasStrings && modifiedHasStrings);\n        this._originalStringElements = originalStringElements;\n        this._originalElementsOrHash = originalElementsOrHash;\n        this._modifiedStringElements = modifiedStringElements;\n        this._modifiedElementsOrHash = modifiedElementsOrHash;\n        this.m_forwardHistory = [];\n        this.m_reverseHistory = [];\n    }\n    static _isStringArray(arr) {\n        return (arr.length > 0 && typeof arr[0] === 'string');\n    }\n    static _getElements(sequence) {\n        const elements = sequence.getElements();\n        if (LcsDiff._isStringArray(elements)) {\n            const hashes = ( new Int32Array(elements.length));\n            for (let i = 0, len = elements.length; i < len; i++) {\n                hashes[i] = stringHash(elements[i], 0);\n            }\n            return [elements, hashes, true];\n        }\n        if (elements instanceof Int32Array) {\n            return [[], elements, false];\n        }\n        return [[], ( new Int32Array(elements)), false];\n    }\n    ElementsAreEqual(originalIndex, newIndex) {\n        if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {\n            return false;\n        }\n        return (this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true);\n    }\n    ElementsAreStrictEqual(originalIndex, newIndex) {\n        if (!this.ElementsAreEqual(originalIndex, newIndex)) {\n            return false;\n        }\n        const originalElement = LcsDiff._getStrictElement(this._originalSequence, originalIndex);\n        const modifiedElement = LcsDiff._getStrictElement(this._modifiedSequence, newIndex);\n        return (originalElement === modifiedElement);\n    }\n    static _getStrictElement(sequence, index) {\n        if (typeof sequence.getStrictElement === 'function') {\n            return sequence.getStrictElement(index);\n        }\n        return null;\n    }\n    OriginalElementsAreEqual(index1, index2) {\n        if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {\n            return false;\n        }\n        return (this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true);\n    }\n    ModifiedElementsAreEqual(index1, index2) {\n        if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {\n            return false;\n        }\n        return (this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true);\n    }\n    ComputeDiff(pretty) {\n        return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);\n    }\n    _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {\n        const quitEarlyArr = [false];\n        let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\n        if (pretty) {\n            changes = this.PrettifyChanges(changes);\n        }\n        return {\n            quitEarly: quitEarlyArr[0],\n            changes: changes\n        };\n    }\n    ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {\n        quitEarlyArr[0] = false;\n        while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\n            originalStart++;\n            modifiedStart++;\n        }\n        while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\n            originalEnd--;\n            modifiedEnd--;\n        }\n        if (originalStart > originalEnd || modifiedStart > modifiedEnd) {\n            let changes;\n            if (modifiedStart <= modifiedEnd) {\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n                changes = [\n                    ( new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1))\n                ];\n            }\n            else if (originalStart <= originalEnd) {\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n                changes = [\n                    ( new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0))\n                ];\n            }\n            else {\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n                changes = [];\n            }\n            return changes;\n        }\n        const midOriginalArr = [0];\n        const midModifiedArr = [0];\n        const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\n        const midOriginal = midOriginalArr[0];\n        const midModified = midModifiedArr[0];\n        if (result !== null) {\n            return result;\n        }\n        else if (!quitEarlyArr[0]) {\n            const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\n            let rightChanges = [];\n            if (!quitEarlyArr[0]) {\n                rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\n            }\n            else {\n                rightChanges = [\n                    ( new DiffChange(\n                        midOriginal + 1,\n                        originalEnd - (midOriginal + 1) + 1,\n                        midModified + 1,\n                        modifiedEnd - (midModified + 1) + 1\n                    ))\n                ];\n            }\n            return this.ConcatenateChanges(leftChanges, rightChanges);\n        }\n        return [\n            ( new DiffChange(\n                originalStart,\n                originalEnd - originalStart + 1,\n                modifiedStart,\n                modifiedEnd - modifiedStart + 1\n            ))\n        ];\n    }\n    WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {\n        let forwardChanges = null;\n        let reverseChanges = null;\n        let changeHelper = ( new DiffChangeHelper());\n        let diagonalMin = diagonalForwardStart;\n        let diagonalMax = diagonalForwardEnd;\n        let diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;\n        let lastOriginalIndex = Constants.MIN_SAFE_SMALL_INTEGER;\n        let historyIndex = this.m_forwardHistory.length - 1;\n        do {\n            const diagonal = diagonalRelative + diagonalForwardBase;\n            if (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n                originalIndex = forwardPoints[diagonal + 1];\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n                if (originalIndex < lastOriginalIndex) {\n                    changeHelper.MarkNextChange();\n                }\n                lastOriginalIndex = originalIndex;\n                changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\n                diagonalRelative = (diagonal + 1) - diagonalForwardBase;\n            }\n            else {\n                originalIndex = forwardPoints[diagonal - 1] + 1;\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n                if (originalIndex < lastOriginalIndex) {\n                    changeHelper.MarkNextChange();\n                }\n                lastOriginalIndex = originalIndex - 1;\n                changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\n                diagonalRelative = (diagonal - 1) - diagonalForwardBase;\n            }\n            if (historyIndex >= 0) {\n                forwardPoints = this.m_forwardHistory[historyIndex];\n                diagonalForwardBase = forwardPoints[0];\n                diagonalMin = 1;\n                diagonalMax = forwardPoints.length - 1;\n            }\n        } while (--historyIndex >= -1);\n        forwardChanges = changeHelper.getReverseChanges();\n        if (quitEarlyArr[0]) {\n            let originalStartPoint = midOriginalArr[0] + 1;\n            let modifiedStartPoint = midModifiedArr[0] + 1;\n            if (forwardChanges !== null && forwardChanges.length > 0) {\n                const lastForwardChange = forwardChanges[forwardChanges.length - 1];\n                originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\n                modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\n            }\n            reverseChanges = [\n                ( new DiffChange(\n                    originalStartPoint,\n                    originalEnd - originalStartPoint + 1,\n                    modifiedStartPoint,\n                    modifiedEnd - modifiedStartPoint + 1\n                ))\n            ];\n        }\n        else {\n            changeHelper = ( new DiffChangeHelper());\n            diagonalMin = diagonalReverseStart;\n            diagonalMax = diagonalReverseEnd;\n            diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;\n            lastOriginalIndex = Constants.MAX_SAFE_SMALL_INTEGER;\n            historyIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\n            do {\n                const diagonal = diagonalRelative + diagonalReverseBase;\n                if (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n                    originalIndex = reversePoints[diagonal + 1] - 1;\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n                    if (originalIndex > lastOriginalIndex) {\n                        changeHelper.MarkNextChange();\n                    }\n                    lastOriginalIndex = originalIndex + 1;\n                    changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\n                    diagonalRelative = (diagonal + 1) - diagonalReverseBase;\n                }\n                else {\n                    originalIndex = reversePoints[diagonal - 1];\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n                    if (originalIndex > lastOriginalIndex) {\n                        changeHelper.MarkNextChange();\n                    }\n                    lastOriginalIndex = originalIndex;\n                    changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\n                    diagonalRelative = (diagonal - 1) - diagonalReverseBase;\n                }\n                if (historyIndex >= 0) {\n                    reversePoints = this.m_reverseHistory[historyIndex];\n                    diagonalReverseBase = reversePoints[0];\n                    diagonalMin = 1;\n                    diagonalMax = reversePoints.length - 1;\n                }\n            } while (--historyIndex >= -1);\n            reverseChanges = changeHelper.getChanges();\n        }\n        return this.ConcatenateChanges(forwardChanges, reverseChanges);\n    }\n    ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {\n        let originalIndex = 0, modifiedIndex = 0;\n        let diagonalForwardStart = 0, diagonalForwardEnd = 0;\n        let diagonalReverseStart = 0, diagonalReverseEnd = 0;\n        originalStart--;\n        modifiedStart--;\n        midOriginalArr[0] = 0;\n        midModifiedArr[0] = 0;\n        this.m_forwardHistory = [];\n        this.m_reverseHistory = [];\n        const maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);\n        const numDiagonals = maxDifferences + 1;\n        const forwardPoints = ( new Int32Array(numDiagonals));\n        const reversePoints = ( new Int32Array(numDiagonals));\n        const diagonalForwardBase = (modifiedEnd - modifiedStart);\n        const diagonalReverseBase = (originalEnd - originalStart);\n        const diagonalForwardOffset = (originalStart - modifiedStart);\n        const diagonalReverseOffset = (originalEnd - modifiedEnd);\n        const delta = diagonalReverseBase - diagonalForwardBase;\n        const deltaIsEven = (delta % 2 === 0);\n        forwardPoints[diagonalForwardBase] = originalStart;\n        reversePoints[diagonalReverseBase] = originalEnd;\n        quitEarlyArr[0] = false;\n        for (let numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {\n            let furthestOriginalIndex = 0;\n            let furthestModifiedIndex = 0;\n            diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n            diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n            for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\n                if (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n                    originalIndex = forwardPoints[diagonal + 1];\n                }\n                else {\n                    originalIndex = forwardPoints[diagonal - 1] + 1;\n                }\n                modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\n                const tempOriginalIndex = originalIndex;\n                while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\n                    originalIndex++;\n                    modifiedIndex++;\n                }\n                forwardPoints[diagonal] = originalIndex;\n                if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\n                    furthestOriginalIndex = originalIndex;\n                    furthestModifiedIndex = modifiedIndex;\n                }\n                if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {\n                    if (originalIndex >= reversePoints[diagonal]) {\n                        midOriginalArr[0] = originalIndex;\n                        midModifiedArr[0] = modifiedIndex;\n                        if (tempOriginalIndex <= reversePoints[diagonal] && LocalConstants.MaxDifferencesHistory > 0 && numDifferences <= (LocalConstants.MaxDifferencesHistory + 1)) {\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                        }\n                        else {\n                            return null;\n                        }\n                    }\n                }\n            }\n            const matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\n            if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {\n                quitEarlyArr[0] = true;\n                midOriginalArr[0] = furthestOriginalIndex;\n                midModifiedArr[0] = furthestModifiedIndex;\n                if (matchLengthOfLongest > 0 && LocalConstants.MaxDifferencesHistory > 0 && numDifferences <= (LocalConstants.MaxDifferencesHistory + 1)) {\n                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                }\n                else {\n                    originalStart++;\n                    modifiedStart++;\n                    return [\n                        ( new DiffChange(\n                            originalStart,\n                            originalEnd - originalStart + 1,\n                            modifiedStart,\n                            modifiedEnd - modifiedStart + 1\n                        ))\n                    ];\n                }\n            }\n            diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n            diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n            for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\n                if (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n                    originalIndex = reversePoints[diagonal + 1] - 1;\n                }\n                else {\n                    originalIndex = reversePoints[diagonal - 1];\n                }\n                modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\n                const tempOriginalIndex = originalIndex;\n                while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\n                    originalIndex--;\n                    modifiedIndex--;\n                }\n                reversePoints[diagonal] = originalIndex;\n                if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\n                    if (originalIndex <= forwardPoints[diagonal]) {\n                        midOriginalArr[0] = originalIndex;\n                        midModifiedArr[0] = modifiedIndex;\n                        if (tempOriginalIndex >= forwardPoints[diagonal] && LocalConstants.MaxDifferencesHistory > 0 && numDifferences <= (LocalConstants.MaxDifferencesHistory + 1)) {\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                        }\n                        else {\n                            return null;\n                        }\n                    }\n                }\n            }\n            if (numDifferences <= LocalConstants.MaxDifferencesHistory) {\n                let temp = ( new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2));\n                temp[0] = diagonalForwardBase - diagonalForwardStart + 1;\n                MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\n                this.m_forwardHistory.push(temp);\n                temp = ( new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2));\n                temp[0] = diagonalReverseBase - diagonalReverseStart + 1;\n                MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\n                this.m_reverseHistory.push(temp);\n            }\n        }\n        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n    }\n    PrettifyChanges(changes) {\n        for (let i = 0; i < changes.length; i++) {\n            const change = changes[i];\n            const originalStop = (i < changes.length - 1) ? changes[i + 1].originalStart : this._originalElementsOrHash.length;\n            const modifiedStop = (i < changes.length - 1) ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;\n            const checkOriginal = change.originalLength > 0;\n            const checkModified = change.modifiedLength > 0;\n            while (change.originalStart + change.originalLength < originalStop\n                && change.modifiedStart + change.modifiedLength < modifiedStop\n                && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength))\n                && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {\n                const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);\n                const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);\n                if (endStrictEqual && !startStrictEqual) {\n                    break;\n                }\n                change.originalStart++;\n                change.modifiedStart++;\n            }\n            const mergedChangeArr = [null];\n            if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\n                changes[i] = mergedChangeArr[0];\n                changes.splice(i + 1, 1);\n                i--;\n                continue;\n            }\n        }\n        for (let i = changes.length - 1; i >= 0; i--) {\n            const change = changes[i];\n            let originalStop = 0;\n            let modifiedStop = 0;\n            if (i > 0) {\n                const prevChange = changes[i - 1];\n                originalStop = prevChange.originalStart + prevChange.originalLength;\n                modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\n            }\n            const checkOriginal = change.originalLength > 0;\n            const checkModified = change.modifiedLength > 0;\n            let bestDelta = 0;\n            let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);\n            for (let delta = 1;; delta++) {\n                const originalStart = change.originalStart - delta;\n                const modifiedStart = change.modifiedStart - delta;\n                if (originalStart < originalStop || modifiedStart < modifiedStop) {\n                    break;\n                }\n                if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {\n                    break;\n                }\n                if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {\n                    break;\n                }\n                const touchingPreviousChange = (originalStart === originalStop && modifiedStart === modifiedStop);\n                const score = ((touchingPreviousChange ? 5 : 0)\n                    + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength));\n                if (score > bestScore) {\n                    bestScore = score;\n                    bestDelta = delta;\n                }\n            }\n            change.originalStart -= bestDelta;\n            change.modifiedStart -= bestDelta;\n            const mergedChangeArr = [null];\n            if (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {\n                changes[i - 1] = mergedChangeArr[0];\n                changes.splice(i, 1);\n                i++;\n                continue;\n            }\n        }\n        if (this._hasStrings) {\n            for (let i = 1, len = changes.length; i < len; i++) {\n                const aChange = changes[i - 1];\n                const bChange = changes[i];\n                const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;\n                const aOriginalStart = aChange.originalStart;\n                const bOriginalEnd = bChange.originalStart + bChange.originalLength;\n                const abOriginalLength = bOriginalEnd - aOriginalStart;\n                const aModifiedStart = aChange.modifiedStart;\n                const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;\n                const abModifiedLength = bModifiedEnd - aModifiedStart;\n                if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {\n                    const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);\n                    if (t) {\n                        const [originalMatchStart, modifiedMatchStart] = t;\n                        if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {\n                            aChange.originalLength = originalMatchStart - aChange.originalStart;\n                            aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;\n                            bChange.originalStart = originalMatchStart + matchedLength;\n                            bChange.modifiedStart = modifiedMatchStart + matchedLength;\n                            bChange.originalLength = bOriginalEnd - bChange.originalStart;\n                            bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;\n                        }\n                    }\n                }\n            }\n        }\n        return changes;\n    }\n    _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {\n        if (originalLength < desiredLength || modifiedLength < desiredLength) {\n            return null;\n        }\n        const originalMax = originalStart + originalLength - desiredLength + 1;\n        const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;\n        let bestScore = 0;\n        let bestOriginalStart = 0;\n        let bestModifiedStart = 0;\n        for (let i = originalStart; i < originalMax; i++) {\n            for (let j = modifiedStart; j < modifiedMax; j++) {\n                const score = this._contiguousSequenceScore(i, j, desiredLength);\n                if (score > 0 && score > bestScore) {\n                    bestScore = score;\n                    bestOriginalStart = i;\n                    bestModifiedStart = j;\n                }\n            }\n        }\n        if (bestScore > 0) {\n            return [bestOriginalStart, bestModifiedStart];\n        }\n        return null;\n    }\n    _contiguousSequenceScore(originalStart, modifiedStart, length) {\n        let score = 0;\n        for (let l = 0; l < length; l++) {\n            if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {\n                return 0;\n            }\n            score += this._originalStringElements[originalStart + l].length;\n        }\n        return score;\n    }\n    _OriginalIsBoundary(index) {\n        if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {\n            return true;\n        }\n        return (this._hasStrings && /^\\s*$/.test(this._originalStringElements[index]));\n    }\n    _OriginalRegionIsBoundary(originalStart, originalLength) {\n        if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\n            return true;\n        }\n        if (originalLength > 0) {\n            const originalEnd = originalStart + originalLength;\n            if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _ModifiedIsBoundary(index) {\n        if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {\n            return true;\n        }\n        return (this._hasStrings && /^\\s*$/.test(this._modifiedStringElements[index]));\n    }\n    _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {\n        if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\n            return true;\n        }\n        if (modifiedLength > 0) {\n            const modifiedEnd = modifiedStart + modifiedLength;\n            if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {\n        const originalScore = (this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0);\n        const modifiedScore = (this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0);\n        return (originalScore + modifiedScore);\n    }\n    ConcatenateChanges(left, right) {\n        const mergedChangeArr = [];\n        if (left.length === 0 || right.length === 0) {\n            return (right.length > 0) ? right : left;\n        }\n        else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\n            const result = ( new Array(left.length + right.length - 1));\n            MyArray.Copy(left, 0, result, 0, left.length - 1);\n            result[left.length - 1] = mergedChangeArr[0];\n            MyArray.Copy(right, 1, result, left.length, right.length - 1);\n            return result;\n        }\n        else {\n            const result = ( new Array(left.length + right.length));\n            MyArray.Copy(left, 0, result, 0, left.length);\n            MyArray.Copy(right, 0, result, left.length, right.length);\n            return result;\n        }\n    }\n    ChangesOverlap(left, right, mergedChangeArr) {\n        Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\n        Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\n        if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n            const originalStart = left.originalStart;\n            let originalLength = left.originalLength;\n            const modifiedStart = left.modifiedStart;\n            let modifiedLength = left.modifiedLength;\n            if (left.originalStart + left.originalLength >= right.originalStart) {\n                originalLength = right.originalStart + right.originalLength - left.originalStart;\n            }\n            if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n                modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\n            }\n            mergedChangeArr[0] = ( new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength));\n            return true;\n        }\n        else {\n            mergedChangeArr[0] = null;\n            return false;\n        }\n    }\n    ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {\n        if (diagonal >= 0 && diagonal < numDiagonals) {\n            return diagonal;\n        }\n        const diagonalsBelow = diagonalBaseIndex;\n        const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\n        const diffEven = (numDifferences % 2 === 0);\n        if (diagonal < 0) {\n            const lowerBoundEven = (diagonalsBelow % 2 === 0);\n            return (diffEven === lowerBoundEven) ? 0 : 1;\n        }\n        else {\n            const upperBoundEven = (diagonalsAbove % 2 === 0);\n            return (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;\n        }\n    }\n}\nexport { LcsDiff, StringDiffSequence, stringDiff };\n","class DiffChange {\n    constructor(originalStart, originalLength, modifiedStart, modifiedLength) {\n        this.originalStart = originalStart;\n        this.originalLength = originalLength;\n        this.modifiedStart = modifiedStart;\n        this.modifiedLength = modifiedLength;\n    }\n    getOriginalEnd() {\n        return this.originalStart + this.originalLength;\n    }\n    getModifiedEnd() {\n        return this.modifiedStart + this.modifiedLength;\n    }\n}\nexport { DiffChange };\n","var KeyCode;\n( (function(KeyCode) {\n    KeyCode[KeyCode[\"DependsOnKbLayout\"] = -1] = \"DependsOnKbLayout\";\n    KeyCode[KeyCode[\"Unknown\"] = 0] = \"Unknown\";\n    KeyCode[KeyCode[\"Backspace\"] = 1] = \"Backspace\";\n    KeyCode[KeyCode[\"Tab\"] = 2] = \"Tab\";\n    KeyCode[KeyCode[\"Enter\"] = 3] = \"Enter\";\n    KeyCode[KeyCode[\"Shift\"] = 4] = \"Shift\";\n    KeyCode[KeyCode[\"Ctrl\"] = 5] = \"Ctrl\";\n    KeyCode[KeyCode[\"Alt\"] = 6] = \"Alt\";\n    KeyCode[KeyCode[\"PauseBreak\"] = 7] = \"PauseBreak\";\n    KeyCode[KeyCode[\"CapsLock\"] = 8] = \"CapsLock\";\n    KeyCode[KeyCode[\"Escape\"] = 9] = \"Escape\";\n    KeyCode[KeyCode[\"Space\"] = 10] = \"Space\";\n    KeyCode[KeyCode[\"PageUp\"] = 11] = \"PageUp\";\n    KeyCode[KeyCode[\"PageDown\"] = 12] = \"PageDown\";\n    KeyCode[KeyCode[\"End\"] = 13] = \"End\";\n    KeyCode[KeyCode[\"Home\"] = 14] = \"Home\";\n    KeyCode[KeyCode[\"LeftArrow\"] = 15] = \"LeftArrow\";\n    KeyCode[KeyCode[\"UpArrow\"] = 16] = \"UpArrow\";\n    KeyCode[KeyCode[\"RightArrow\"] = 17] = \"RightArrow\";\n    KeyCode[KeyCode[\"DownArrow\"] = 18] = \"DownArrow\";\n    KeyCode[KeyCode[\"Insert\"] = 19] = \"Insert\";\n    KeyCode[KeyCode[\"Delete\"] = 20] = \"Delete\";\n    KeyCode[KeyCode[\"Digit0\"] = 21] = \"Digit0\";\n    KeyCode[KeyCode[\"Digit1\"] = 22] = \"Digit1\";\n    KeyCode[KeyCode[\"Digit2\"] = 23] = \"Digit2\";\n    KeyCode[KeyCode[\"Digit3\"] = 24] = \"Digit3\";\n    KeyCode[KeyCode[\"Digit4\"] = 25] = \"Digit4\";\n    KeyCode[KeyCode[\"Digit5\"] = 26] = \"Digit5\";\n    KeyCode[KeyCode[\"Digit6\"] = 27] = \"Digit6\";\n    KeyCode[KeyCode[\"Digit7\"] = 28] = \"Digit7\";\n    KeyCode[KeyCode[\"Digit8\"] = 29] = \"Digit8\";\n    KeyCode[KeyCode[\"Digit9\"] = 30] = \"Digit9\";\n    KeyCode[KeyCode[\"KeyA\"] = 31] = \"KeyA\";\n    KeyCode[KeyCode[\"KeyB\"] = 32] = \"KeyB\";\n    KeyCode[KeyCode[\"KeyC\"] = 33] = \"KeyC\";\n    KeyCode[KeyCode[\"KeyD\"] = 34] = \"KeyD\";\n    KeyCode[KeyCode[\"KeyE\"] = 35] = \"KeyE\";\n    KeyCode[KeyCode[\"KeyF\"] = 36] = \"KeyF\";\n    KeyCode[KeyCode[\"KeyG\"] = 37] = \"KeyG\";\n    KeyCode[KeyCode[\"KeyH\"] = 38] = \"KeyH\";\n    KeyCode[KeyCode[\"KeyI\"] = 39] = \"KeyI\";\n    KeyCode[KeyCode[\"KeyJ\"] = 40] = \"KeyJ\";\n    KeyCode[KeyCode[\"KeyK\"] = 41] = \"KeyK\";\n    KeyCode[KeyCode[\"KeyL\"] = 42] = \"KeyL\";\n    KeyCode[KeyCode[\"KeyM\"] = 43] = \"KeyM\";\n    KeyCode[KeyCode[\"KeyN\"] = 44] = \"KeyN\";\n    KeyCode[KeyCode[\"KeyO\"] = 45] = \"KeyO\";\n    KeyCode[KeyCode[\"KeyP\"] = 46] = \"KeyP\";\n    KeyCode[KeyCode[\"KeyQ\"] = 47] = \"KeyQ\";\n    KeyCode[KeyCode[\"KeyR\"] = 48] = \"KeyR\";\n    KeyCode[KeyCode[\"KeyS\"] = 49] = \"KeyS\";\n    KeyCode[KeyCode[\"KeyT\"] = 50] = \"KeyT\";\n    KeyCode[KeyCode[\"KeyU\"] = 51] = \"KeyU\";\n    KeyCode[KeyCode[\"KeyV\"] = 52] = \"KeyV\";\n    KeyCode[KeyCode[\"KeyW\"] = 53] = \"KeyW\";\n    KeyCode[KeyCode[\"KeyX\"] = 54] = \"KeyX\";\n    KeyCode[KeyCode[\"KeyY\"] = 55] = \"KeyY\";\n    KeyCode[KeyCode[\"KeyZ\"] = 56] = \"KeyZ\";\n    KeyCode[KeyCode[\"Meta\"] = 57] = \"Meta\";\n    KeyCode[KeyCode[\"ContextMenu\"] = 58] = \"ContextMenu\";\n    KeyCode[KeyCode[\"F1\"] = 59] = \"F1\";\n    KeyCode[KeyCode[\"F2\"] = 60] = \"F2\";\n    KeyCode[KeyCode[\"F3\"] = 61] = \"F3\";\n    KeyCode[KeyCode[\"F4\"] = 62] = \"F4\";\n    KeyCode[KeyCode[\"F5\"] = 63] = \"F5\";\n    KeyCode[KeyCode[\"F6\"] = 64] = \"F6\";\n    KeyCode[KeyCode[\"F7\"] = 65] = \"F7\";\n    KeyCode[KeyCode[\"F8\"] = 66] = \"F8\";\n    KeyCode[KeyCode[\"F9\"] = 67] = \"F9\";\n    KeyCode[KeyCode[\"F10\"] = 68] = \"F10\";\n    KeyCode[KeyCode[\"F11\"] = 69] = \"F11\";\n    KeyCode[KeyCode[\"F12\"] = 70] = \"F12\";\n    KeyCode[KeyCode[\"F13\"] = 71] = \"F13\";\n    KeyCode[KeyCode[\"F14\"] = 72] = \"F14\";\n    KeyCode[KeyCode[\"F15\"] = 73] = \"F15\";\n    KeyCode[KeyCode[\"F16\"] = 74] = \"F16\";\n    KeyCode[KeyCode[\"F17\"] = 75] = \"F17\";\n    KeyCode[KeyCode[\"F18\"] = 76] = \"F18\";\n    KeyCode[KeyCode[\"F19\"] = 77] = \"F19\";\n    KeyCode[KeyCode[\"F20\"] = 78] = \"F20\";\n    KeyCode[KeyCode[\"F21\"] = 79] = \"F21\";\n    KeyCode[KeyCode[\"F22\"] = 80] = \"F22\";\n    KeyCode[KeyCode[\"F23\"] = 81] = \"F23\";\n    KeyCode[KeyCode[\"F24\"] = 82] = \"F24\";\n    KeyCode[KeyCode[\"NumLock\"] = 83] = \"NumLock\";\n    KeyCode[KeyCode[\"ScrollLock\"] = 84] = \"ScrollLock\";\n    KeyCode[KeyCode[\"Semicolon\"] = 85] = \"Semicolon\";\n    KeyCode[KeyCode[\"Equal\"] = 86] = \"Equal\";\n    KeyCode[KeyCode[\"Comma\"] = 87] = \"Comma\";\n    KeyCode[KeyCode[\"Minus\"] = 88] = \"Minus\";\n    KeyCode[KeyCode[\"Period\"] = 89] = \"Period\";\n    KeyCode[KeyCode[\"Slash\"] = 90] = \"Slash\";\n    KeyCode[KeyCode[\"Backquote\"] = 91] = \"Backquote\";\n    KeyCode[KeyCode[\"BracketLeft\"] = 92] = \"BracketLeft\";\n    KeyCode[KeyCode[\"Backslash\"] = 93] = \"Backslash\";\n    KeyCode[KeyCode[\"BracketRight\"] = 94] = \"BracketRight\";\n    KeyCode[KeyCode[\"Quote\"] = 95] = \"Quote\";\n    KeyCode[KeyCode[\"OEM_8\"] = 96] = \"OEM_8\";\n    KeyCode[KeyCode[\"IntlBackslash\"] = 97] = \"IntlBackslash\";\n    KeyCode[KeyCode[\"Numpad0\"] = 98] = \"Numpad0\";\n    KeyCode[KeyCode[\"Numpad1\"] = 99] = \"Numpad1\";\n    KeyCode[KeyCode[\"Numpad2\"] = 100] = \"Numpad2\";\n    KeyCode[KeyCode[\"Numpad3\"] = 101] = \"Numpad3\";\n    KeyCode[KeyCode[\"Numpad4\"] = 102] = \"Numpad4\";\n    KeyCode[KeyCode[\"Numpad5\"] = 103] = \"Numpad5\";\n    KeyCode[KeyCode[\"Numpad6\"] = 104] = \"Numpad6\";\n    KeyCode[KeyCode[\"Numpad7\"] = 105] = \"Numpad7\";\n    KeyCode[KeyCode[\"Numpad8\"] = 106] = \"Numpad8\";\n    KeyCode[KeyCode[\"Numpad9\"] = 107] = \"Numpad9\";\n    KeyCode[KeyCode[\"NumpadMultiply\"] = 108] = \"NumpadMultiply\";\n    KeyCode[KeyCode[\"NumpadAdd\"] = 109] = \"NumpadAdd\";\n    KeyCode[KeyCode[\"NUMPAD_SEPARATOR\"] = 110] = \"NUMPAD_SEPARATOR\";\n    KeyCode[KeyCode[\"NumpadSubtract\"] = 111] = \"NumpadSubtract\";\n    KeyCode[KeyCode[\"NumpadDecimal\"] = 112] = \"NumpadDecimal\";\n    KeyCode[KeyCode[\"NumpadDivide\"] = 113] = \"NumpadDivide\";\n    KeyCode[KeyCode[\"KEY_IN_COMPOSITION\"] = 114] = \"KEY_IN_COMPOSITION\";\n    KeyCode[KeyCode[\"ABNT_C1\"] = 115] = \"ABNT_C1\";\n    KeyCode[KeyCode[\"ABNT_C2\"] = 116] = \"ABNT_C2\";\n    KeyCode[KeyCode[\"AudioVolumeMute\"] = 117] = \"AudioVolumeMute\";\n    KeyCode[KeyCode[\"AudioVolumeUp\"] = 118] = \"AudioVolumeUp\";\n    KeyCode[KeyCode[\"AudioVolumeDown\"] = 119] = \"AudioVolumeDown\";\n    KeyCode[KeyCode[\"BrowserSearch\"] = 120] = \"BrowserSearch\";\n    KeyCode[KeyCode[\"BrowserHome\"] = 121] = \"BrowserHome\";\n    KeyCode[KeyCode[\"BrowserBack\"] = 122] = \"BrowserBack\";\n    KeyCode[KeyCode[\"BrowserForward\"] = 123] = \"BrowserForward\";\n    KeyCode[KeyCode[\"MediaTrackNext\"] = 124] = \"MediaTrackNext\";\n    KeyCode[KeyCode[\"MediaTrackPrevious\"] = 125] = \"MediaTrackPrevious\";\n    KeyCode[KeyCode[\"MediaStop\"] = 126] = \"MediaStop\";\n    KeyCode[KeyCode[\"MediaPlayPause\"] = 127] = \"MediaPlayPause\";\n    KeyCode[KeyCode[\"LaunchMediaPlayer\"] = 128] = \"LaunchMediaPlayer\";\n    KeyCode[KeyCode[\"LaunchMail\"] = 129] = \"LaunchMail\";\n    KeyCode[KeyCode[\"LaunchApp2\"] = 130] = \"LaunchApp2\";\n    KeyCode[KeyCode[\"Clear\"] = 131] = \"Clear\";\n    KeyCode[KeyCode[\"MAX_VALUE\"] = 132] = \"MAX_VALUE\";\n})(KeyCode || (KeyCode = {})));\nvar ScanCode;\n( (function(ScanCode) {\n    ScanCode[ScanCode[\"DependsOnKbLayout\"] = -1] = \"DependsOnKbLayout\";\n    ScanCode[ScanCode[\"None\"] = 0] = \"None\";\n    ScanCode[ScanCode[\"Hyper\"] = 1] = \"Hyper\";\n    ScanCode[ScanCode[\"Super\"] = 2] = \"Super\";\n    ScanCode[ScanCode[\"Fn\"] = 3] = \"Fn\";\n    ScanCode[ScanCode[\"FnLock\"] = 4] = \"FnLock\";\n    ScanCode[ScanCode[\"Suspend\"] = 5] = \"Suspend\";\n    ScanCode[ScanCode[\"Resume\"] = 6] = \"Resume\";\n    ScanCode[ScanCode[\"Turbo\"] = 7] = \"Turbo\";\n    ScanCode[ScanCode[\"Sleep\"] = 8] = \"Sleep\";\n    ScanCode[ScanCode[\"WakeUp\"] = 9] = \"WakeUp\";\n    ScanCode[ScanCode[\"KeyA\"] = 10] = \"KeyA\";\n    ScanCode[ScanCode[\"KeyB\"] = 11] = \"KeyB\";\n    ScanCode[ScanCode[\"KeyC\"] = 12] = \"KeyC\";\n    ScanCode[ScanCode[\"KeyD\"] = 13] = \"KeyD\";\n    ScanCode[ScanCode[\"KeyE\"] = 14] = \"KeyE\";\n    ScanCode[ScanCode[\"KeyF\"] = 15] = \"KeyF\";\n    ScanCode[ScanCode[\"KeyG\"] = 16] = \"KeyG\";\n    ScanCode[ScanCode[\"KeyH\"] = 17] = \"KeyH\";\n    ScanCode[ScanCode[\"KeyI\"] = 18] = \"KeyI\";\n    ScanCode[ScanCode[\"KeyJ\"] = 19] = \"KeyJ\";\n    ScanCode[ScanCode[\"KeyK\"] = 20] = \"KeyK\";\n    ScanCode[ScanCode[\"KeyL\"] = 21] = \"KeyL\";\n    ScanCode[ScanCode[\"KeyM\"] = 22] = \"KeyM\";\n    ScanCode[ScanCode[\"KeyN\"] = 23] = \"KeyN\";\n    ScanCode[ScanCode[\"KeyO\"] = 24] = \"KeyO\";\n    ScanCode[ScanCode[\"KeyP\"] = 25] = \"KeyP\";\n    ScanCode[ScanCode[\"KeyQ\"] = 26] = \"KeyQ\";\n    ScanCode[ScanCode[\"KeyR\"] = 27] = \"KeyR\";\n    ScanCode[ScanCode[\"KeyS\"] = 28] = \"KeyS\";\n    ScanCode[ScanCode[\"KeyT\"] = 29] = \"KeyT\";\n    ScanCode[ScanCode[\"KeyU\"] = 30] = \"KeyU\";\n    ScanCode[ScanCode[\"KeyV\"] = 31] = \"KeyV\";\n    ScanCode[ScanCode[\"KeyW\"] = 32] = \"KeyW\";\n    ScanCode[ScanCode[\"KeyX\"] = 33] = \"KeyX\";\n    ScanCode[ScanCode[\"KeyY\"] = 34] = \"KeyY\";\n    ScanCode[ScanCode[\"KeyZ\"] = 35] = \"KeyZ\";\n    ScanCode[ScanCode[\"Digit1\"] = 36] = \"Digit1\";\n    ScanCode[ScanCode[\"Digit2\"] = 37] = \"Digit2\";\n    ScanCode[ScanCode[\"Digit3\"] = 38] = \"Digit3\";\n    ScanCode[ScanCode[\"Digit4\"] = 39] = \"Digit4\";\n    ScanCode[ScanCode[\"Digit5\"] = 40] = \"Digit5\";\n    ScanCode[ScanCode[\"Digit6\"] = 41] = \"Digit6\";\n    ScanCode[ScanCode[\"Digit7\"] = 42] = \"Digit7\";\n    ScanCode[ScanCode[\"Digit8\"] = 43] = \"Digit8\";\n    ScanCode[ScanCode[\"Digit9\"] = 44] = \"Digit9\";\n    ScanCode[ScanCode[\"Digit0\"] = 45] = \"Digit0\";\n    ScanCode[ScanCode[\"Enter\"] = 46] = \"Enter\";\n    ScanCode[ScanCode[\"Escape\"] = 47] = \"Escape\";\n    ScanCode[ScanCode[\"Backspace\"] = 48] = \"Backspace\";\n    ScanCode[ScanCode[\"Tab\"] = 49] = \"Tab\";\n    ScanCode[ScanCode[\"Space\"] = 50] = \"Space\";\n    ScanCode[ScanCode[\"Minus\"] = 51] = \"Minus\";\n    ScanCode[ScanCode[\"Equal\"] = 52] = \"Equal\";\n    ScanCode[ScanCode[\"BracketLeft\"] = 53] = \"BracketLeft\";\n    ScanCode[ScanCode[\"BracketRight\"] = 54] = \"BracketRight\";\n    ScanCode[ScanCode[\"Backslash\"] = 55] = \"Backslash\";\n    ScanCode[ScanCode[\"IntlHash\"] = 56] = \"IntlHash\";\n    ScanCode[ScanCode[\"Semicolon\"] = 57] = \"Semicolon\";\n    ScanCode[ScanCode[\"Quote\"] = 58] = \"Quote\";\n    ScanCode[ScanCode[\"Backquote\"] = 59] = \"Backquote\";\n    ScanCode[ScanCode[\"Comma\"] = 60] = \"Comma\";\n    ScanCode[ScanCode[\"Period\"] = 61] = \"Period\";\n    ScanCode[ScanCode[\"Slash\"] = 62] = \"Slash\";\n    ScanCode[ScanCode[\"CapsLock\"] = 63] = \"CapsLock\";\n    ScanCode[ScanCode[\"F1\"] = 64] = \"F1\";\n    ScanCode[ScanCode[\"F2\"] = 65] = \"F2\";\n    ScanCode[ScanCode[\"F3\"] = 66] = \"F3\";\n    ScanCode[ScanCode[\"F4\"] = 67] = \"F4\";\n    ScanCode[ScanCode[\"F5\"] = 68] = \"F5\";\n    ScanCode[ScanCode[\"F6\"] = 69] = \"F6\";\n    ScanCode[ScanCode[\"F7\"] = 70] = \"F7\";\n    ScanCode[ScanCode[\"F8\"] = 71] = \"F8\";\n    ScanCode[ScanCode[\"F9\"] = 72] = \"F9\";\n    ScanCode[ScanCode[\"F10\"] = 73] = \"F10\";\n    ScanCode[ScanCode[\"F11\"] = 74] = \"F11\";\n    ScanCode[ScanCode[\"F12\"] = 75] = \"F12\";\n    ScanCode[ScanCode[\"PrintScreen\"] = 76] = \"PrintScreen\";\n    ScanCode[ScanCode[\"ScrollLock\"] = 77] = \"ScrollLock\";\n    ScanCode[ScanCode[\"Pause\"] = 78] = \"Pause\";\n    ScanCode[ScanCode[\"Insert\"] = 79] = \"Insert\";\n    ScanCode[ScanCode[\"Home\"] = 80] = \"Home\";\n    ScanCode[ScanCode[\"PageUp\"] = 81] = \"PageUp\";\n    ScanCode[ScanCode[\"Delete\"] = 82] = \"Delete\";\n    ScanCode[ScanCode[\"End\"] = 83] = \"End\";\n    ScanCode[ScanCode[\"PageDown\"] = 84] = \"PageDown\";\n    ScanCode[ScanCode[\"ArrowRight\"] = 85] = \"ArrowRight\";\n    ScanCode[ScanCode[\"ArrowLeft\"] = 86] = \"ArrowLeft\";\n    ScanCode[ScanCode[\"ArrowDown\"] = 87] = \"ArrowDown\";\n    ScanCode[ScanCode[\"ArrowUp\"] = 88] = \"ArrowUp\";\n    ScanCode[ScanCode[\"NumLock\"] = 89] = \"NumLock\";\n    ScanCode[ScanCode[\"NumpadDivide\"] = 90] = \"NumpadDivide\";\n    ScanCode[ScanCode[\"NumpadMultiply\"] = 91] = \"NumpadMultiply\";\n    ScanCode[ScanCode[\"NumpadSubtract\"] = 92] = \"NumpadSubtract\";\n    ScanCode[ScanCode[\"NumpadAdd\"] = 93] = \"NumpadAdd\";\n    ScanCode[ScanCode[\"NumpadEnter\"] = 94] = \"NumpadEnter\";\n    ScanCode[ScanCode[\"Numpad1\"] = 95] = \"Numpad1\";\n    ScanCode[ScanCode[\"Numpad2\"] = 96] = \"Numpad2\";\n    ScanCode[ScanCode[\"Numpad3\"] = 97] = \"Numpad3\";\n    ScanCode[ScanCode[\"Numpad4\"] = 98] = \"Numpad4\";\n    ScanCode[ScanCode[\"Numpad5\"] = 99] = \"Numpad5\";\n    ScanCode[ScanCode[\"Numpad6\"] = 100] = \"Numpad6\";\n    ScanCode[ScanCode[\"Numpad7\"] = 101] = \"Numpad7\";\n    ScanCode[ScanCode[\"Numpad8\"] = 102] = \"Numpad8\";\n    ScanCode[ScanCode[\"Numpad9\"] = 103] = \"Numpad9\";\n    ScanCode[ScanCode[\"Numpad0\"] = 104] = \"Numpad0\";\n    ScanCode[ScanCode[\"NumpadDecimal\"] = 105] = \"NumpadDecimal\";\n    ScanCode[ScanCode[\"IntlBackslash\"] = 106] = \"IntlBackslash\";\n    ScanCode[ScanCode[\"ContextMenu\"] = 107] = \"ContextMenu\";\n    ScanCode[ScanCode[\"Power\"] = 108] = \"Power\";\n    ScanCode[ScanCode[\"NumpadEqual\"] = 109] = \"NumpadEqual\";\n    ScanCode[ScanCode[\"F13\"] = 110] = \"F13\";\n    ScanCode[ScanCode[\"F14\"] = 111] = \"F14\";\n    ScanCode[ScanCode[\"F15\"] = 112] = \"F15\";\n    ScanCode[ScanCode[\"F16\"] = 113] = \"F16\";\n    ScanCode[ScanCode[\"F17\"] = 114] = \"F17\";\n    ScanCode[ScanCode[\"F18\"] = 115] = \"F18\";\n    ScanCode[ScanCode[\"F19\"] = 116] = \"F19\";\n    ScanCode[ScanCode[\"F20\"] = 117] = \"F20\";\n    ScanCode[ScanCode[\"F21\"] = 118] = \"F21\";\n    ScanCode[ScanCode[\"F22\"] = 119] = \"F22\";\n    ScanCode[ScanCode[\"F23\"] = 120] = \"F23\";\n    ScanCode[ScanCode[\"F24\"] = 121] = \"F24\";\n    ScanCode[ScanCode[\"Open\"] = 122] = \"Open\";\n    ScanCode[ScanCode[\"Help\"] = 123] = \"Help\";\n    ScanCode[ScanCode[\"Select\"] = 124] = \"Select\";\n    ScanCode[ScanCode[\"Again\"] = 125] = \"Again\";\n    ScanCode[ScanCode[\"Undo\"] = 126] = \"Undo\";\n    ScanCode[ScanCode[\"Cut\"] = 127] = \"Cut\";\n    ScanCode[ScanCode[\"Copy\"] = 128] = \"Copy\";\n    ScanCode[ScanCode[\"Paste\"] = 129] = \"Paste\";\n    ScanCode[ScanCode[\"Find\"] = 130] = \"Find\";\n    ScanCode[ScanCode[\"AudioVolumeMute\"] = 131] = \"AudioVolumeMute\";\n    ScanCode[ScanCode[\"AudioVolumeUp\"] = 132] = \"AudioVolumeUp\";\n    ScanCode[ScanCode[\"AudioVolumeDown\"] = 133] = \"AudioVolumeDown\";\n    ScanCode[ScanCode[\"NumpadComma\"] = 134] = \"NumpadComma\";\n    ScanCode[ScanCode[\"IntlRo\"] = 135] = \"IntlRo\";\n    ScanCode[ScanCode[\"KanaMode\"] = 136] = \"KanaMode\";\n    ScanCode[ScanCode[\"IntlYen\"] = 137] = \"IntlYen\";\n    ScanCode[ScanCode[\"Convert\"] = 138] = \"Convert\";\n    ScanCode[ScanCode[\"NonConvert\"] = 139] = \"NonConvert\";\n    ScanCode[ScanCode[\"Lang1\"] = 140] = \"Lang1\";\n    ScanCode[ScanCode[\"Lang2\"] = 141] = \"Lang2\";\n    ScanCode[ScanCode[\"Lang3\"] = 142] = \"Lang3\";\n    ScanCode[ScanCode[\"Lang4\"] = 143] = \"Lang4\";\n    ScanCode[ScanCode[\"Lang5\"] = 144] = \"Lang5\";\n    ScanCode[ScanCode[\"Abort\"] = 145] = \"Abort\";\n    ScanCode[ScanCode[\"Props\"] = 146] = \"Props\";\n    ScanCode[ScanCode[\"NumpadParenLeft\"] = 147] = \"NumpadParenLeft\";\n    ScanCode[ScanCode[\"NumpadParenRight\"] = 148] = \"NumpadParenRight\";\n    ScanCode[ScanCode[\"NumpadBackspace\"] = 149] = \"NumpadBackspace\";\n    ScanCode[ScanCode[\"NumpadMemoryStore\"] = 150] = \"NumpadMemoryStore\";\n    ScanCode[ScanCode[\"NumpadMemoryRecall\"] = 151] = \"NumpadMemoryRecall\";\n    ScanCode[ScanCode[\"NumpadMemoryClear\"] = 152] = \"NumpadMemoryClear\";\n    ScanCode[ScanCode[\"NumpadMemoryAdd\"] = 153] = \"NumpadMemoryAdd\";\n    ScanCode[ScanCode[\"NumpadMemorySubtract\"] = 154] = \"NumpadMemorySubtract\";\n    ScanCode[ScanCode[\"NumpadClear\"] = 155] = \"NumpadClear\";\n    ScanCode[ScanCode[\"NumpadClearEntry\"] = 156] = \"NumpadClearEntry\";\n    ScanCode[ScanCode[\"ControlLeft\"] = 157] = \"ControlLeft\";\n    ScanCode[ScanCode[\"ShiftLeft\"] = 158] = \"ShiftLeft\";\n    ScanCode[ScanCode[\"AltLeft\"] = 159] = \"AltLeft\";\n    ScanCode[ScanCode[\"MetaLeft\"] = 160] = \"MetaLeft\";\n    ScanCode[ScanCode[\"ControlRight\"] = 161] = \"ControlRight\";\n    ScanCode[ScanCode[\"ShiftRight\"] = 162] = \"ShiftRight\";\n    ScanCode[ScanCode[\"AltRight\"] = 163] = \"AltRight\";\n    ScanCode[ScanCode[\"MetaRight\"] = 164] = \"MetaRight\";\n    ScanCode[ScanCode[\"BrightnessUp\"] = 165] = \"BrightnessUp\";\n    ScanCode[ScanCode[\"BrightnessDown\"] = 166] = \"BrightnessDown\";\n    ScanCode[ScanCode[\"MediaPlay\"] = 167] = \"MediaPlay\";\n    ScanCode[ScanCode[\"MediaRecord\"] = 168] = \"MediaRecord\";\n    ScanCode[ScanCode[\"MediaFastForward\"] = 169] = \"MediaFastForward\";\n    ScanCode[ScanCode[\"MediaRewind\"] = 170] = \"MediaRewind\";\n    ScanCode[ScanCode[\"MediaTrackNext\"] = 171] = \"MediaTrackNext\";\n    ScanCode[ScanCode[\"MediaTrackPrevious\"] = 172] = \"MediaTrackPrevious\";\n    ScanCode[ScanCode[\"MediaStop\"] = 173] = \"MediaStop\";\n    ScanCode[ScanCode[\"Eject\"] = 174] = \"Eject\";\n    ScanCode[ScanCode[\"MediaPlayPause\"] = 175] = \"MediaPlayPause\";\n    ScanCode[ScanCode[\"MediaSelect\"] = 176] = \"MediaSelect\";\n    ScanCode[ScanCode[\"LaunchMail\"] = 177] = \"LaunchMail\";\n    ScanCode[ScanCode[\"LaunchApp2\"] = 178] = \"LaunchApp2\";\n    ScanCode[ScanCode[\"LaunchApp1\"] = 179] = \"LaunchApp1\";\n    ScanCode[ScanCode[\"SelectTask\"] = 180] = \"SelectTask\";\n    ScanCode[ScanCode[\"LaunchScreenSaver\"] = 181] = \"LaunchScreenSaver\";\n    ScanCode[ScanCode[\"BrowserSearch\"] = 182] = \"BrowserSearch\";\n    ScanCode[ScanCode[\"BrowserHome\"] = 183] = \"BrowserHome\";\n    ScanCode[ScanCode[\"BrowserBack\"] = 184] = \"BrowserBack\";\n    ScanCode[ScanCode[\"BrowserForward\"] = 185] = \"BrowserForward\";\n    ScanCode[ScanCode[\"BrowserStop\"] = 186] = \"BrowserStop\";\n    ScanCode[ScanCode[\"BrowserRefresh\"] = 187] = \"BrowserRefresh\";\n    ScanCode[ScanCode[\"BrowserFavorites\"] = 188] = \"BrowserFavorites\";\n    ScanCode[ScanCode[\"ZoomToggle\"] = 189] = \"ZoomToggle\";\n    ScanCode[ScanCode[\"MailReply\"] = 190] = \"MailReply\";\n    ScanCode[ScanCode[\"MailForward\"] = 191] = \"MailForward\";\n    ScanCode[ScanCode[\"MailSend\"] = 192] = \"MailSend\";\n    ScanCode[ScanCode[\"MAX_VALUE\"] = 193] = \"MAX_VALUE\";\n})(ScanCode || (ScanCode = {})));\nclass KeyCodeStrMap {\n    constructor() {\n        this._keyCodeToStr = [];\n        this._strToKeyCode = Object.create(null);\n    }\n    define(keyCode, str) {\n        this._keyCodeToStr[keyCode] = str;\n        this._strToKeyCode[str.toLowerCase()] = keyCode;\n    }\n    keyCodeToStr(keyCode) {\n        return this._keyCodeToStr[keyCode];\n    }\n    strToKeyCode(str) {\n        return this._strToKeyCode[str.toLowerCase()] || KeyCode.Unknown;\n    }\n}\nconst uiMap = ( new KeyCodeStrMap());\nconst userSettingsUSMap = ( new KeyCodeStrMap());\nconst userSettingsGeneralMap = ( new KeyCodeStrMap());\nconst EVENT_KEY_CODE_MAP = ( new Array(230));\nconst NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE = {};\nconst scanCodeIntToStr = [];\nconst scanCodeStrToInt = Object.create(null);\nconst scanCodeLowerCaseStrToInt = Object.create(null);\nconst ScanCodeUtils = {\n    lowerCaseToEnum: (scanCode) => scanCodeLowerCaseStrToInt[scanCode] || ScanCode.None,\n    toEnum: (scanCode) => scanCodeStrToInt[scanCode] || ScanCode.None,\n    toString: (scanCode) => scanCodeIntToStr[scanCode] || 'None'\n};\nconst IMMUTABLE_CODE_TO_KEY_CODE = [];\nconst IMMUTABLE_KEY_CODE_TO_CODE = [];\nfor (let i = 0; i <= ScanCode.MAX_VALUE; i++) {\n    IMMUTABLE_CODE_TO_KEY_CODE[i] = KeyCode.DependsOnKbLayout;\n}\nfor (let i = 0; i <= KeyCode.MAX_VALUE; i++) {\n    IMMUTABLE_KEY_CODE_TO_CODE[i] = ScanCode.DependsOnKbLayout;\n}\n(function () {\n    const empty = '';\n    const mappings = [\n        [1, ScanCode.None, 'None', KeyCode.Unknown, 'unknown', 0, 'VK_UNKNOWN', empty, empty],\n        [1, ScanCode.Hyper, 'Hyper', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.Super, 'Super', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.Fn, 'Fn', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.FnLock, 'FnLock', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.Suspend, 'Suspend', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.Resume, 'Resume', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.Turbo, 'Turbo', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.Sleep, 'Sleep', KeyCode.Unknown, empty, 0, 'VK_SLEEP', empty, empty],\n        [1, ScanCode.WakeUp, 'WakeUp', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [0, ScanCode.KeyA, 'KeyA', KeyCode.KeyA, 'A', 65, 'VK_A', empty, empty],\n        [0, ScanCode.KeyB, 'KeyB', KeyCode.KeyB, 'B', 66, 'VK_B', empty, empty],\n        [0, ScanCode.KeyC, 'KeyC', KeyCode.KeyC, 'C', 67, 'VK_C', empty, empty],\n        [0, ScanCode.KeyD, 'KeyD', KeyCode.KeyD, 'D', 68, 'VK_D', empty, empty],\n        [0, ScanCode.KeyE, 'KeyE', KeyCode.KeyE, 'E', 69, 'VK_E', empty, empty],\n        [0, ScanCode.KeyF, 'KeyF', KeyCode.KeyF, 'F', 70, 'VK_F', empty, empty],\n        [0, ScanCode.KeyG, 'KeyG', KeyCode.KeyG, 'G', 71, 'VK_G', empty, empty],\n        [0, ScanCode.KeyH, 'KeyH', KeyCode.KeyH, 'H', 72, 'VK_H', empty, empty],\n        [0, ScanCode.KeyI, 'KeyI', KeyCode.KeyI, 'I', 73, 'VK_I', empty, empty],\n        [0, ScanCode.KeyJ, 'KeyJ', KeyCode.KeyJ, 'J', 74, 'VK_J', empty, empty],\n        [0, ScanCode.KeyK, 'KeyK', KeyCode.KeyK, 'K', 75, 'VK_K', empty, empty],\n        [0, ScanCode.KeyL, 'KeyL', KeyCode.KeyL, 'L', 76, 'VK_L', empty, empty],\n        [0, ScanCode.KeyM, 'KeyM', KeyCode.KeyM, 'M', 77, 'VK_M', empty, empty],\n        [0, ScanCode.KeyN, 'KeyN', KeyCode.KeyN, 'N', 78, 'VK_N', empty, empty],\n        [0, ScanCode.KeyO, 'KeyO', KeyCode.KeyO, 'O', 79, 'VK_O', empty, empty],\n        [0, ScanCode.KeyP, 'KeyP', KeyCode.KeyP, 'P', 80, 'VK_P', empty, empty],\n        [0, ScanCode.KeyQ, 'KeyQ', KeyCode.KeyQ, 'Q', 81, 'VK_Q', empty, empty],\n        [0, ScanCode.KeyR, 'KeyR', KeyCode.KeyR, 'R', 82, 'VK_R', empty, empty],\n        [0, ScanCode.KeyS, 'KeyS', KeyCode.KeyS, 'S', 83, 'VK_S', empty, empty],\n        [0, ScanCode.KeyT, 'KeyT', KeyCode.KeyT, 'T', 84, 'VK_T', empty, empty],\n        [0, ScanCode.KeyU, 'KeyU', KeyCode.KeyU, 'U', 85, 'VK_U', empty, empty],\n        [0, ScanCode.KeyV, 'KeyV', KeyCode.KeyV, 'V', 86, 'VK_V', empty, empty],\n        [0, ScanCode.KeyW, 'KeyW', KeyCode.KeyW, 'W', 87, 'VK_W', empty, empty],\n        [0, ScanCode.KeyX, 'KeyX', KeyCode.KeyX, 'X', 88, 'VK_X', empty, empty],\n        [0, ScanCode.KeyY, 'KeyY', KeyCode.KeyY, 'Y', 89, 'VK_Y', empty, empty],\n        [0, ScanCode.KeyZ, 'KeyZ', KeyCode.KeyZ, 'Z', 90, 'VK_Z', empty, empty],\n        [0, ScanCode.Digit1, 'Digit1', KeyCode.Digit1, '1', 49, 'VK_1', empty, empty],\n        [0, ScanCode.Digit2, 'Digit2', KeyCode.Digit2, '2', 50, 'VK_2', empty, empty],\n        [0, ScanCode.Digit3, 'Digit3', KeyCode.Digit3, '3', 51, 'VK_3', empty, empty],\n        [0, ScanCode.Digit4, 'Digit4', KeyCode.Digit4, '4', 52, 'VK_4', empty, empty],\n        [0, ScanCode.Digit5, 'Digit5', KeyCode.Digit5, '5', 53, 'VK_5', empty, empty],\n        [0, ScanCode.Digit6, 'Digit6', KeyCode.Digit6, '6', 54, 'VK_6', empty, empty],\n        [0, ScanCode.Digit7, 'Digit7', KeyCode.Digit7, '7', 55, 'VK_7', empty, empty],\n        [0, ScanCode.Digit8, 'Digit8', KeyCode.Digit8, '8', 56, 'VK_8', empty, empty],\n        [0, ScanCode.Digit9, 'Digit9', KeyCode.Digit9, '9', 57, 'VK_9', empty, empty],\n        [0, ScanCode.Digit0, 'Digit0', KeyCode.Digit0, '0', 48, 'VK_0', empty, empty],\n        [1, ScanCode.Enter, 'Enter', KeyCode.Enter, 'Enter', 13, 'VK_RETURN', empty, empty],\n        [1, ScanCode.Escape, 'Escape', KeyCode.Escape, 'Escape', 27, 'VK_ESCAPE', empty, empty],\n        [1, ScanCode.Backspace, 'Backspace', KeyCode.Backspace, 'Backspace', 8, 'VK_BACK', empty, empty],\n        [1, ScanCode.Tab, 'Tab', KeyCode.Tab, 'Tab', 9, 'VK_TAB', empty, empty],\n        [1, ScanCode.Space, 'Space', KeyCode.Space, 'Space', 32, 'VK_SPACE', empty, empty],\n        [0, ScanCode.Minus, 'Minus', KeyCode.Minus, '-', 189, 'VK_OEM_MINUS', '-', 'OEM_MINUS'],\n        [0, ScanCode.Equal, 'Equal', KeyCode.Equal, '=', 187, 'VK_OEM_PLUS', '=', 'OEM_PLUS'],\n        [0, ScanCode.BracketLeft, 'BracketLeft', KeyCode.BracketLeft, '[', 219, 'VK_OEM_4', '[', 'OEM_4'],\n        [0, ScanCode.BracketRight, 'BracketRight', KeyCode.BracketRight, ']', 221, 'VK_OEM_6', ']', 'OEM_6'],\n        [0, ScanCode.Backslash, 'Backslash', KeyCode.Backslash, '\\\\', 220, 'VK_OEM_5', '\\\\', 'OEM_5'],\n        [0, ScanCode.IntlHash, 'IntlHash', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [0, ScanCode.Semicolon, 'Semicolon', KeyCode.Semicolon, ';', 186, 'VK_OEM_1', ';', 'OEM_1'],\n        [0, ScanCode.Quote, 'Quote', KeyCode.Quote, '\\'', 222, 'VK_OEM_7', '\\'', 'OEM_7'],\n        [0, ScanCode.Backquote, 'Backquote', KeyCode.Backquote, '`', 192, 'VK_OEM_3', '`', 'OEM_3'],\n        [0, ScanCode.Comma, 'Comma', KeyCode.Comma, ',', 188, 'VK_OEM_COMMA', ',', 'OEM_COMMA'],\n        [0, ScanCode.Period, 'Period', KeyCode.Period, '.', 190, 'VK_OEM_PERIOD', '.', 'OEM_PERIOD'],\n        [0, ScanCode.Slash, 'Slash', KeyCode.Slash, '/', 191, 'VK_OEM_2', '/', 'OEM_2'],\n        [1, ScanCode.CapsLock, 'CapsLock', KeyCode.CapsLock, 'CapsLock', 20, 'VK_CAPITAL', empty, empty],\n        [1, ScanCode.F1, 'F1', KeyCode.F1, 'F1', 112, 'VK_F1', empty, empty],\n        [1, ScanCode.F2, 'F2', KeyCode.F2, 'F2', 113, 'VK_F2', empty, empty],\n        [1, ScanCode.F3, 'F3', KeyCode.F3, 'F3', 114, 'VK_F3', empty, empty],\n        [1, ScanCode.F4, 'F4', KeyCode.F4, 'F4', 115, 'VK_F4', empty, empty],\n        [1, ScanCode.F5, 'F5', KeyCode.F5, 'F5', 116, 'VK_F5', empty, empty],\n        [1, ScanCode.F6, 'F6', KeyCode.F6, 'F6', 117, 'VK_F6', empty, empty],\n        [1, ScanCode.F7, 'F7', KeyCode.F7, 'F7', 118, 'VK_F7', empty, empty],\n        [1, ScanCode.F8, 'F8', KeyCode.F8, 'F8', 119, 'VK_F8', empty, empty],\n        [1, ScanCode.F9, 'F9', KeyCode.F9, 'F9', 120, 'VK_F9', empty, empty],\n        [1, ScanCode.F10, 'F10', KeyCode.F10, 'F10', 121, 'VK_F10', empty, empty],\n        [1, ScanCode.F11, 'F11', KeyCode.F11, 'F11', 122, 'VK_F11', empty, empty],\n        [1, ScanCode.F12, 'F12', KeyCode.F12, 'F12', 123, 'VK_F12', empty, empty],\n        [1, ScanCode.PrintScreen, 'PrintScreen', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.ScrollLock, 'ScrollLock', KeyCode.ScrollLock, 'ScrollLock', 145, 'VK_SCROLL', empty, empty],\n        [1, ScanCode.Pause, 'Pause', KeyCode.PauseBreak, 'PauseBreak', 19, 'VK_PAUSE', empty, empty],\n        [1, ScanCode.Insert, 'Insert', KeyCode.Insert, 'Insert', 45, 'VK_INSERT', empty, empty],\n        [1, ScanCode.Home, 'Home', KeyCode.Home, 'Home', 36, 'VK_HOME', empty, empty],\n        [1, ScanCode.PageUp, 'PageUp', KeyCode.PageUp, 'PageUp', 33, 'VK_PRIOR', empty, empty],\n        [1, ScanCode.Delete, 'Delete', KeyCode.Delete, 'Delete', 46, 'VK_DELETE', empty, empty],\n        [1, ScanCode.End, 'End', KeyCode.End, 'End', 35, 'VK_END', empty, empty],\n        [1, ScanCode.PageDown, 'PageDown', KeyCode.PageDown, 'PageDown', 34, 'VK_NEXT', empty, empty],\n        [1, ScanCode.ArrowRight, 'ArrowRight', KeyCode.RightArrow, 'RightArrow', 39, 'VK_RIGHT', 'Right', empty],\n        [1, ScanCode.ArrowLeft, 'ArrowLeft', KeyCode.LeftArrow, 'LeftArrow', 37, 'VK_LEFT', 'Left', empty],\n        [1, ScanCode.ArrowDown, 'ArrowDown', KeyCode.DownArrow, 'DownArrow', 40, 'VK_DOWN', 'Down', empty],\n        [1, ScanCode.ArrowUp, 'ArrowUp', KeyCode.UpArrow, 'UpArrow', 38, 'VK_UP', 'Up', empty],\n        [1, ScanCode.NumLock, 'NumLock', KeyCode.NumLock, 'NumLock', 144, 'VK_NUMLOCK', empty, empty],\n        [1, ScanCode.NumpadDivide, 'NumpadDivide', KeyCode.NumpadDivide, 'NumPad_Divide', 111, 'VK_DIVIDE', empty, empty],\n        [1, ScanCode.NumpadMultiply, 'NumpadMultiply', KeyCode.NumpadMultiply, 'NumPad_Multiply', 106, 'VK_MULTIPLY', empty, empty],\n        [1, ScanCode.NumpadSubtract, 'NumpadSubtract', KeyCode.NumpadSubtract, 'NumPad_Subtract', 109, 'VK_SUBTRACT', empty, empty],\n        [1, ScanCode.NumpadAdd, 'NumpadAdd', KeyCode.NumpadAdd, 'NumPad_Add', 107, 'VK_ADD', empty, empty],\n        [1, ScanCode.NumpadEnter, 'NumpadEnter', KeyCode.Enter, empty, 0, empty, empty, empty],\n        [1, ScanCode.Numpad1, 'Numpad1', KeyCode.Numpad1, 'NumPad1', 97, 'VK_NUMPAD1', empty, empty],\n        [1, ScanCode.Numpad2, 'Numpad2', KeyCode.Numpad2, 'NumPad2', 98, 'VK_NUMPAD2', empty, empty],\n        [1, ScanCode.Numpad3, 'Numpad3', KeyCode.Numpad3, 'NumPad3', 99, 'VK_NUMPAD3', empty, empty],\n        [1, ScanCode.Numpad4, 'Numpad4', KeyCode.Numpad4, 'NumPad4', 100, 'VK_NUMPAD4', empty, empty],\n        [1, ScanCode.Numpad5, 'Numpad5', KeyCode.Numpad5, 'NumPad5', 101, 'VK_NUMPAD5', empty, empty],\n        [1, ScanCode.Numpad6, 'Numpad6', KeyCode.Numpad6, 'NumPad6', 102, 'VK_NUMPAD6', empty, empty],\n        [1, ScanCode.Numpad7, 'Numpad7', KeyCode.Numpad7, 'NumPad7', 103, 'VK_NUMPAD7', empty, empty],\n        [1, ScanCode.Numpad8, 'Numpad8', KeyCode.Numpad8, 'NumPad8', 104, 'VK_NUMPAD8', empty, empty],\n        [1, ScanCode.Numpad9, 'Numpad9', KeyCode.Numpad9, 'NumPad9', 105, 'VK_NUMPAD9', empty, empty],\n        [1, ScanCode.Numpad0, 'Numpad0', KeyCode.Numpad0, 'NumPad0', 96, 'VK_NUMPAD0', empty, empty],\n        [1, ScanCode.NumpadDecimal, 'NumpadDecimal', KeyCode.NumpadDecimal, 'NumPad_Decimal', 110, 'VK_DECIMAL', empty, empty],\n        [0, ScanCode.IntlBackslash, 'IntlBackslash', KeyCode.IntlBackslash, 'OEM_102', 226, 'VK_OEM_102', empty, empty],\n        [1, ScanCode.ContextMenu, 'ContextMenu', KeyCode.ContextMenu, 'ContextMenu', 93, empty, empty, empty],\n        [1, ScanCode.Power, 'Power', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.NumpadEqual, 'NumpadEqual', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.F13, 'F13', KeyCode.F13, 'F13', 124, 'VK_F13', empty, empty],\n        [1, ScanCode.F14, 'F14', KeyCode.F14, 'F14', 125, 'VK_F14', empty, empty],\n        [1, ScanCode.F15, 'F15', KeyCode.F15, 'F15', 126, 'VK_F15', empty, empty],\n        [1, ScanCode.F16, 'F16', KeyCode.F16, 'F16', 127, 'VK_F16', empty, empty],\n        [1, ScanCode.F17, 'F17', KeyCode.F17, 'F17', 128, 'VK_F17', empty, empty],\n        [1, ScanCode.F18, 'F18', KeyCode.F18, 'F18', 129, 'VK_F18', empty, empty],\n        [1, ScanCode.F19, 'F19', KeyCode.F19, 'F19', 130, 'VK_F19', empty, empty],\n        [1, ScanCode.F20, 'F20', KeyCode.F20, 'F20', 131, 'VK_F20', empty, empty],\n        [1, ScanCode.F21, 'F21', KeyCode.F21, 'F21', 132, 'VK_F21', empty, empty],\n        [1, ScanCode.F22, 'F22', KeyCode.F22, 'F22', 133, 'VK_F22', empty, empty],\n        [1, ScanCode.F23, 'F23', KeyCode.F23, 'F23', 134, 'VK_F23', empty, empty],\n        [1, ScanCode.F24, 'F24', KeyCode.F24, 'F24', 135, 'VK_F24', empty, empty],\n        [1, ScanCode.Open, 'Open', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.Help, 'Help', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.Select, 'Select', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.Again, 'Again', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.Undo, 'Undo', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.Cut, 'Cut', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.Copy, 'Copy', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.Paste, 'Paste', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.Find, 'Find', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.AudioVolumeMute, 'AudioVolumeMute', KeyCode.AudioVolumeMute, 'AudioVolumeMute', 173, 'VK_VOLUME_MUTE', empty, empty],\n        [1, ScanCode.AudioVolumeUp, 'AudioVolumeUp', KeyCode.AudioVolumeUp, 'AudioVolumeUp', 175, 'VK_VOLUME_UP', empty, empty],\n        [1, ScanCode.AudioVolumeDown, 'AudioVolumeDown', KeyCode.AudioVolumeDown, 'AudioVolumeDown', 174, 'VK_VOLUME_DOWN', empty, empty],\n        [1, ScanCode.NumpadComma, 'NumpadComma', KeyCode.NUMPAD_SEPARATOR, 'NumPad_Separator', 108, 'VK_SEPARATOR', empty, empty],\n        [0, ScanCode.IntlRo, 'IntlRo', KeyCode.ABNT_C1, 'ABNT_C1', 193, 'VK_ABNT_C1', empty, empty],\n        [1, ScanCode.KanaMode, 'KanaMode', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [0, ScanCode.IntlYen, 'IntlYen', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.Convert, 'Convert', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.NonConvert, 'NonConvert', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.Lang1, 'Lang1', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.Lang2, 'Lang2', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.Lang3, 'Lang3', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.Lang4, 'Lang4', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.Lang5, 'Lang5', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.Abort, 'Abort', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.Props, 'Props', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.NumpadParenLeft, 'NumpadParenLeft', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.NumpadParenRight, 'NumpadParenRight', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.NumpadBackspace, 'NumpadBackspace', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.NumpadMemoryStore, 'NumpadMemoryStore', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.NumpadMemoryRecall, 'NumpadMemoryRecall', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.NumpadMemoryClear, 'NumpadMemoryClear', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.NumpadMemoryAdd, 'NumpadMemoryAdd', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.NumpadMemorySubtract, 'NumpadMemorySubtract', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.NumpadClear, 'NumpadClear', KeyCode.Clear, 'Clear', 12, 'VK_CLEAR', empty, empty],\n        [1, ScanCode.NumpadClearEntry, 'NumpadClearEntry', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Ctrl, 'Ctrl', 17, 'VK_CONTROL', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Shift, 'Shift', 16, 'VK_SHIFT', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Alt, 'Alt', 18, 'VK_MENU', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Meta, 'Meta', 91, 'VK_COMMAND', empty, empty],\n        [1, ScanCode.ControlLeft, 'ControlLeft', KeyCode.Ctrl, empty, 0, 'VK_LCONTROL', empty, empty],\n        [1, ScanCode.ShiftLeft, 'ShiftLeft', KeyCode.Shift, empty, 0, 'VK_LSHIFT', empty, empty],\n        [1, ScanCode.AltLeft, 'AltLeft', KeyCode.Alt, empty, 0, 'VK_LMENU', empty, empty],\n        [1, ScanCode.MetaLeft, 'MetaLeft', KeyCode.Meta, empty, 0, 'VK_LWIN', empty, empty],\n        [1, ScanCode.ControlRight, 'ControlRight', KeyCode.Ctrl, empty, 0, 'VK_RCONTROL', empty, empty],\n        [1, ScanCode.ShiftRight, 'ShiftRight', KeyCode.Shift, empty, 0, 'VK_RSHIFT', empty, empty],\n        [1, ScanCode.AltRight, 'AltRight', KeyCode.Alt, empty, 0, 'VK_RMENU', empty, empty],\n        [1, ScanCode.MetaRight, 'MetaRight', KeyCode.Meta, empty, 0, 'VK_RWIN', empty, empty],\n        [1, ScanCode.BrightnessUp, 'BrightnessUp', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.BrightnessDown, 'BrightnessDown', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.MediaPlay, 'MediaPlay', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.MediaRecord, 'MediaRecord', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.MediaFastForward, 'MediaFastForward', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.MediaRewind, 'MediaRewind', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.MediaTrackNext, 'MediaTrackNext', KeyCode.MediaTrackNext, 'MediaTrackNext', 176, 'VK_MEDIA_NEXT_TRACK', empty, empty],\n        [1, ScanCode.MediaTrackPrevious, 'MediaTrackPrevious', KeyCode.MediaTrackPrevious, 'MediaTrackPrevious', 177, 'VK_MEDIA_PREV_TRACK', empty, empty],\n        [1, ScanCode.MediaStop, 'MediaStop', KeyCode.MediaStop, 'MediaStop', 178, 'VK_MEDIA_STOP', empty, empty],\n        [1, ScanCode.Eject, 'Eject', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.MediaPlayPause, 'MediaPlayPause', KeyCode.MediaPlayPause, 'MediaPlayPause', 179, 'VK_MEDIA_PLAY_PAUSE', empty, empty],\n        [1, ScanCode.MediaSelect, 'MediaSelect', KeyCode.LaunchMediaPlayer, 'LaunchMediaPlayer', 181, 'VK_MEDIA_LAUNCH_MEDIA_SELECT', empty, empty],\n        [1, ScanCode.LaunchMail, 'LaunchMail', KeyCode.LaunchMail, 'LaunchMail', 180, 'VK_MEDIA_LAUNCH_MAIL', empty, empty],\n        [1, ScanCode.LaunchApp2, 'LaunchApp2', KeyCode.LaunchApp2, 'LaunchApp2', 183, 'VK_MEDIA_LAUNCH_APP2', empty, empty],\n        [1, ScanCode.LaunchApp1, 'LaunchApp1', KeyCode.Unknown, empty, 0, 'VK_MEDIA_LAUNCH_APP1', empty, empty],\n        [1, ScanCode.SelectTask, 'SelectTask', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.LaunchScreenSaver, 'LaunchScreenSaver', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.BrowserSearch, 'BrowserSearch', KeyCode.BrowserSearch, 'BrowserSearch', 170, 'VK_BROWSER_SEARCH', empty, empty],\n        [1, ScanCode.BrowserHome, 'BrowserHome', KeyCode.BrowserHome, 'BrowserHome', 172, 'VK_BROWSER_HOME', empty, empty],\n        [1, ScanCode.BrowserBack, 'BrowserBack', KeyCode.BrowserBack, 'BrowserBack', 166, 'VK_BROWSER_BACK', empty, empty],\n        [1, ScanCode.BrowserForward, 'BrowserForward', KeyCode.BrowserForward, 'BrowserForward', 167, 'VK_BROWSER_FORWARD', empty, empty],\n        [1, ScanCode.BrowserStop, 'BrowserStop', KeyCode.Unknown, empty, 0, 'VK_BROWSER_STOP', empty, empty],\n        [1, ScanCode.BrowserRefresh, 'BrowserRefresh', KeyCode.Unknown, empty, 0, 'VK_BROWSER_REFRESH', empty, empty],\n        [1, ScanCode.BrowserFavorites, 'BrowserFavorites', KeyCode.Unknown, empty, 0, 'VK_BROWSER_FAVORITES', empty, empty],\n        [1, ScanCode.ZoomToggle, 'ZoomToggle', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.MailReply, 'MailReply', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.MailForward, 'MailForward', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.MailSend, 'MailSend', KeyCode.Unknown, empty, 0, empty, empty, empty],\n        [1, ScanCode.None, empty, KeyCode.KEY_IN_COMPOSITION, 'KeyInComposition', 229, empty, empty, empty],\n        [1, ScanCode.None, empty, KeyCode.ABNT_C2, 'ABNT_C2', 194, 'VK_ABNT_C2', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.OEM_8, 'OEM_8', 223, 'VK_OEM_8', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_KANA', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_HANGUL', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_JUNJA', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_FINAL', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_HANJA', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_KANJI', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_CONVERT', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_NONCONVERT', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_ACCEPT', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_MODECHANGE', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_SELECT', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_PRINT', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_EXECUTE', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_SNAPSHOT', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_HELP', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_APPS', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_PROCESSKEY', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_PACKET', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_DBE_SBCSCHAR', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_DBE_DBCSCHAR', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_ATTN', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_CRSEL', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_EXSEL', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_EREOF', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_PLAY', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_ZOOM', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_NONAME', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_PA1', empty, empty],\n        [1, ScanCode.None, empty, KeyCode.Unknown, empty, 0, 'VK_OEM_CLEAR', empty, empty],\n    ];\n    const seenKeyCode = [];\n    const seenScanCode = [];\n    for (const mapping of mappings) {\n        const [immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel] = mapping;\n        if (!seenScanCode[scanCode]) {\n            seenScanCode[scanCode] = true;\n            scanCodeIntToStr[scanCode] = scanCodeStr;\n            scanCodeStrToInt[scanCodeStr] = scanCode;\n            scanCodeLowerCaseStrToInt[scanCodeStr.toLowerCase()] = scanCode;\n            if (immutable) {\n                IMMUTABLE_CODE_TO_KEY_CODE[scanCode] = keyCode;\n                if ((keyCode !== KeyCode.Unknown)\n                    && (keyCode !== KeyCode.Enter)\n                    && (keyCode !== KeyCode.Ctrl)\n                    && (keyCode !== KeyCode.Shift)\n                    && (keyCode !== KeyCode.Alt)\n                    && (keyCode !== KeyCode.Meta)) {\n                    IMMUTABLE_KEY_CODE_TO_CODE[keyCode] = scanCode;\n                }\n            }\n        }\n        if (!seenKeyCode[keyCode]) {\n            seenKeyCode[keyCode] = true;\n            if (!keyCodeStr) {\n                throw ( new Error(\n                    `String representation missing for key code ${keyCode} around scan code ${scanCodeStr}`\n                ));\n            }\n            uiMap.define(keyCode, keyCodeStr);\n            userSettingsUSMap.define(keyCode, usUserSettingsLabel || keyCodeStr);\n            userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel || usUserSettingsLabel || keyCodeStr);\n        }\n        if (eventKeyCode) {\n            EVENT_KEY_CODE_MAP[eventKeyCode] = keyCode;\n        }\n        if (vkey) {\n            NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE[vkey] = keyCode;\n        }\n    }\n    IMMUTABLE_KEY_CODE_TO_CODE[KeyCode.Enter] = ScanCode.Enter;\n})();\nvar KeyCodeUtils;\n( (function(KeyCodeUtils) {\n    function toString(keyCode) {\n        return uiMap.keyCodeToStr(keyCode);\n    }\n    KeyCodeUtils.toString = toString;\n    function fromString(key) {\n        return uiMap.strToKeyCode(key);\n    }\n    KeyCodeUtils.fromString = fromString;\n    function toUserSettingsUS(keyCode) {\n        return userSettingsUSMap.keyCodeToStr(keyCode);\n    }\n    KeyCodeUtils.toUserSettingsUS = toUserSettingsUS;\n    function toUserSettingsGeneral(keyCode) {\n        return userSettingsGeneralMap.keyCodeToStr(keyCode);\n    }\n    KeyCodeUtils.toUserSettingsGeneral = toUserSettingsGeneral;\n    function fromUserSettings(key) {\n        return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);\n    }\n    KeyCodeUtils.fromUserSettings = fromUserSettings;\n    function toElectronAccelerator(keyCode) {\n        if (keyCode >= KeyCode.Numpad0 && keyCode <= KeyCode.NumpadDivide) {\n            return null;\n        }\n        switch (keyCode) {\n            case KeyCode.UpArrow:\n                return 'Up';\n            case KeyCode.DownArrow:\n                return 'Down';\n            case KeyCode.LeftArrow:\n                return 'Left';\n            case KeyCode.RightArrow:\n                return 'Right';\n        }\n        return uiMap.keyCodeToStr(keyCode);\n    }\n    KeyCodeUtils.toElectronAccelerator = toElectronAccelerator;\n})(KeyCodeUtils || (KeyCodeUtils = {})));\nvar KeyMod$1;\n( (function(KeyMod) {\n    KeyMod[KeyMod[\"CtrlCmd\"] = 2048] = \"CtrlCmd\";\n    KeyMod[KeyMod[\"Shift\"] = 1024] = \"Shift\";\n    KeyMod[KeyMod[\"Alt\"] = 512] = \"Alt\";\n    KeyMod[KeyMod[\"WinCtrl\"] = 256] = \"WinCtrl\";\n})(KeyMod$1 || (KeyMod$1 = {})));\nfunction KeyChord(firstPart, secondPart) {\n    const chordPart = ((secondPart & 0x0000FFFF) << 16) >>> 0;\n    return (firstPart | chordPart) >>> 0;\n}\nexport { EVENT_KEY_CODE_MAP, IMMUTABLE_CODE_TO_KEY_CODE, IMMUTABLE_KEY_CODE_TO_CODE, KeyChord, KeyCode, KeyCodeUtils, KeyMod$1 as KeyMod, NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE, ScanCode, ScanCodeUtils };\n","import { transformErrorForSerialization } from '../errors.js';\nimport { Emitter } from '../event.js';\nimport { Disposable } from '../lifecycle.js';\nimport { getAllMethodNames } from '../objects.js';\nimport { isWeb } from '../platform.js';\nimport { isUpperAsciiLetter } from '../strings.js';\nconst INITIALIZE = '$initialize';\nlet webWorkerWarningLogged = false;\nfunction logOnceWebWorkerWarning(err) {\n    if (!isWeb) {\n        return;\n    }\n    if (!webWorkerWarningLogged) {\n        webWorkerWarningLogged = true;\n        console.warn('Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq');\n    }\n    console.warn(err.message);\n}\nvar MessageType;\n( (function(MessageType) {\n    MessageType[MessageType[\"Request\"] = 0] = \"Request\";\n    MessageType[MessageType[\"Reply\"] = 1] = \"Reply\";\n    MessageType[MessageType[\"SubscribeEvent\"] = 2] = \"SubscribeEvent\";\n    MessageType[MessageType[\"Event\"] = 3] = \"Event\";\n    MessageType[MessageType[\"UnsubscribeEvent\"] = 4] = \"UnsubscribeEvent\";\n})(MessageType || (MessageType = {})));\nclass RequestMessage {\n    constructor(vsWorker, req, method, args) {\n        this.vsWorker = vsWorker;\n        this.req = req;\n        this.method = method;\n        this.args = args;\n        this.type = MessageType.Request;\n    }\n}\nclass ReplyMessage {\n    constructor(vsWorker, seq, res, err) {\n        this.vsWorker = vsWorker;\n        this.seq = seq;\n        this.res = res;\n        this.err = err;\n        this.type = MessageType.Reply;\n    }\n}\nclass SubscribeEventMessage {\n    constructor(vsWorker, req, eventName, arg) {\n        this.vsWorker = vsWorker;\n        this.req = req;\n        this.eventName = eventName;\n        this.arg = arg;\n        this.type = MessageType.SubscribeEvent;\n    }\n}\nclass EventMessage {\n    constructor(vsWorker, req, event) {\n        this.vsWorker = vsWorker;\n        this.req = req;\n        this.event = event;\n        this.type = MessageType.Event;\n    }\n}\nclass UnsubscribeEventMessage {\n    constructor(vsWorker, req) {\n        this.vsWorker = vsWorker;\n        this.req = req;\n        this.type = MessageType.UnsubscribeEvent;\n    }\n}\nclass SimpleWorkerProtocol {\n    constructor(handler) {\n        this._workerId = -1;\n        this._handler = handler;\n        this._lastSentReq = 0;\n        this._pendingReplies = Object.create(null);\n        this._pendingEmitters = ( new Map());\n        this._pendingEvents = ( new Map());\n    }\n    setWorkerId(workerId) {\n        this._workerId = workerId;\n    }\n    sendMessage(method, args) {\n        const req = String(++this._lastSentReq);\n        return ( new Promise((resolve, reject) => {\n            this._pendingReplies[req] = {\n                resolve: resolve,\n                reject: reject\n            };\n            this._send(( new RequestMessage(this._workerId, req, method, args)));\n        }));\n    }\n    listen(eventName, arg) {\n        let req = null;\n        const emitter = ( new Emitter({\n            onWillAddFirstListener: () => {\n                req = String(++this._lastSentReq);\n                this._pendingEmitters.set(req, emitter);\n                this._send(( new SubscribeEventMessage(this._workerId, req, eventName, arg)));\n            },\n            onDidRemoveLastListener: () => {\n                this._pendingEmitters.delete(req);\n                this._send(( new UnsubscribeEventMessage(this._workerId, req)));\n                req = null;\n            }\n        }));\n        return emitter.event;\n    }\n    handleMessage(message) {\n        if (!message || !message.vsWorker) {\n            return;\n        }\n        if (this._workerId !== -1 && message.vsWorker !== this._workerId) {\n            return;\n        }\n        this._handleMessage(message);\n    }\n    _handleMessage(msg) {\n        switch (msg.type) {\n            case MessageType.Reply:\n                return this._handleReplyMessage(msg);\n            case MessageType.Request:\n                return this._handleRequestMessage(msg);\n            case MessageType.SubscribeEvent:\n                return this._handleSubscribeEventMessage(msg);\n            case MessageType.Event:\n                return this._handleEventMessage(msg);\n            case MessageType.UnsubscribeEvent:\n                return this._handleUnsubscribeEventMessage(msg);\n        }\n    }\n    _handleReplyMessage(replyMessage) {\n        if (!this._pendingReplies[replyMessage.seq]) {\n            console.warn('Got reply to unknown seq');\n            return;\n        }\n        const reply = this._pendingReplies[replyMessage.seq];\n        delete this._pendingReplies[replyMessage.seq];\n        if (replyMessage.err) {\n            let err = replyMessage.err;\n            if (replyMessage.err.$isError) {\n                err = ( new Error());\n                err.name = replyMessage.err.name;\n                err.message = replyMessage.err.message;\n                err.stack = replyMessage.err.stack;\n            }\n            reply.reject(err);\n            return;\n        }\n        reply.resolve(replyMessage.res);\n    }\n    _handleRequestMessage(requestMessage) {\n        const req = requestMessage.req;\n        const result = this._handler.handleMessage(requestMessage.method, requestMessage.args);\n        result.then((r) => {\n            this._send(( new ReplyMessage(this._workerId, req, r, undefined)));\n        }, (e) => {\n            if (e.detail instanceof Error) {\n                e.detail = transformErrorForSerialization(e.detail);\n            }\n            this._send(( new ReplyMessage(this._workerId, req, undefined, transformErrorForSerialization(e))));\n        });\n    }\n    _handleSubscribeEventMessage(msg) {\n        const req = msg.req;\n        const disposable = this._handler.handleEvent(msg.eventName, msg.arg)((event) => {\n            this._send(( new EventMessage(this._workerId, req, event)));\n        });\n        this._pendingEvents.set(req, disposable);\n    }\n    _handleEventMessage(msg) {\n        if (!( this._pendingEmitters.has(msg.req))) {\n            console.warn('Got event for unknown req');\n            return;\n        }\n        this._pendingEmitters.get(msg.req).fire(msg.event);\n    }\n    _handleUnsubscribeEventMessage(msg) {\n        if (!( this._pendingEvents.has(msg.req))) {\n            console.warn('Got unsubscribe for unknown req');\n            return;\n        }\n        this._pendingEvents.get(msg.req).dispose();\n        this._pendingEvents.delete(msg.req);\n    }\n    _send(msg) {\n        const transfer = [];\n        if (msg.type === MessageType.Request) {\n            for (let i = 0; i < msg.args.length; i++) {\n                if (msg.args[i] instanceof ArrayBuffer) {\n                    transfer.push(msg.args[i]);\n                }\n            }\n        }\n        else if (msg.type === MessageType.Reply) {\n            if (msg.res instanceof ArrayBuffer) {\n                transfer.push(msg.res);\n            }\n        }\n        this._handler.sendMessage(msg, transfer);\n    }\n}\nclass SimpleWorkerClient extends Disposable {\n    constructor(workerFactory, moduleId, host) {\n        super();\n        let lazyProxyReject = null;\n        this._worker = this._register(workerFactory.create('vs/base/common/worker/simpleWorker', (msg) => {\n            this._protocol.handleMessage(msg);\n        }, (err) => {\n            lazyProxyReject?.(err);\n        }));\n        this._protocol = ( new SimpleWorkerProtocol({\n            sendMessage: (msg, transfer) => {\n                this._worker.postMessage(msg, transfer);\n            },\n            handleMessage: (method, args) => {\n                if (typeof host[method] !== 'function') {\n                    return Promise.reject(( new Error('Missing method ' + method + ' on main thread host.')));\n                }\n                try {\n                    return Promise.resolve(host[method].apply(host, args));\n                }\n                catch (e) {\n                    return Promise.reject(e);\n                }\n            },\n            handleEvent: (eventName, arg) => {\n                if (propertyIsDynamicEvent(eventName)) {\n                    const event = host[eventName].call(host, arg);\n                    if (typeof event !== 'function') {\n                        throw ( new Error(`Missing dynamic event ${eventName} on main thread host.`));\n                    }\n                    return event;\n                }\n                if (propertyIsEvent(eventName)) {\n                    const event = host[eventName];\n                    if (typeof event !== 'function') {\n                        throw ( new Error(`Missing event ${eventName} on main thread host.`));\n                    }\n                    return event;\n                }\n                throw ( new Error(`Malformed event name ${eventName}`));\n            }\n        }));\n        this._protocol.setWorkerId(this._worker.getId());\n        let loaderConfiguration = null;\n        if (typeof globalThis.requirejs !== 'undefined') {\n            loaderConfiguration = globalThis.requirejs.s.contexts._.config;\n        }\n        const hostMethods = getAllMethodNames(host);\n        this._onModuleLoaded = this._protocol.sendMessage(INITIALIZE, [\n            this._worker.getId(),\n            JSON.parse(JSON.stringify(loaderConfiguration)),\n            moduleId,\n            hostMethods,\n        ]);\n        const proxyMethodRequest = (method, args) => {\n            return this._request(method, args);\n        };\n        const proxyListen = (eventName, arg) => {\n            return this._protocol.listen(eventName, arg);\n        };\n        this._lazyProxy = ( new Promise((resolve, reject) => {\n            lazyProxyReject = reject;\n            this._onModuleLoaded.then((availableMethods) => {\n                resolve(createProxyObject(availableMethods, proxyMethodRequest, proxyListen));\n            }, (e) => {\n                reject(e);\n                this._onError('Worker failed to load ' + moduleId, e);\n            });\n        }));\n    }\n    getProxyObject() {\n        return this._lazyProxy;\n    }\n    _request(method, args) {\n        return ( new Promise((resolve, reject) => {\n            this._onModuleLoaded.then(() => {\n                this._protocol.sendMessage(method, args).then(resolve, reject);\n            }, reject);\n        }));\n    }\n    _onError(message, error) {\n        console.error(message);\n        console.info(error);\n    }\n}\nfunction propertyIsEvent(name) {\n    return name[0] === 'o' && name[1] === 'n' && isUpperAsciiLetter(name.charCodeAt(2));\n}\nfunction propertyIsDynamicEvent(name) {\n    return /^onDynamic/.test(name) && isUpperAsciiLetter(name.charCodeAt(9));\n}\nfunction createProxyObject(methodNames, invoke, proxyListen) {\n    const createProxyMethod = (method) => {\n        return function () {\n            const args = Array.prototype.slice.call(arguments, 0);\n            return invoke(method, args);\n        };\n    };\n    const createProxyDynamicEvent = (eventName) => {\n        return function (arg) {\n            return proxyListen(eventName, arg);\n        };\n    };\n    const result = {};\n    for (const methodName of methodNames) {\n        if (propertyIsDynamicEvent(methodName)) {\n            result[methodName] = createProxyDynamicEvent(methodName);\n            continue;\n        }\n        if (propertyIsEvent(methodName)) {\n            result[methodName] = proxyListen(methodName, undefined);\n            continue;\n        }\n        result[methodName] = createProxyMethod(methodName);\n    }\n    return result;\n}\nclass SimpleWorkerServer {\n    constructor(postMessage, requestHandlerFactory) {\n        this._requestHandlerFactory = requestHandlerFactory;\n        this._requestHandler = null;\n        this._protocol = ( new SimpleWorkerProtocol({\n            sendMessage: (msg, transfer) => {\n                postMessage(msg, transfer);\n            },\n            handleMessage: (method, args) => this._handleMessage(method, args),\n            handleEvent: (eventName, arg) => this._handleEvent(eventName, arg)\n        }));\n    }\n    onmessage(msg) {\n        this._protocol.handleMessage(msg);\n    }\n    _handleMessage(method, args) {\n        if (method === INITIALIZE) {\n            return this.initialize(args[0], args[1], args[2], args[3]);\n        }\n        if (!this._requestHandler || typeof this._requestHandler[method] !== 'function') {\n            return Promise.reject(( new Error('Missing requestHandler or method: ' + method)));\n        }\n        try {\n            return Promise.resolve(this._requestHandler[method].apply(this._requestHandler, args));\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n    _handleEvent(eventName, arg) {\n        if (!this._requestHandler) {\n            throw ( new Error(`Missing requestHandler`));\n        }\n        if (propertyIsDynamicEvent(eventName)) {\n            const event = this._requestHandler[eventName].call(this._requestHandler, arg);\n            if (typeof event !== 'function') {\n                throw ( new Error(`Missing dynamic event ${eventName} on request handler.`));\n            }\n            return event;\n        }\n        if (propertyIsEvent(eventName)) {\n            const event = this._requestHandler[eventName];\n            if (typeof event !== 'function') {\n                throw ( new Error(`Missing event ${eventName} on request handler.`));\n            }\n            return event;\n        }\n        throw ( new Error(`Malformed event name ${eventName}`));\n    }\n    initialize(workerId, loaderConfig, moduleId, hostMethods) {\n        this._protocol.setWorkerId(workerId);\n        const proxyMethodRequest = (method, args) => {\n            return this._protocol.sendMessage(method, args);\n        };\n        const proxyListen = (eventName, arg) => {\n            return this._protocol.listen(eventName, arg);\n        };\n        const hostProxy = createProxyObject(hostMethods, proxyMethodRequest, proxyListen);\n        if (this._requestHandlerFactory) {\n            this._requestHandler = this._requestHandlerFactory(hostProxy);\n            return Promise.resolve(getAllMethodNames(this._requestHandler));\n        }\n        if (loaderConfig) {\n            if (typeof loaderConfig.baseUrl !== 'undefined') {\n                delete loaderConfig['baseUrl'];\n            }\n            if (typeof loaderConfig.paths !== 'undefined') {\n                if (typeof loaderConfig.paths.vs !== 'undefined') {\n                    delete loaderConfig.paths['vs'];\n                }\n            }\n            if (typeof loaderConfig.trustedTypesPolicy !== 'undefined') {\n                delete loaderConfig['trustedTypesPolicy'];\n            }\n            loaderConfig.catchError = true;\n            globalThis.require.config(loaderConfig);\n        }\n        return ( new Promise((resolve, reject) => {\n            const req = undefined;\n            req([moduleId], (module) => {\n                this._requestHandler = module.create(hostProxy);\n                if (!this._requestHandler) {\n                    reject(( new Error(`No RequestHandler!`)));\n                    return;\n                }\n                resolve(getAllMethodNames(this._requestHandler));\n            }, reject);\n        }));\n    }\n}\nexport { SimpleWorkerClient, SimpleWorkerServer, logOnceWebWorkerWarning };\n","import { BugIndicatingError } from '../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\nimport { Range } from './range.js';\nimport { findFirstIdxMonotonousOrArrLen, findLastMonotonous, findLastIdxMonotonous } from '../../../base/common/arraysFind.js';\nclass LineRange {\n    static fromRange(range) {\n        return ( new LineRange(range.startLineNumber, range.endLineNumber));\n    }\n    static fromRangeInclusive(range) {\n        return ( new LineRange(range.startLineNumber, range.endLineNumber + 1));\n    }\n    static subtract(a, b) {\n        if (!b) {\n            return [a];\n        }\n        if (a.startLineNumber < b.startLineNumber && b.endLineNumberExclusive < a.endLineNumberExclusive) {\n            return [\n                ( new LineRange(a.startLineNumber, b.startLineNumber)),\n                ( new LineRange(b.endLineNumberExclusive, a.endLineNumberExclusive))\n            ];\n        }\n        else if (b.startLineNumber <= a.startLineNumber && a.endLineNumberExclusive <= b.endLineNumberExclusive) {\n            return [];\n        }\n        else if (b.endLineNumberExclusive < a.endLineNumberExclusive) {\n            return [( new LineRange(\n                Math.max(b.endLineNumberExclusive, a.startLineNumber),\n                a.endLineNumberExclusive\n            ))];\n        }\n        else {\n            return [( new LineRange(a.startLineNumber, Math.min(b.startLineNumber, a.endLineNumberExclusive)))];\n        }\n    }\n    static joinMany(lineRanges) {\n        if (lineRanges.length === 0) {\n            return [];\n        }\n        let result = ( new LineRangeSet(lineRanges[0].slice()));\n        for (let i = 1; i < lineRanges.length; i++) {\n            result = result.getUnion(( new LineRangeSet(lineRanges[i].slice())));\n        }\n        return result.ranges;\n    }\n    static join(lineRanges) {\n        if (lineRanges.length === 0) {\n            throw ( new BugIndicatingError('lineRanges cannot be empty'));\n        }\n        let startLineNumber = lineRanges[0].startLineNumber;\n        let endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;\n        for (let i = 1; i < lineRanges.length; i++) {\n            startLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);\n            endLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);\n        }\n        return ( new LineRange(startLineNumber, endLineNumberExclusive));\n    }\n    static ofLength(startLineNumber, length) {\n        return ( new LineRange(startLineNumber, startLineNumber + length));\n    }\n    static deserialize(lineRange) {\n        return ( new LineRange(lineRange[0], lineRange[1]));\n    }\n    constructor(startLineNumber, endLineNumberExclusive) {\n        if (startLineNumber > endLineNumberExclusive) {\n            throw ( new BugIndicatingError(\n                `startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`\n            ));\n        }\n        this.startLineNumber = startLineNumber;\n        this.endLineNumberExclusive = endLineNumberExclusive;\n    }\n    contains(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    get isEmpty() {\n        return this.startLineNumber === this.endLineNumberExclusive;\n    }\n    delta(offset) {\n        return ( new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset));\n    }\n    deltaLength(offset) {\n        return ( new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset));\n    }\n    get length() {\n        return this.endLineNumberExclusive - this.startLineNumber;\n    }\n    join(other) {\n        return ( new LineRange(\n            Math.min(this.startLineNumber, other.startLineNumber),\n            Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive)\n        ));\n    }\n    toString() {\n        return `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n    }\n    intersect(other) {\n        const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n        const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n        if (startLineNumber <= endLineNumberExclusive) {\n            return ( new LineRange(startLineNumber, endLineNumberExclusive));\n        }\n        return undefined;\n    }\n    intersectsStrict(other) {\n        return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n    }\n    overlapOrTouch(other) {\n        return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n    }\n    equals(b) {\n        return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n    }\n    toInclusiveRange() {\n        if (this.isEmpty) {\n            return null;\n        }\n        return ( new Range(\n            this.startLineNumber,\n            1,\n            this.endLineNumberExclusive - 1,\n            Number.MAX_SAFE_INTEGER\n        ));\n    }\n    toExclusiveRange() {\n        return ( new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1));\n    }\n    mapToLineArray(f) {\n        const result = [];\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            result.push(f(lineNumber));\n        }\n        return result;\n    }\n    forEach(f) {\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            f(lineNumber);\n        }\n    }\n    serialize() {\n        return [this.startLineNumber, this.endLineNumberExclusive];\n    }\n    includes(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    toOffsetRange() {\n        return ( new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1));\n    }\n}\nclass LineRangeSet {\n    constructor(\n    _normalizedRanges = []) {\n        this._normalizedRanges = _normalizedRanges;\n    }\n    get ranges() {\n        return this._normalizedRanges;\n    }\n    addRange(range) {\n        if (range.length === 0) {\n            return;\n        }\n        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n            this._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n        }\n        else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n            const joinRange = this._normalizedRanges[joinRangeStartIdx];\n            this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n        }\n        else {\n            const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n            this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n        }\n    }\n    contains(lineNumber) {\n        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber <= lineNumber);\n        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\n    }\n    intersects(range) {\n        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);\n        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;\n    }\n    getUnion(other) {\n        if (this._normalizedRanges.length === 0) {\n            return other;\n        }\n        if (other._normalizedRanges.length === 0) {\n            return this;\n        }\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        let current = null;\n        while (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {\n            let next = null;\n            if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n                const lineRange1 = this._normalizedRanges[i1];\n                const lineRange2 = other._normalizedRanges[i2];\n                if (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n                    next = lineRange1;\n                    i1++;\n                }\n                else {\n                    next = lineRange2;\n                    i2++;\n                }\n            }\n            else if (i1 < this._normalizedRanges.length) {\n                next = this._normalizedRanges[i1];\n                i1++;\n            }\n            else {\n                next = other._normalizedRanges[i2];\n                i2++;\n            }\n            if (current === null) {\n                current = next;\n            }\n            else {\n                if (current.endLineNumberExclusive >= next.startLineNumber) {\n                    current = ( new LineRange(\n                        current.startLineNumber,\n                        Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive)\n                    ));\n                }\n                else {\n                    result.push(current);\n                    current = next;\n                }\n            }\n        }\n        if (current !== null) {\n            result.push(current);\n        }\n        return ( new LineRangeSet(result));\n    }\n    subtractFrom(range) {\n        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n            return ( new LineRangeSet([range]));\n        }\n        const result = [];\n        let startLineNumber = range.startLineNumber;\n        for (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n            const r = this._normalizedRanges[i];\n            if (r.startLineNumber > startLineNumber) {\n                result.push(( new LineRange(startLineNumber, r.startLineNumber)));\n            }\n            startLineNumber = r.endLineNumberExclusive;\n        }\n        if (startLineNumber < range.endLineNumberExclusive) {\n            result.push(( new LineRange(startLineNumber, range.endLineNumberExclusive)));\n        }\n        return ( new LineRangeSet(result));\n    }\n    toString() {\n        return ( this._normalizedRanges.map(r => ( r.toString()))).join(', ');\n    }\n    getIntersection(other) {\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n            const r1 = this._normalizedRanges[i1];\n            const r2 = other._normalizedRanges[i2];\n            const i = r1.intersect(r2);\n            if (i && !i.isEmpty) {\n                result.push(i);\n            }\n            if (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n                i1++;\n            }\n            else {\n                i2++;\n            }\n        }\n        return ( new LineRangeSet(result));\n    }\n    getWithDelta(value) {\n        return ( new LineRangeSet(( this._normalizedRanges.map(r => r.delta(value)))));\n    }\n}\nexport { LineRange, LineRangeSet };\n","import { BugIndicatingError } from '../../../base/common/errors.js';\nclass OffsetRange {\n    static addRange(range, sortedRanges) {\n        let i = 0;\n        while (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {\n            i++;\n        }\n        let j = i;\n        while (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {\n            j++;\n        }\n        if (i === j) {\n            sortedRanges.splice(i, 0, range);\n        }\n        else {\n            const start = Math.min(range.start, sortedRanges[i].start);\n            const end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);\n            sortedRanges.splice(i, j - i, ( new OffsetRange(start, end)));\n        }\n    }\n    static tryCreate(start, endExclusive) {\n        if (start > endExclusive) {\n            return undefined;\n        }\n        return ( new OffsetRange(start, endExclusive));\n    }\n    static ofLength(length) {\n        return ( new OffsetRange(0, length));\n    }\n    static ofStartAndLength(start, length) {\n        return ( new OffsetRange(start, start + length));\n    }\n    constructor(start, endExclusive) {\n        this.start = start;\n        this.endExclusive = endExclusive;\n        if (start > endExclusive) {\n            throw ( new BugIndicatingError(`Invalid range: ${( this.toString())}`));\n        }\n    }\n    get isEmpty() {\n        return this.start === this.endExclusive;\n    }\n    delta(offset) {\n        return ( new OffsetRange(this.start + offset, this.endExclusive + offset));\n    }\n    deltaStart(offset) {\n        return ( new OffsetRange(this.start + offset, this.endExclusive));\n    }\n    deltaEnd(offset) {\n        return ( new OffsetRange(this.start, this.endExclusive + offset));\n    }\n    get length() {\n        return this.endExclusive - this.start;\n    }\n    toString() {\n        return `[${this.start}, ${this.endExclusive})`;\n    }\n    equals(other) {\n        return this.start === other.start && this.endExclusive === other.endExclusive;\n    }\n    containsRange(other) {\n        return this.start <= other.start && other.endExclusive <= this.endExclusive;\n    }\n    contains(offset) {\n        return this.start <= offset && offset < this.endExclusive;\n    }\n    join(other) {\n        return ( new OffsetRange(\n            Math.min(this.start, other.start),\n            Math.max(this.endExclusive, other.endExclusive)\n        ));\n    }\n    intersect(other) {\n        const start = Math.max(this.start, other.start);\n        const end = Math.min(this.endExclusive, other.endExclusive);\n        if (start <= end) {\n            return ( new OffsetRange(start, end));\n        }\n        return undefined;\n    }\n    intersects(other) {\n        const start = Math.max(this.start, other.start);\n        const end = Math.min(this.endExclusive, other.endExclusive);\n        return start < end;\n    }\n    intersectsOrTouches(other) {\n        const start = Math.max(this.start, other.start);\n        const end = Math.min(this.endExclusive, other.endExclusive);\n        return start <= end;\n    }\n    isBefore(other) {\n        return this.endExclusive <= other.start;\n    }\n    isAfter(other) {\n        return this.start >= other.endExclusive;\n    }\n    slice(arr) {\n        return arr.slice(this.start, this.endExclusive);\n    }\n    substring(str) {\n        return str.substring(this.start, this.endExclusive);\n    }\n    clip(value) {\n        if (this.isEmpty) {\n            throw ( new BugIndicatingError(`Invalid clipping range: ${( this.toString())}`));\n        }\n        return Math.max(this.start, Math.min(this.endExclusive - 1, value));\n    }\n    clipCyclic(value) {\n        if (this.isEmpty) {\n            throw ( new BugIndicatingError(`Invalid clipping range: ${( this.toString())}`));\n        }\n        if (value < this.start) {\n            return this.endExclusive - ((this.start - value) % this.length);\n        }\n        if (value >= this.endExclusive) {\n            return this.start + ((value - this.start) % this.length);\n        }\n        return value;\n    }\n    map(f) {\n        const result = [];\n        for (let i = this.start; i < this.endExclusive; i++) {\n            result.push(f(i));\n        }\n        return result;\n    }\n    forEach(f) {\n        for (let i = this.start; i < this.endExclusive; i++) {\n            f(i);\n        }\n    }\n}\nclass OffsetRangeSet {\n    constructor() {\n        this._sortedRanges = [];\n    }\n    addRange(range) {\n        let i = 0;\n        while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive < range.start) {\n            i++;\n        }\n        let j = i;\n        while (j < this._sortedRanges.length && this._sortedRanges[j].start <= range.endExclusive) {\n            j++;\n        }\n        if (i === j) {\n            this._sortedRanges.splice(i, 0, range);\n        }\n        else {\n            const start = Math.min(range.start, this._sortedRanges[i].start);\n            const end = Math.max(range.endExclusive, this._sortedRanges[j - 1].endExclusive);\n            this._sortedRanges.splice(i, j - i, ( new OffsetRange(start, end)));\n        }\n    }\n    toString() {\n        return ( this._sortedRanges.map(r => ( r.toString()))).join(', ');\n    }\n    intersectsStrict(other) {\n        let i = 0;\n        while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive <= other.start) {\n            i++;\n        }\n        return i < this._sortedRanges.length && this._sortedRanges[i].start < other.endExclusive;\n    }\n    intersectWithRange(other) {\n        const result = ( new OffsetRangeSet());\n        for (const range of this._sortedRanges) {\n            const intersection = range.intersect(other);\n            if (intersection) {\n                result.addRange(intersection);\n            }\n        }\n        return result;\n    }\n    intersectWithRangeLength(other) {\n        return this.intersectWithRange(other).length;\n    }\n    get length() {\n        return this._sortedRanges.reduce((prev, cur) => prev + cur.length, 0);\n    }\n}\nexport { OffsetRange, OffsetRangeSet };\n","import { findLastIdxMonotonous } from '../../../base/common/arraysFind.js';\nimport { OffsetRange } from './offsetRange.js';\nimport { Position } from './position.js';\nimport { Range } from './range.js';\nimport { TextLength } from './textLength.js';\nclass PositionOffsetTransformer {\n    constructor(text) {\n        this.text = text;\n        this.lineStartOffsetByLineIdx = [];\n        this.lineStartOffsetByLineIdx.push(0);\n        for (let i = 0; i < text.length; i++) {\n            if (text.charAt(i) === '\\n') {\n                this.lineStartOffsetByLineIdx.push(i + 1);\n            }\n        }\n    }\n    getOffset(position) {\n        return this.lineStartOffsetByLineIdx[position.lineNumber - 1] + position.column - 1;\n    }\n    getOffsetRange(range) {\n        return ( new OffsetRange(\n            this.getOffset(range.getStartPosition()),\n            this.getOffset(range.getEndPosition())\n        ));\n    }\n    getPosition(offset) {\n        const idx = findLastIdxMonotonous(this.lineStartOffsetByLineIdx, i => i <= offset);\n        const lineNumber = idx + 1;\n        const column = offset - this.lineStartOffsetByLineIdx[idx] + 1;\n        return ( new Position(lineNumber, column));\n    }\n    getRange(offsetRange) {\n        return Range.fromPositions(this.getPosition(offsetRange.start), this.getPosition(offsetRange.endExclusive));\n    }\n    getTextLength(offsetRange) {\n        return TextLength.ofRange(this.getRange(offsetRange));\n    }\n    get textLength() {\n        const lineIdx = this.lineStartOffsetByLineIdx.length - 1;\n        return ( new TextLength(lineIdx, this.text.length - this.lineStartOffsetByLineIdx[lineIdx]));\n    }\n}\nexport { PositionOffsetTransformer };\n","import { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { Position } from './position.js';\nimport { PositionOffsetTransformer } from './positionToOffset.js';\nimport { Range } from './range.js';\nimport { TextLength } from './textLength.js';\nclass TextEdit {\n    static single(originalRange, newText) {\n        return ( new TextEdit([( new SingleTextEdit(originalRange, newText))]));\n    }\n    constructor(edits) {\n        this.edits = edits;\n        assertFn(() => checkAdjacentItems(edits, (a, b) => a.range.getEndPosition().isBeforeOrEqual(b.range.getStartPosition())));\n    }\n    normalize() {\n        const edits = [];\n        for (const edit of this.edits) {\n            if (edits.length > 0 && edits[edits.length - 1].range.getEndPosition().equals(edit.range.getStartPosition())) {\n                const last = edits[edits.length - 1];\n                edits[edits.length - 1] = ( new SingleTextEdit(last.range.plusRange(edit.range), last.text + edit.text));\n            }\n            else if (!edit.isEmpty) {\n                edits.push(edit);\n            }\n        }\n        return ( new TextEdit(edits));\n    }\n    mapPosition(position) {\n        let lineDelta = 0;\n        let curLine = 0;\n        let columnDeltaInCurLine = 0;\n        for (const edit of this.edits) {\n            const start = edit.range.getStartPosition();\n            const end = edit.range.getEndPosition();\n            if (position.isBeforeOrEqual(start)) {\n                break;\n            }\n            const len = TextLength.ofText(edit.text);\n            if (position.isBefore(end)) {\n                const startPos = ( new Position(\n                    start.lineNumber + lineDelta,\n                    start.column + (start.lineNumber + lineDelta === curLine ? columnDeltaInCurLine : 0)\n                ));\n                const endPos = len.addToPosition(startPos);\n                return rangeFromPositions(startPos, endPos);\n            }\n            lineDelta += len.lineCount - (edit.range.endLineNumber - edit.range.startLineNumber);\n            if (len.lineCount === 0) {\n                if (end.lineNumber !== start.lineNumber) {\n                    columnDeltaInCurLine += len.columnCount - (end.column - 1);\n                }\n                else {\n                    columnDeltaInCurLine += len.columnCount - (end.column - start.column);\n                }\n            }\n            else {\n                columnDeltaInCurLine = len.columnCount;\n            }\n            curLine = end.lineNumber + lineDelta;\n        }\n        return ( new Position(\n            position.lineNumber + lineDelta,\n            position.column + (position.lineNumber + lineDelta === curLine ? columnDeltaInCurLine : 0)\n        ));\n    }\n    mapRange(range) {\n        function getStart(p) {\n            return p instanceof Position ? p : p.getStartPosition();\n        }\n        function getEnd(p) {\n            return p instanceof Position ? p : p.getEndPosition();\n        }\n        const start = getStart(this.mapPosition(range.getStartPosition()));\n        const end = getEnd(this.mapPosition(range.getEndPosition()));\n        return rangeFromPositions(start, end);\n    }\n    inverseMapPosition(positionAfterEdit, doc) {\n        const reversed = this.inverse(doc);\n        return reversed.mapPosition(positionAfterEdit);\n    }\n    inverseMapRange(range, doc) {\n        const reversed = this.inverse(doc);\n        return reversed.mapRange(range);\n    }\n    apply(text) {\n        let result = '';\n        let lastEditEnd = ( new Position(1, 1));\n        for (const edit of this.edits) {\n            const editRange = edit.range;\n            const editStart = editRange.getStartPosition();\n            const editEnd = editRange.getEndPosition();\n            const r = rangeFromPositions(lastEditEnd, editStart);\n            if (!r.isEmpty()) {\n                result += text.getValueOfRange(r);\n            }\n            result += edit.text;\n            lastEditEnd = editEnd;\n        }\n        const r = rangeFromPositions(lastEditEnd, text.endPositionExclusive);\n        if (!r.isEmpty()) {\n            result += text.getValueOfRange(r);\n        }\n        return result;\n    }\n    applyToString(str) {\n        const strText = ( new StringText(str));\n        return this.apply(strText);\n    }\n    inverse(doc) {\n        const ranges = this.getNewRanges();\n        return ( new TextEdit(( this.edits.map((e, idx) => ( new SingleTextEdit(ranges[idx], doc.getValueOfRange(e.range)))))));\n    }\n    getNewRanges() {\n        const newRanges = [];\n        let previousEditEndLineNumber = 0;\n        let lineOffset = 0;\n        let columnOffset = 0;\n        for (const edit of this.edits) {\n            const textLength = TextLength.ofText(edit.text);\n            const newRangeStart = Position.lift({\n                lineNumber: edit.range.startLineNumber + lineOffset,\n                column: edit.range.startColumn + (edit.range.startLineNumber === previousEditEndLineNumber ? columnOffset : 0)\n            });\n            const newRange = textLength.createRange(newRangeStart);\n            newRanges.push(newRange);\n            lineOffset = newRange.endLineNumber - edit.range.endLineNumber;\n            columnOffset = newRange.endColumn - edit.range.endColumn;\n            previousEditEndLineNumber = edit.range.endLineNumber;\n        }\n        return newRanges;\n    }\n}\nclass SingleTextEdit {\n    constructor(range, text) {\n        this.range = range;\n        this.text = text;\n    }\n    get isEmpty() {\n        return this.range.isEmpty() && this.text.length === 0;\n    }\n    static equals(first, second) {\n        return first.range.equalsRange(second.range) && first.text === second.text;\n    }\n    toSingleEditOperation() {\n        return {\n            range: this.range,\n            text: this.text,\n        };\n    }\n}\nfunction rangeFromPositions(start, end) {\n    if (start.lineNumber === end.lineNumber && start.column === Number.MAX_SAFE_INTEGER) {\n        return Range.fromPositions(end, end);\n    }\n    else if (!start.isBeforeOrEqual(end)) {\n        throw ( new BugIndicatingError('start must be before end'));\n    }\n    return ( new Range(start.lineNumber, start.column, end.lineNumber, end.column));\n}\nclass AbstractText {\n    get endPositionExclusive() {\n        return this.length.addToPosition(( new Position(1, 1)));\n    }\n    getValue() {\n        return this.getValueOfRange(this.length.toRange());\n    }\n}\nclass StringText extends AbstractText {\n    constructor(value) {\n        super();\n        this.value = value;\n        this._t = ( new PositionOffsetTransformer(this.value));\n    }\n    getValueOfRange(range) {\n        return this._t.getOffsetRange(range).substring(this.value);\n    }\n    get length() {\n        return this._t.textLength;\n    }\n}\nexport { AbstractText, SingleTextEdit, StringText, TextEdit };\n","import { Position } from './position.js';\nimport { Range } from './range.js';\nclass TextLength {\n    static { this.zero = ( new TextLength(0, 0)); }\n    static lengthDiffNonNegative(start, end) {\n        if (end.isLessThan(start)) {\n            return TextLength.zero;\n        }\n        if (start.lineCount === end.lineCount) {\n            return ( new TextLength(0, end.columnCount - start.columnCount));\n        }\n        else {\n            return ( new TextLength(end.lineCount - start.lineCount, end.columnCount));\n        }\n    }\n    static betweenPositions(position1, position2) {\n        if (position1.lineNumber === position2.lineNumber) {\n            return ( new TextLength(0, position2.column - position1.column));\n        }\n        else {\n            return ( new TextLength(position2.lineNumber - position1.lineNumber, position2.column - 1));\n        }\n    }\n    static ofRange(range) {\n        return TextLength.betweenPositions(range.getStartPosition(), range.getEndPosition());\n    }\n    static ofText(text) {\n        let line = 0;\n        let column = 0;\n        for (const c of text) {\n            if (c === '\\n') {\n                line++;\n                column = 0;\n            }\n            else {\n                column++;\n            }\n        }\n        return ( new TextLength(line, column));\n    }\n    constructor(lineCount, columnCount) {\n        this.lineCount = lineCount;\n        this.columnCount = columnCount;\n    }\n    isZero() {\n        return this.lineCount === 0 && this.columnCount === 0;\n    }\n    isLessThan(other) {\n        if (this.lineCount !== other.lineCount) {\n            return this.lineCount < other.lineCount;\n        }\n        return this.columnCount < other.columnCount;\n    }\n    isGreaterThan(other) {\n        if (this.lineCount !== other.lineCount) {\n            return this.lineCount > other.lineCount;\n        }\n        return this.columnCount > other.columnCount;\n    }\n    isGreaterThanOrEqualTo(other) {\n        if (this.lineCount !== other.lineCount) {\n            return this.lineCount > other.lineCount;\n        }\n        return this.columnCount >= other.columnCount;\n    }\n    equals(other) {\n        return this.lineCount === other.lineCount && this.columnCount === other.columnCount;\n    }\n    compare(other) {\n        if (this.lineCount !== other.lineCount) {\n            return this.lineCount - other.lineCount;\n        }\n        return this.columnCount - other.columnCount;\n    }\n    add(other) {\n        if (other.lineCount === 0) {\n            return ( new TextLength(this.lineCount, this.columnCount + other.columnCount));\n        }\n        else {\n            return ( new TextLength(this.lineCount + other.lineCount, other.columnCount));\n        }\n    }\n    createRange(startPosition) {\n        if (this.lineCount === 0) {\n            return ( new Range(\n                startPosition.lineNumber,\n                startPosition.column,\n                startPosition.lineNumber,\n                startPosition.column + this.columnCount\n            ));\n        }\n        else {\n            return ( new Range(\n                startPosition.lineNumber,\n                startPosition.column,\n                startPosition.lineNumber + this.lineCount,\n                this.columnCount + 1\n            ));\n        }\n    }\n    toRange() {\n        return ( new Range(1, 1, this.lineCount + 1, this.columnCount + 1));\n    }\n    addToPosition(position) {\n        if (this.lineCount === 0) {\n            return ( new Position(position.lineNumber, position.column + this.columnCount));\n        }\n        else {\n            return ( new Position(position.lineNumber + this.lineCount, this.columnCount + 1));\n        }\n    }\n    toString() {\n        return `${this.lineCount},${this.columnCount}`;\n    }\n}\nexport { TextLength };\n","import { forEachAdjacent } from '../../../../../base/common/arrays.js';\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { OffsetRange } from '../../../core/offsetRange.js';\nclass DiffAlgorithmResult {\n    static trivial(seq1, seq2) {\n        return ( new DiffAlgorithmResult([( new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length)))], false));\n    }\n    static trivialTimedOut(seq1, seq2) {\n        return ( new DiffAlgorithmResult([( new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length)))], true));\n    }\n    constructor(diffs,\n    hitTimeout) {\n        this.diffs = diffs;\n        this.hitTimeout = hitTimeout;\n    }\n}\nclass SequenceDiff {\n    static invert(sequenceDiffs, doc1Length) {\n        const result = [];\n        forEachAdjacent(sequenceDiffs, (a, b) => {\n            result.push(SequenceDiff.fromOffsetPairs(a ? a.getEndExclusives() : OffsetPair.zero, b ? b.getStarts() : ( new OffsetPair(\n                doc1Length,\n                (a ? a.seq2Range.endExclusive - a.seq1Range.endExclusive : 0) + doc1Length\n            ))));\n        });\n        return result;\n    }\n    static fromOffsetPairs(start, endExclusive) {\n        return ( new SequenceDiff(( new OffsetRange(start.offset1, endExclusive.offset1)), ( new OffsetRange(start.offset2, endExclusive.offset2))));\n    }\n    constructor(seq1Range, seq2Range) {\n        this.seq1Range = seq1Range;\n        this.seq2Range = seq2Range;\n    }\n    swap() {\n        return ( new SequenceDiff(this.seq2Range, this.seq1Range));\n    }\n    toString() {\n        return `${this.seq1Range} <-> ${this.seq2Range}`;\n    }\n    join(other) {\n        return ( new SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range)));\n    }\n    delta(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return ( new SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset)));\n    }\n    deltaStart(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return ( new SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset)));\n    }\n    deltaEnd(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return ( new SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset)));\n    }\n    intersectsOrTouches(other) {\n        return this.seq1Range.intersectsOrTouches(other.seq1Range) || this.seq2Range.intersectsOrTouches(other.seq2Range);\n    }\n    intersect(other) {\n        const i1 = this.seq1Range.intersect(other.seq1Range);\n        const i2 = this.seq2Range.intersect(other.seq2Range);\n        if (!i1 || !i2) {\n            return undefined;\n        }\n        return ( new SequenceDiff(i1, i2));\n    }\n    getStarts() {\n        return ( new OffsetPair(this.seq1Range.start, this.seq2Range.start));\n    }\n    getEndExclusives() {\n        return ( new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive));\n    }\n}\nclass OffsetPair {\n    static { this.zero = ( new OffsetPair(0, 0)); }\n    static { this.max = ( new OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)); }\n    constructor(offset1, offset2) {\n        this.offset1 = offset1;\n        this.offset2 = offset2;\n    }\n    toString() {\n        return `${this.offset1} <-> ${this.offset2}`;\n    }\n    delta(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return ( new OffsetPair(this.offset1 + offset, this.offset2 + offset));\n    }\n    equals(other) {\n        return this.offset1 === other.offset1 && this.offset2 === other.offset2;\n    }\n}\nclass InfiniteTimeout {\n    static { this.instance = ( new InfiniteTimeout()); }\n    isValid() {\n        return true;\n    }\n}\nclass DateTimeout {\n    constructor(timeout) {\n        this.timeout = timeout;\n        this.startTime = Date.now();\n        this.valid = true;\n        if (timeout <= 0) {\n            throw ( new BugIndicatingError('timeout must be positive'));\n        }\n    }\n    isValid() {\n        const valid = Date.now() - this.startTime < this.timeout;\n        if (!valid && this.valid) {\n            this.valid = false;\n            debugger;\n        }\n        return this.valid;\n    }\n    disable() {\n        this.timeout = Number.MAX_SAFE_INTEGER;\n        this.isValid = () => true;\n        this.valid = true;\n    }\n}\nexport { DateTimeout, DiffAlgorithmResult, InfiniteTimeout, OffsetPair, SequenceDiff };\n","import { OffsetRange } from '../../../core/offsetRange.js';\nimport { DiffAlgorithmResult, InfiniteTimeout, SequenceDiff } from './diffAlgorithm.js';\nimport { Array2D } from '../utils.js';\nclass DynamicProgrammingDiffing {\n    compute(sequence1, sequence2, timeout = InfiniteTimeout.instance, equalityScore) {\n        if (sequence1.length === 0 || sequence2.length === 0) {\n            return DiffAlgorithmResult.trivial(sequence1, sequence2);\n        }\n        const lcsLengths = ( new Array2D(sequence1.length, sequence2.length));\n        const directions = ( new Array2D(sequence1.length, sequence2.length));\n        const lengths = ( new Array2D(sequence1.length, sequence2.length));\n        for (let s1 = 0; s1 < sequence1.length; s1++) {\n            for (let s2 = 0; s2 < sequence2.length; s2++) {\n                if (!timeout.isValid()) {\n                    return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\n                }\n                const horizontalLen = s1 === 0 ? 0 : lcsLengths.get(s1 - 1, s2);\n                const verticalLen = s2 === 0 ? 0 : lcsLengths.get(s1, s2 - 1);\n                let extendedSeqScore;\n                if (sequence1.getElement(s1) === sequence2.getElement(s2)) {\n                    if (s1 === 0 || s2 === 0) {\n                        extendedSeqScore = 0;\n                    }\n                    else {\n                        extendedSeqScore = lcsLengths.get(s1 - 1, s2 - 1);\n                    }\n                    if (s1 > 0 && s2 > 0 && directions.get(s1 - 1, s2 - 1) === 3) {\n                        extendedSeqScore += lengths.get(s1 - 1, s2 - 1);\n                    }\n                    extendedSeqScore += (equalityScore ? equalityScore(s1, s2) : 1);\n                }\n                else {\n                    extendedSeqScore = -1;\n                }\n                const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n                if (newValue === extendedSeqScore) {\n                    const prevLen = s1 > 0 && s2 > 0 ? lengths.get(s1 - 1, s2 - 1) : 0;\n                    lengths.set(s1, s2, prevLen + 1);\n                    directions.set(s1, s2, 3);\n                }\n                else if (newValue === horizontalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 1);\n                }\n                else if (newValue === verticalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 2);\n                }\n                lcsLengths.set(s1, s2, newValue);\n            }\n        }\n        const result = [];\n        let lastAligningPosS1 = sequence1.length;\n        let lastAligningPosS2 = sequence2.length;\n        function reportDecreasingAligningPositions(s1, s2) {\n            if (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {\n                result.push(( new SequenceDiff(( new OffsetRange(s1 + 1, lastAligningPosS1)), ( new OffsetRange(s2 + 1, lastAligningPosS2)))));\n            }\n            lastAligningPosS1 = s1;\n            lastAligningPosS2 = s2;\n        }\n        let s1 = sequence1.length - 1;\n        let s2 = sequence2.length - 1;\n        while (s1 >= 0 && s2 >= 0) {\n            if (directions.get(s1, s2) === 3) {\n                reportDecreasingAligningPositions(s1, s2);\n                s1--;\n                s2--;\n            }\n            else {\n                if (directions.get(s1, s2) === 1) {\n                    s1--;\n                }\n                else {\n                    s2--;\n                }\n            }\n        }\n        reportDecreasingAligningPositions(-1, -1);\n        result.reverse();\n        return ( new DiffAlgorithmResult(result, false));\n    }\n}\nexport { DynamicProgrammingDiffing };\n","import { OffsetRange } from '../../../core/offsetRange.js';\nimport { DiffAlgorithmResult, InfiniteTimeout, SequenceDiff } from './diffAlgorithm.js';\nclass MyersDiffAlgorithm {\n    compute(seq1, seq2, timeout = InfiniteTimeout.instance) {\n        if (seq1.length === 0 || seq2.length === 0) {\n            return DiffAlgorithmResult.trivial(seq1, seq2);\n        }\n        const seqX = seq1;\n        const seqY = seq2;\n        function getXAfterSnake(x, y) {\n            while (x < seqX.length && y < seqY.length && seqX.getElement(x) === seqY.getElement(y)) {\n                x++;\n                y++;\n            }\n            return x;\n        }\n        let d = 0;\n        const V = ( new FastInt32Array());\n        V.set(0, getXAfterSnake(0, 0));\n        const paths = ( new FastArrayNegativeIndices());\n        paths.set(0, V.get(0) === 0 ? null : ( new SnakePath(null, 0, 0, V.get(0))));\n        let k = 0;\n        loop: while (true) {\n            d++;\n            if (!timeout.isValid()) {\n                return DiffAlgorithmResult.trivialTimedOut(seqX, seqY);\n            }\n            const lowerBound = -Math.min(d, seqY.length + (d % 2));\n            const upperBound = Math.min(d, seqX.length + (d % 2));\n            for (k = lowerBound; k <= upperBound; k += 2) {\n                const maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1);\n                const maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1;\n                const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);\n                const y = x - k;\n                if (x > seqX.length || y > seqY.length) {\n                    continue;\n                }\n                const newMaxX = getXAfterSnake(x, y);\n                V.set(k, newMaxX);\n                const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n                paths.set(k, newMaxX !== x ? ( new SnakePath(lastPath, x, y, newMaxX - x)) : lastPath);\n                if (V.get(k) === seqX.length && V.get(k) - k === seqY.length) {\n                    break loop;\n                }\n            }\n        }\n        let path = paths.get(k);\n        const result = [];\n        let lastAligningPosS1 = seqX.length;\n        let lastAligningPosS2 = seqY.length;\n        while (true) {\n            const endX = path ? path.x + path.length : 0;\n            const endY = path ? path.y + path.length : 0;\n            if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n                result.push(( new SequenceDiff(( new OffsetRange(endX, lastAligningPosS1)), ( new OffsetRange(endY, lastAligningPosS2)))));\n            }\n            if (!path) {\n                break;\n            }\n            lastAligningPosS1 = path.x;\n            lastAligningPosS2 = path.y;\n            path = path.prev;\n        }\n        result.reverse();\n        return ( new DiffAlgorithmResult(result, false));\n    }\n}\nclass SnakePath {\n    constructor(prev, x, y, length) {\n        this.prev = prev;\n        this.x = x;\n        this.y = y;\n        this.length = length;\n    }\n}\nclass FastInt32Array {\n    constructor() {\n        this.positiveArr = ( new Int32Array(10));\n        this.negativeArr = ( new Int32Array(10));\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            if (idx >= this.negativeArr.length) {\n                const arr = this.negativeArr;\n                this.negativeArr = ( new Int32Array(arr.length * 2));\n                this.negativeArr.set(arr);\n            }\n            this.negativeArr[idx] = value;\n        }\n        else {\n            if (idx >= this.positiveArr.length) {\n                const arr = this.positiveArr;\n                this.positiveArr = ( new Int32Array(arr.length * 2));\n                this.positiveArr.set(arr);\n            }\n            this.positiveArr[idx] = value;\n        }\n    }\n}\nclass FastArrayNegativeIndices {\n    constructor() {\n        this.positiveArr = [];\n        this.negativeArr = [];\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            this.negativeArr[idx] = value;\n        }\n        else {\n            this.positiveArr[idx] = value;\n        }\n    }\n}\nexport { MyersDiffAlgorithm };\n","import { SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { LineRangeMapping } from '../rangeMapping.js';\nimport { pushMany, compareBy, numberComparator, reverseOrder } from '../../../../base/common/arrays.js';\nimport { findLastMonotonous, MonotonousArray } from '../../../../base/common/arraysFind.js';\nimport { SetMap } from '../../../../base/common/map.js';\nimport { LineRange, LineRangeSet } from '../../core/lineRange.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { isSpace, LineRangeFragment } from './utils.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nfunction computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {\n    let { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);\n    if (!timeout.isValid()) {\n        return [];\n    }\n    const filteredChanges = changes.filter(c => !( excludedChanges.has(c)));\n    const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);\n    pushMany(moves, unchangedMoves);\n    moves = joinCloseConsecutiveMoves(moves);\n    moves = moves.filter(current => {\n        const lines = ( current.original.toOffsetRange().slice(originalLines).map(l => l.trim()));\n        const originalText = lines.join('\\n');\n        return originalText.length >= 15 && countWhere(lines, l => l.length >= 2) >= 2;\n    });\n    moves = removeMovesInSameDiff(changes, moves);\n    return moves;\n}\nfunction countWhere(arr, predicate) {\n    let count = 0;\n    for (const t of arr) {\n        if (predicate(t)) {\n            count++;\n        }\n    }\n    return count;\n}\nfunction computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {\n    const moves = [];\n    const deletions = ( changes\n        .filter(c => c.modified.isEmpty && c.original.length >= 3)\n        .map(d => ( new LineRangeFragment(d.original, originalLines, d))));\n    const insertions = ( new Set(( changes\n        .filter(c => c.original.isEmpty && c.modified.length >= 3)\n        .map(d => ( new LineRangeFragment(d.modified, modifiedLines, d))))));\n    const excludedChanges = ( new Set());\n    for (const deletion of deletions) {\n        let highestSimilarity = -1;\n        let best;\n        for (const insertion of insertions) {\n            const similarity = deletion.computeSimilarity(insertion);\n            if (similarity > highestSimilarity) {\n                highestSimilarity = similarity;\n                best = insertion;\n            }\n        }\n        if (highestSimilarity > 0.90 && best) {\n            insertions.delete(best);\n            moves.push(( new LineRangeMapping(deletion.range, best.range)));\n            excludedChanges.add(deletion.source);\n            excludedChanges.add(best.source);\n        }\n        if (!timeout.isValid()) {\n            return { moves, excludedChanges };\n        }\n    }\n    return { moves, excludedChanges };\n}\nfunction computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {\n    const moves = [];\n    const original3LineHashes = ( new SetMap());\n    for (const change of changes) {\n        for (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {\n            const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;\n            original3LineHashes.add(key, { range: ( new LineRange(i, i + 3)) });\n        }\n    }\n    const possibleMappings = [];\n    changes.sort(compareBy(c => c.modified.startLineNumber, numberComparator));\n    for (const change of changes) {\n        let lastMappings = [];\n        for (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {\n            const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;\n            const currentModifiedRange = ( new LineRange(i, i + 3));\n            const nextMappings = [];\n            original3LineHashes.forEach(key, ({ range }) => {\n                for (const lastMapping of lastMappings) {\n                    if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive &&\n                        lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {\n                        lastMapping.originalLineRange = ( new LineRange(\n                            lastMapping.originalLineRange.startLineNumber,\n                            range.endLineNumberExclusive\n                        ));\n                        lastMapping.modifiedLineRange = ( new LineRange(\n                            lastMapping.modifiedLineRange.startLineNumber,\n                            currentModifiedRange.endLineNumberExclusive\n                        ));\n                        nextMappings.push(lastMapping);\n                        return;\n                    }\n                }\n                const mapping = {\n                    modifiedLineRange: currentModifiedRange,\n                    originalLineRange: range,\n                };\n                possibleMappings.push(mapping);\n                nextMappings.push(mapping);\n            });\n            lastMappings = nextMappings;\n        }\n        if (!timeout.isValid()) {\n            return [];\n        }\n    }\n    possibleMappings.sort(reverseOrder(compareBy(m => m.modifiedLineRange.length, numberComparator)));\n    const modifiedSet = ( new LineRangeSet());\n    const originalSet = ( new LineRangeSet());\n    for (const mapping of possibleMappings) {\n        const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;\n        const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);\n        const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);\n        const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);\n        for (const s of modifiedIntersectedSections.ranges) {\n            if (s.length < 3) {\n                continue;\n            }\n            const modifiedLineRange = s;\n            const originalLineRange = s.delta(-diffOrigToMod);\n            moves.push(( new LineRangeMapping(originalLineRange, modifiedLineRange)));\n            modifiedSet.addRange(modifiedLineRange);\n            originalSet.addRange(originalLineRange);\n        }\n    }\n    moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n    const monotonousChanges = ( new MonotonousArray(changes));\n    for (let i = 0; i < moves.length; i++) {\n        const move = moves[i];\n        const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber <= move.original.startLineNumber);\n        const firstTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber <= move.modified.startLineNumber);\n        const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);\n        const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber < move.original.endLineNumberExclusive);\n        const lastTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber < move.modified.endLineNumberExclusive);\n        const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);\n        let extendToTop;\n        for (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {\n            const origLine = move.original.startLineNumber - extendToTop - 1;\n            const modLine = move.modified.startLineNumber - extendToTop - 1;\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\n                break;\n            }\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n                break;\n            }\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n                break;\n            }\n        }\n        if (extendToTop > 0) {\n            originalSet.addRange(( new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber)));\n            modifiedSet.addRange(( new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber)));\n        }\n        let extendToBottom;\n        for (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {\n            const origLine = move.original.endLineNumberExclusive + extendToBottom;\n            const modLine = move.modified.endLineNumberExclusive + extendToBottom;\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\n                break;\n            }\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n                break;\n            }\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n                break;\n            }\n        }\n        if (extendToBottom > 0) {\n            originalSet.addRange(( new LineRange(\n                move.original.endLineNumberExclusive,\n                move.original.endLineNumberExclusive + extendToBottom\n            )));\n            modifiedSet.addRange(( new LineRange(\n                move.modified.endLineNumberExclusive,\n                move.modified.endLineNumberExclusive + extendToBottom\n            )));\n        }\n        if (extendToTop > 0 || extendToBottom > 0) {\n            moves[i] = ( new LineRangeMapping(( new LineRange(\n                move.original.startLineNumber - extendToTop,\n                move.original.endLineNumberExclusive + extendToBottom\n            )), ( new LineRange(\n                move.modified.startLineNumber - extendToTop,\n                move.modified.endLineNumberExclusive + extendToBottom\n            ))));\n        }\n    }\n    return moves;\n}\nfunction areLinesSimilar(line1, line2, timeout) {\n    if (line1.trim() === line2.trim()) {\n        return true;\n    }\n    if (line1.length > 300 && line2.length > 300) {\n        return false;\n    }\n    const myersDiffingAlgorithm = ( new MyersDiffAlgorithm());\n    const result = myersDiffingAlgorithm.compute(( new LinesSliceCharSequence([line1], ( new OffsetRange(0, 1)), false)), ( new LinesSliceCharSequence([line2], ( new OffsetRange(0, 1)), false)), timeout);\n    let commonNonSpaceCharCount = 0;\n    const inverted = SequenceDiff.invert(result.diffs, line1.length);\n    for (const seq of inverted) {\n        seq.seq1Range.forEach(idx => {\n            if (!isSpace(line1.charCodeAt(idx))) {\n                commonNonSpaceCharCount++;\n            }\n        });\n    }\n    function countNonWsChars(str) {\n        let count = 0;\n        for (let i = 0; i < line1.length; i++) {\n            if (!isSpace(str.charCodeAt(i))) {\n                count++;\n            }\n        }\n        return count;\n    }\n    const longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);\n    const r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;\n    return r;\n}\nfunction joinCloseConsecutiveMoves(moves) {\n    if (moves.length === 0) {\n        return moves;\n    }\n    moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n    const result = [moves[0]];\n    for (let i = 1; i < moves.length; i++) {\n        const last = result[result.length - 1];\n        const current = moves[i];\n        const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;\n        const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;\n        const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;\n        if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {\n            result[result.length - 1] = last.join(current);\n            continue;\n        }\n        result.push(current);\n    }\n    return result;\n}\nfunction removeMovesInSameDiff(changes, moves) {\n    const changesMonotonous = ( new MonotonousArray(changes));\n    moves = moves.filter(m => {\n        const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous(c => c.original.startLineNumber < m.original.endLineNumberExclusive)\n            || ( new LineRangeMapping(( new LineRange(1, 1)), ( new LineRange(1, 1))));\n        const diffBeforeEndOfMoveModified = findLastMonotonous(changes, c => c.modified.startLineNumber < m.modified.endLineNumberExclusive);\n        const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;\n        return differentDiffs;\n    });\n    return moves;\n}\nexport { computeMovedLines };\n","import { equals, groupAdjacentBy } from '../../../../base/common/arrays.js';\nimport { assertFn, checkAdjacentItems } from '../../../../base/common/assert.js';\nimport { LineRange } from '../../core/lineRange.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { Range } from '../../core/range.js';\nimport { InfiniteTimeout, DateTimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { computeMovedLines } from './computeMovedLines.js';\nimport { optimizeSequenceDiffs, removeVeryShortMatchingLinesBetweenDiffs, extendDiffsToEntireWordIfAppropriate, removeShortMatches, removeVeryShortMatchingTextBetweenLongDiffs } from './heuristicSequenceOptimizations.js';\nimport { LineSequence } from './lineSequence.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LinesDiff, MovedText } from '../linesDiffComputer.js';\nimport { DetailedLineRangeMapping, RangeMapping } from '../rangeMapping.js';\nclass DefaultLinesDiffComputer {\n    constructor() {\n        this.dynamicProgrammingDiffing = ( new DynamicProgrammingDiffing());\n        this.myersDiffingAlgorithm = ( new MyersDiffAlgorithm());\n    }\n    computeDiff(originalLines, modifiedLines, options) {\n        if (originalLines.length <= 1 && equals(originalLines, modifiedLines, (a, b) => a === b)) {\n            return ( new LinesDiff([], [], false));\n        }\n        if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {\n            return ( new LinesDiff([\n                ( new DetailedLineRangeMapping(( new LineRange(1, originalLines.length + 1)), ( new LineRange(1, modifiedLines.length + 1)), [\n                    ( new RangeMapping(( new Range(\n                        1,\n                        1,\n                        originalLines.length,\n                        originalLines[originalLines.length - 1].length + 1\n                    )), ( new Range(\n                        1,\n                        1,\n                        modifiedLines.length,\n                        modifiedLines[modifiedLines.length - 1].length + 1\n                    ))))\n                ]))\n            ], [], false));\n        }\n        const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : ( new DateTimeout(options.maxComputationTimeMs));\n        const considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n        const perfectHashes = ( new Map());\n        function getOrCreateHash(text) {\n            let hash = perfectHashes.get(text);\n            if (hash === undefined) {\n                hash = perfectHashes.size;\n                perfectHashes.set(text, hash);\n            }\n            return hash;\n        }\n        const originalLinesHashes = ( originalLines.map((l) => getOrCreateHash(l.trim())));\n        const modifiedLinesHashes = ( modifiedLines.map((l) => getOrCreateHash(l.trim())));\n        const sequence1 = ( new LineSequence(originalLinesHashes, originalLines));\n        const sequence2 = ( new LineSequence(modifiedLinesHashes, modifiedLines));\n        const lineAlignmentResult = (() => {\n            if (sequence1.length + sequence2.length < 1700) {\n                return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2]\n                    ? modifiedLines[offset2].length === 0\n                        ? 0.1\n                        : 1 + Math.log(1 + modifiedLines[offset2].length)\n                    : 0.99);\n            }\n            return this.myersDiffingAlgorithm.compute(sequence1, sequence2, timeout);\n        })();\n        let lineAlignments = lineAlignmentResult.diffs;\n        let hitTimeout = lineAlignmentResult.hitTimeout;\n        lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n        lineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);\n        const alignments = [];\n        const scanForWhitespaceChanges = (equalLinesCount) => {\n            if (!considerWhitespaceChanges) {\n                return;\n            }\n            for (let i = 0; i < equalLinesCount; i++) {\n                const seq1Offset = seq1LastStart + i;\n                const seq2Offset = seq2LastStart + i;\n                if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n                    const characterDiffs = this.refineDiff(originalLines, modifiedLines, ( new SequenceDiff(( new OffsetRange(seq1Offset, seq1Offset + 1)), ( new OffsetRange(seq2Offset, seq2Offset + 1)))), timeout, considerWhitespaceChanges);\n                    for (const a of characterDiffs.mappings) {\n                        alignments.push(a);\n                    }\n                    if (characterDiffs.hitTimeout) {\n                        hitTimeout = true;\n                    }\n                }\n            }\n        };\n        let seq1LastStart = 0;\n        let seq2LastStart = 0;\n        for (const diff of lineAlignments) {\n            assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n            const equalLinesCount = diff.seq1Range.start - seq1LastStart;\n            scanForWhitespaceChanges(equalLinesCount);\n            seq1LastStart = diff.seq1Range.endExclusive;\n            seq2LastStart = diff.seq2Range.endExclusive;\n            const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);\n            if (characterDiffs.hitTimeout) {\n                hitTimeout = true;\n            }\n            for (const a of characterDiffs.mappings) {\n                alignments.push(a);\n            }\n        }\n        scanForWhitespaceChanges(originalLines.length - seq1LastStart);\n        const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);\n        let moves = [];\n        if (options.computeMoves) {\n            moves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges);\n        }\n        assertFn(() => {\n            function validatePosition(pos, lines) {\n                if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {\n                    return false;\n                }\n                const line = lines[pos.lineNumber - 1];\n                if (pos.column < 1 || pos.column > line.length + 1) {\n                    return false;\n                }\n                return true;\n            }\n            function validateRange(range, lines) {\n                if (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) {\n                    return false;\n                }\n                if (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) {\n                    return false;\n                }\n                return true;\n            }\n            for (const c of changes) {\n                if (!c.innerChanges) {\n                    return false;\n                }\n                for (const ic of c.innerChanges) {\n                    const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) &&\n                        validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);\n                    if (!valid) {\n                        return false;\n                    }\n                }\n                if (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {\n                    return false;\n                }\n            }\n            return true;\n        });\n        return ( new LinesDiff(changes, moves, hitTimeout));\n    }\n    computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout, considerWhitespaceChanges) {\n        const moves = computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout);\n        const movesWithDiffs = ( moves.map(m => {\n            const moveChanges = this.refineDiff(originalLines, modifiedLines, ( new SequenceDiff(m.original.toOffsetRange(), m.modified.toOffsetRange())), timeout, considerWhitespaceChanges);\n            const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);\n            return ( new MovedText(m, mappings));\n        }));\n        return movesWithDiffs;\n    }\n    refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {\n        const slice1 = ( new LinesSliceCharSequence(originalLines, diff.seq1Range, considerWhitespaceChanges));\n        const slice2 = ( new LinesSliceCharSequence(modifiedLines, diff.seq2Range, considerWhitespaceChanges));\n        const diffResult = slice1.length + slice2.length < 500\n            ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout)\n            : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);\n        let diffs = diffResult.diffs;\n        diffs = optimizeSequenceDiffs(slice1, slice2, diffs);\n        diffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs);\n        diffs = removeShortMatches(slice1, slice2, diffs);\n        diffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);\n        const result = ( diffs.map((d) => ( new RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range)))));\n        return {\n            mappings: result,\n            hitTimeout: diffResult.hitTimeout,\n        };\n    }\n}\nfunction lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {\n    const changes = [];\n    for (const g of groupAdjacentBy(( alignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines))), (a1, a2) => a1.original.overlapOrTouch(a2.original)\n        || a1.modified.overlapOrTouch(a2.modified))) {\n        const first = g[0];\n        const last = g[g.length - 1];\n        changes.push(( new DetailedLineRangeMapping(\n            first.original.join(last.original),\n            first.modified.join(last.modified),\n            ( g.map(a => a.innerChanges[0]))\n        )));\n    }\n    assertFn(() => {\n        if (!dontAssertStartLine && changes.length > 0) {\n            if (changes[0].modified.startLineNumber !== changes[0].original.startLineNumber) {\n                return false;\n            }\n            if (modifiedLines.length - changes[changes.length - 1].modified.endLineNumberExclusive !== originalLines.length - changes[changes.length - 1].original.endLineNumberExclusive) {\n                return false;\n            }\n        }\n        return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n            m1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n            m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);\n    });\n    return changes;\n}\nfunction getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {\n    let lineStartDelta = 0;\n    let lineEndDelta = 0;\n    if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1\n        && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber\n        && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n        lineEndDelta = -1;\n    }\n    if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta\n        && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\n        lineStartDelta = 1;\n    }\n    const originalLineRange = ( new LineRange(\n        rangeMapping.originalRange.startLineNumber + lineStartDelta,\n        rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta\n    ));\n    const modifiedLineRange = ( new LineRange(\n        rangeMapping.modifiedRange.startLineNumber + lineStartDelta,\n        rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta\n    ));\n    return ( new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]));\n}\nexport { DefaultLinesDiffComputer, getLineRangeMapping, lineRangeMappingFromRangeMappings };\n","import { forEachWithNeighbors } from '../../../../base/common/arrays.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { SequenceDiff, OffsetPair } from './algorithms/diffAlgorithm.js';\nfunction optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    let result = sequenceDiffs;\n    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n    result = shiftSequenceDiffs(sequence1, sequence2, result);\n    return result;\n}\nfunction joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {\n    if (sequenceDiffs.length === 0) {\n        return sequenceDiffs;\n    }\n    const result = [];\n    result.push(sequenceDiffs[0]);\n    for (let i = 1; i < sequenceDiffs.length; i++) {\n        const prevResult = result[result.length - 1];\n        let cur = sequenceDiffs[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\n            let d;\n            for (d = 1; d <= length; d++) {\n                if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) ||\n                    sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\n                    break;\n                }\n            }\n            d--;\n            if (d === length) {\n                result[result.length - 1] = ( new SequenceDiff(( new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length)), ( new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length))));\n                continue;\n            }\n            cur = cur.delta(-d);\n        }\n        result.push(cur);\n    }\n    const result2 = [];\n    for (let i = 0; i < result.length - 1; i++) {\n        const nextResult = result[i + 1];\n        let cur = result[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;\n            let d;\n            for (d = 0; d < length; d++) {\n                if (!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) ||\n                    !sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)) {\n                    break;\n                }\n            }\n            if (d === length) {\n                result[i + 1] = ( new SequenceDiff(( new OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive)), ( new OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive))));\n                continue;\n            }\n            if (d > 0) {\n                cur = cur.delta(d);\n            }\n        }\n        result2.push(cur);\n    }\n    if (result.length > 0) {\n        result2.push(result[result.length - 1]);\n    }\n    return result2;\n}\nfunction shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n        return sequenceDiffs;\n    }\n    for (let i = 0; i < sequenceDiffs.length; i++) {\n        const prevDiff = (i > 0 ? sequenceDiffs[i - 1] : undefined);\n        const diff = sequenceDiffs[i];\n        const nextDiff = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined);\n        const seq1ValidRange = ( new OffsetRange(\n            prevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0,\n            nextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length\n        ));\n        const seq2ValidRange = ( new OffsetRange(\n            prevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0,\n            nextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length\n        ));\n        if (diff.seq1Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\n        }\n        else if (diff.seq2Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();\n        }\n    }\n    return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {\n    const maxShiftLimit = 100;\n    let deltaBefore = 1;\n    while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start &&\n        diff.seq2Range.start - deltaBefore >= seq2ValidRange.start &&\n        sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\n        deltaBefore++;\n    }\n    deltaBefore--;\n    let deltaAfter = 0;\n    while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive &&\n        diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive &&\n        sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\n        deltaAfter++;\n    }\n    if (deltaBefore === 0 && deltaAfter === 0) {\n        return diff;\n    }\n    let bestDelta = 0;\n    let bestScore = -1;\n    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n        const seq2OffsetStart = diff.seq2Range.start + delta;\n        const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n        const seq1Offset = diff.seq1Range.start + delta;\n        const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n        if (score > bestScore) {\n            bestScore = score;\n            bestDelta = delta;\n        }\n    }\n    return diff.delta(bestDelta);\n}\nfunction removeShortMatches(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    for (const s of sequenceDiffs) {\n        const last = result[result.length - 1];\n        if (!last) {\n            result.push(s);\n            continue;\n        }\n        if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n            result[result.length - 1] = ( new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range)));\n        }\n        else {\n            result.push(s);\n        }\n    }\n    return result;\n}\nfunction extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs) {\n    const equalMappings = SequenceDiff.invert(sequenceDiffs, sequence1.length);\n    const additional = [];\n    let lastPoint = ( new OffsetPair(0, 0));\n    function scanWord(pair, equalMapping) {\n        if (pair.offset1 < lastPoint.offset1 || pair.offset2 < lastPoint.offset2) {\n            return;\n        }\n        const w1 = sequence1.findWordContaining(pair.offset1);\n        const w2 = sequence2.findWordContaining(pair.offset2);\n        if (!w1 || !w2) {\n            return;\n        }\n        let w = ( new SequenceDiff(w1, w2));\n        const equalPart = w.intersect(equalMapping);\n        let equalChars1 = equalPart.seq1Range.length;\n        let equalChars2 = equalPart.seq2Range.length;\n        while (equalMappings.length > 0) {\n            const next = equalMappings[0];\n            const intersects = next.seq1Range.intersects(w.seq1Range) || next.seq2Range.intersects(w.seq2Range);\n            if (!intersects) {\n                break;\n            }\n            const v1 = sequence1.findWordContaining(next.seq1Range.start);\n            const v2 = sequence2.findWordContaining(next.seq2Range.start);\n            const v = ( new SequenceDiff(v1, v2));\n            const equalPart = v.intersect(next);\n            equalChars1 += equalPart.seq1Range.length;\n            equalChars2 += equalPart.seq2Range.length;\n            w = w.join(v);\n            if (w.seq1Range.endExclusive >= next.seq1Range.endExclusive) {\n                equalMappings.shift();\n            }\n            else {\n                break;\n            }\n        }\n        if (equalChars1 + equalChars2 < (w.seq1Range.length + w.seq2Range.length) * 2 / 3) {\n            additional.push(w);\n        }\n        lastPoint = w.getEndExclusives();\n    }\n    while (equalMappings.length > 0) {\n        const next = equalMappings.shift();\n        if (next.seq1Range.isEmpty) {\n            continue;\n        }\n        scanWord(next.getStarts(), next);\n        scanWord(next.getEndExclusives().delta(-1), next);\n    }\n    const merged = mergeSequenceDiffs(sequenceDiffs, additional);\n    return merged;\n}\nfunction mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {\n    const result = [];\n    while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n        const sd1 = sequenceDiffs1[0];\n        const sd2 = sequenceDiffs2[0];\n        let next;\n        if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n            next = sequenceDiffs1.shift();\n        }\n        else {\n            next = sequenceDiffs2.shift();\n        }\n        if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n            result[result.length - 1] = result[result.length - 1].join(next);\n        }\n        else {\n            result.push(next);\n        }\n    }\n    return result;\n}\nfunction removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {\n    let diffs = sequenceDiffs;\n    if (diffs.length === 0) {\n        return diffs;\n    }\n    let counter = 0;\n    let shouldRepeat;\n    do {\n        shouldRepeat = false;\n        const result = [\n            diffs[0]\n        ];\n        for (let i = 1; i < diffs.length; i++) {\n            const cur = diffs[i];\n            const lastResult = result[result.length - 1];\n            function shouldJoinDiffs(before, after) {\n                const unchangedRange = ( new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start));\n                const unchangedText = sequence1.getText(unchangedRange);\n                const unchangedTextWithoutWs = unchangedText.replace(/\\s/g, '');\n                if (unchangedTextWithoutWs.length <= 4\n                    && (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {\n                    return true;\n                }\n                return false;\n            }\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\n            if (shouldJoin) {\n                shouldRepeat = true;\n                result[result.length - 1] = result[result.length - 1].join(cur);\n            }\n            else {\n                result.push(cur);\n            }\n        }\n        diffs = result;\n    } while (counter++ < 10 && shouldRepeat);\n    return diffs;\n}\nfunction removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {\n    let diffs = sequenceDiffs;\n    if (diffs.length === 0) {\n        return diffs;\n    }\n    let counter = 0;\n    let shouldRepeat;\n    do {\n        shouldRepeat = false;\n        const result = [\n            diffs[0]\n        ];\n        for (let i = 1; i < diffs.length; i++) {\n            const cur = diffs[i];\n            const lastResult = result[result.length - 1];\n            function shouldJoinDiffs(before, after) {\n                const unchangedRange = ( new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start));\n                const unchangedLineCount = sequence1.countLinesIn(unchangedRange);\n                if (unchangedLineCount > 5 || unchangedRange.length > 500) {\n                    return false;\n                }\n                const unchangedText = sequence1.getText(unchangedRange).trim();\n                if (unchangedText.length > 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length > 1) {\n                    return false;\n                }\n                const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\n                const beforeSeq1Length = before.seq1Range.length;\n                const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\n                const beforeSeq2Length = before.seq2Range.length;\n                const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n                const afterSeq1Length = after.seq1Range.length;\n                const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n                const afterSeq2Length = after.seq2Range.length;\n                const max = 2 * 40 + 50;\n                function cap(v) {\n                    return Math.min(v, max);\n                }\n                if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5)\n                    + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > ((max ** 1.5) ** 1.5) * 1.3) {\n                    return true;\n                }\n                return false;\n            }\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\n            if (shouldJoin) {\n                shouldRepeat = true;\n                result[result.length - 1] = result[result.length - 1].join(cur);\n            }\n            else {\n                result.push(cur);\n            }\n        }\n        diffs = result;\n    } while (counter++ < 10 && shouldRepeat);\n    const newDiffs = [];\n    forEachWithNeighbors(diffs, (prev, cur, next) => {\n        let newDiff = cur;\n        function shouldMarkAsChanged(text) {\n            return text.length > 0 && text.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;\n        }\n        const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);\n        const prefix = sequence1.getText(( new OffsetRange(fullRange1.start, cur.seq1Range.start)));\n        if (shouldMarkAsChanged(prefix)) {\n            newDiff = newDiff.deltaStart(-prefix.length);\n        }\n        const suffix = sequence1.getText(( new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive)));\n        if (shouldMarkAsChanged(suffix)) {\n            newDiff = newDiff.deltaEnd(suffix.length);\n        }\n        const availableSpace = SequenceDiff.fromOffsetPairs(prev ? prev.getEndExclusives() : OffsetPair.zero, next ? next.getStarts() : OffsetPair.max);\n        const result = newDiff.intersect(availableSpace);\n        if (newDiffs.length > 0 && result.getStarts().equals(newDiffs[newDiffs.length - 1].getEndExclusives())) {\n            newDiffs[newDiffs.length - 1] = newDiffs[newDiffs.length - 1].join(result);\n        }\n        else {\n            newDiffs.push(result);\n        }\n    });\n    return newDiffs;\n}\nexport { extendDiffsToEntireWordIfAppropriate, optimizeSequenceDiffs, removeShortMatches, removeVeryShortMatchingLinesBetweenDiffs, removeVeryShortMatchingTextBetweenLongDiffs };\n","import { CharCode } from '../../../../base/common/charCode.js';\nclass LineSequence {\n    constructor(trimmedHash, lines) {\n        this.trimmedHash = trimmedHash;\n        this.lines = lines;\n    }\n    getElement(offset) {\n        return this.trimmedHash[offset];\n    }\n    get length() {\n        return this.trimmedHash.length;\n    }\n    getBoundaryScore(length) {\n        const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n        const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n        return 1000 - (indentationBefore + indentationAfter);\n    }\n    getText(range) {\n        return this.lines.slice(range.start, range.endExclusive).join('\\n');\n    }\n    isStronglyEqual(offset1, offset2) {\n        return this.lines[offset1] === this.lines[offset2];\n    }\n}\nfunction getIndentation(str) {\n    let i = 0;\n    while (i < str.length && (str.charCodeAt(i) === CharCode.Space || str.charCodeAt(i) === CharCode.Tab)) {\n        i++;\n    }\n    return i;\n}\nexport { LineSequence };\n","import { findLastIdxMonotonous, findLastMonotonous, findFirstMonotonous } from '../../../../base/common/arraysFind.js';\nimport { CharCode } from '../../../../base/common/charCode.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { isSpace } from './utils.js';\nclass LinesSliceCharSequence {\n    constructor(lines, lineRange, considerWhitespaceChanges) {\n        this.lines = lines;\n        this.considerWhitespaceChanges = considerWhitespaceChanges;\n        this.elements = [];\n        this.firstCharOffsetByLine = [];\n        this.additionalOffsetByLine = [];\n        let trimFirstLineFully = false;\n        if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {\n            lineRange = ( new OffsetRange(lineRange.start - 1, lineRange.endExclusive));\n            trimFirstLineFully = true;\n        }\n        this.lineRange = lineRange;\n        this.firstCharOffsetByLine[0] = 0;\n        for (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {\n            let line = lines[i];\n            let offset = 0;\n            if (trimFirstLineFully) {\n                offset = line.length;\n                line = '';\n                trimFirstLineFully = false;\n            }\n            else if (!considerWhitespaceChanges) {\n                const trimmedStartLine = line.trimStart();\n                offset = line.length - trimmedStartLine.length;\n                line = trimmedStartLine.trimEnd();\n            }\n            this.additionalOffsetByLine.push(offset);\n            for (let i = 0; i < line.length; i++) {\n                this.elements.push(line.charCodeAt(i));\n            }\n            if (i < lines.length - 1) {\n                this.elements.push('\\n'.charCodeAt(0));\n                this.firstCharOffsetByLine[i - this.lineRange.start + 1] = this.elements.length;\n            }\n        }\n        this.additionalOffsetByLine.push(0);\n    }\n    toString() {\n        return `Slice: \"${this.text}\"`;\n    }\n    get text() {\n        return this.getText(( new OffsetRange(0, this.length)));\n    }\n    getText(range) {\n        return ( this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e))).join('');\n    }\n    getElement(offset) {\n        return this.elements[offset];\n    }\n    get length() {\n        return this.elements.length;\n    }\n    getBoundaryScore(length) {\n        const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n        const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n        if (prevCategory === CharBoundaryCategory.LineBreakCR && nextCategory === CharBoundaryCategory.LineBreakLF) {\n            return 0;\n        }\n        if (prevCategory === CharBoundaryCategory.LineBreakLF) {\n            return 150;\n        }\n        let score = 0;\n        if (prevCategory !== nextCategory) {\n            score += 10;\n            if (prevCategory === CharBoundaryCategory.WordLower && nextCategory === CharBoundaryCategory.WordUpper) {\n                score += 1;\n            }\n        }\n        score += getCategoryBoundaryScore(prevCategory);\n        score += getCategoryBoundaryScore(nextCategory);\n        return score;\n    }\n    translateOffset(offset) {\n        if (this.lineRange.isEmpty) {\n            return ( new Position(this.lineRange.start + 1, 1));\n        }\n        const i = findLastIdxMonotonous(this.firstCharOffsetByLine, (value) => value <= offset);\n        return ( new Position(\n            this.lineRange.start + i + 1,\n            offset - this.firstCharOffsetByLine[i] + this.additionalOffsetByLine[i] + 1\n        ));\n    }\n    translateRange(range) {\n        return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\n    }\n    findWordContaining(offset) {\n        if (offset < 0 || offset >= this.elements.length) {\n            return undefined;\n        }\n        if (!isWordChar(this.elements[offset])) {\n            return undefined;\n        }\n        let start = offset;\n        while (start > 0 && isWordChar(this.elements[start - 1])) {\n            start--;\n        }\n        let end = offset;\n        while (end < this.elements.length && isWordChar(this.elements[end])) {\n            end++;\n        }\n        return ( new OffsetRange(start, end));\n    }\n    countLinesIn(range) {\n        return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n    }\n    isStronglyEqual(offset1, offset2) {\n        return this.elements[offset1] === this.elements[offset2];\n    }\n    extendToFullLines(range) {\n        const start = findLastMonotonous(this.firstCharOffsetByLine, x => x <= range.start) ?? 0;\n        const end = findFirstMonotonous(this.firstCharOffsetByLine, x => range.endExclusive <= x) ?? this.elements.length;\n        return ( new OffsetRange(start, end));\n    }\n}\nfunction isWordChar(charCode) {\n    return charCode >= CharCode.a && charCode <= CharCode.z\n        || charCode >= CharCode.A && charCode <= CharCode.Z\n        || charCode >= CharCode.Digit0 && charCode <= CharCode.Digit9;\n}\nvar CharBoundaryCategory;\n( (function(CharBoundaryCategory) {\n    CharBoundaryCategory[CharBoundaryCategory[\"WordLower\"] = 0] = \"WordLower\";\n    CharBoundaryCategory[CharBoundaryCategory[\"WordUpper\"] = 1] = \"WordUpper\";\n    CharBoundaryCategory[CharBoundaryCategory[\"WordNumber\"] = 2] = \"WordNumber\";\n    CharBoundaryCategory[CharBoundaryCategory[\"End\"] = 3] = \"End\";\n    CharBoundaryCategory[CharBoundaryCategory[\"Other\"] = 4] = \"Other\";\n    CharBoundaryCategory[CharBoundaryCategory[\"Separator\"] = 5] = \"Separator\";\n    CharBoundaryCategory[CharBoundaryCategory[\"Space\"] = 6] = \"Space\";\n    CharBoundaryCategory[CharBoundaryCategory[\"LineBreakCR\"] = 7] = \"LineBreakCR\";\n    CharBoundaryCategory[CharBoundaryCategory[\"LineBreakLF\"] = 8] = \"LineBreakLF\";\n})(CharBoundaryCategory || (CharBoundaryCategory = {})));\nconst score = {\n    [CharBoundaryCategory.WordLower]: 0,\n    [CharBoundaryCategory.WordUpper]: 0,\n    [CharBoundaryCategory.WordNumber]: 0,\n    [CharBoundaryCategory.End]: 10,\n    [CharBoundaryCategory.Other]: 2,\n    [CharBoundaryCategory.Separator]: 30,\n    [CharBoundaryCategory.Space]: 3,\n    [CharBoundaryCategory.LineBreakCR]: 10,\n    [CharBoundaryCategory.LineBreakLF]: 10,\n};\nfunction getCategoryBoundaryScore(category) {\n    return score[category];\n}\nfunction getCategory(charCode) {\n    if (charCode === CharCode.LineFeed) {\n        return CharBoundaryCategory.LineBreakLF;\n    }\n    else if (charCode === CharCode.CarriageReturn) {\n        return CharBoundaryCategory.LineBreakCR;\n    }\n    else if (isSpace(charCode)) {\n        return CharBoundaryCategory.Space;\n    }\n    else if (charCode >= CharCode.a && charCode <= CharCode.z) {\n        return CharBoundaryCategory.WordLower;\n    }\n    else if (charCode >= CharCode.A && charCode <= CharCode.Z) {\n        return CharBoundaryCategory.WordUpper;\n    }\n    else if (charCode >= CharCode.Digit0 && charCode <= CharCode.Digit9) {\n        return CharBoundaryCategory.WordNumber;\n    }\n    else if (charCode === -1) {\n        return CharBoundaryCategory.End;\n    }\n    else if (charCode === CharCode.Comma || charCode === CharCode.Semicolon) {\n        return CharBoundaryCategory.Separator;\n    }\n    else {\n        return CharBoundaryCategory.Other;\n    }\n}\nexport { LinesSliceCharSequence };\n","import { CharCode } from '../../../../base/common/charCode.js';\nclass Array2D {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.array = [];\n        this.array = ( new Array(width * height));\n    }\n    get(x, y) {\n        return this.array[x + y * this.width];\n    }\n    set(x, y, value) {\n        this.array[x + y * this.width] = value;\n    }\n}\nfunction isSpace(charCode) {\n    return charCode === CharCode.Space || charCode === CharCode.Tab;\n}\nclass LineRangeFragment {\n    static { this.chrKeys = ( new Map()); }\n    static getKey(chr) {\n        let key = this.chrKeys.get(chr);\n        if (key === undefined) {\n            key = this.chrKeys.size;\n            this.chrKeys.set(chr, key);\n        }\n        return key;\n    }\n    constructor(range, lines, source) {\n        this.range = range;\n        this.lines = lines;\n        this.source = source;\n        this.histogram = [];\n        let counter = 0;\n        for (let i = range.startLineNumber - 1; i < range.endLineNumberExclusive - 1; i++) {\n            const line = lines[i];\n            for (let j = 0; j < line.length; j++) {\n                counter++;\n                const chr = line[j];\n                const key = LineRangeFragment.getKey(chr);\n                this.histogram[key] = (this.histogram[key] || 0) + 1;\n            }\n            counter++;\n            const key = LineRangeFragment.getKey('\\n');\n            this.histogram[key] = (this.histogram[key] || 0) + 1;\n        }\n        this.totalCount = counter;\n    }\n    computeSimilarity(other) {\n        let sumDifferences = 0;\n        const maxLength = Math.max(this.histogram.length, other.histogram.length);\n        for (let i = 0; i < maxLength; i++) {\n            sumDifferences += Math.abs((this.histogram[i] ?? 0) - (other.histogram[i] ?? 0));\n        }\n        return 1 - (sumDifferences / (this.totalCount + other.totalCount));\n    }\n}\nexport { Array2D, LineRangeFragment, isSpace };\n","import { CharCode } from '../../../base/common/charCode.js';\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport { LinesDiff } from './linesDiffComputer.js';\nimport { DetailedLineRangeMapping, RangeMapping } from './rangeMapping.js';\nimport { firstNonWhitespaceIndex, lastNonWhitespaceIndex } from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/lineRange.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nclass LegacyLinesDiffComputer {\n    computeDiff(originalLines, modifiedLines, options) {\n        const diffComputer = ( new DiffComputer(originalLines, modifiedLines, {\n            maxComputationTime: options.maxComputationTimeMs,\n            shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n            shouldComputeCharChanges: true,\n            shouldMakePrettyDiff: true,\n            shouldPostProcessCharChanges: true,\n        }));\n        const result = diffComputer.computeDiff();\n        const changes = [];\n        let lastChange = null;\n        for (const c of result.changes) {\n            let originalRange;\n            if (c.originalEndLineNumber === 0) {\n                originalRange = ( new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1));\n            }\n            else {\n                originalRange = ( new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1));\n            }\n            let modifiedRange;\n            if (c.modifiedEndLineNumber === 0) {\n                modifiedRange = ( new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1));\n            }\n            else {\n                modifiedRange = ( new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1));\n            }\n            let change = ( new DetailedLineRangeMapping(originalRange, modifiedRange, c.charChanges?.map(c => ( new RangeMapping(( new Range(\n                c.originalStartLineNumber,\n                c.originalStartColumn,\n                c.originalEndLineNumber,\n                c.originalEndColumn\n            )), ( new Range(\n                c.modifiedStartLineNumber,\n                c.modifiedStartColumn,\n                c.modifiedEndLineNumber,\n                c.modifiedEndColumn\n            )))))));\n            if (lastChange) {\n                if (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber\n                    || lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {\n                    change = ( new DetailedLineRangeMapping(\n                        lastChange.original.join(change.original),\n                        lastChange.modified.join(change.modified),\n                        lastChange.innerChanges && change.innerChanges ?\n                            lastChange.innerChanges.concat(change.innerChanges) : undefined\n                    ));\n                    changes.pop();\n                }\n            }\n            changes.push(change);\n            lastChange = change;\n        }\n        assertFn(() => {\n            return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n                m1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n                m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);\n        });\n        return ( new LinesDiff(changes, [], result.quitEarly));\n    }\n}\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    const diffAlgo = ( new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate));\n    return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n    constructor(lines) {\n        const startColumns = [];\n        const endColumns = [];\n        for (let i = 0, length = lines.length; i < length; i++) {\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n        }\n        this.lines = lines;\n        this._startColumns = startColumns;\n        this._endColumns = endColumns;\n    }\n    getElements() {\n        const elements = [];\n        for (let i = 0, len = this.lines.length; i < len; i++) {\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n        }\n        return elements;\n    }\n    getStrictElement(index) {\n        return this.lines[index];\n    }\n    getStartLineNumber(i) {\n        return i + 1;\n    }\n    getEndLineNumber(i) {\n        return i + 1;\n    }\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n        const charCodes = [];\n        const lineNumbers = [];\n        const columns = [];\n        let len = 0;\n        for (let index = startIndex; index <= endIndex; index++) {\n            const lineContent = this.lines[index];\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n            for (let col = startColumn; col < endColumn; col++) {\n                charCodes[len] = lineContent.charCodeAt(col - 1);\n                lineNumbers[len] = index + 1;\n                columns[len] = col;\n                len++;\n            }\n            if (!shouldIgnoreTrimWhitespace && index < endIndex) {\n                charCodes[len] = CharCode.LineFeed;\n                lineNumbers[len] = index + 1;\n                columns[len] = lineContent.length + 1;\n                len++;\n            }\n        }\n        return ( new CharSequence(charCodes, lineNumbers, columns));\n    }\n}\nclass CharSequence {\n    constructor(charCodes, lineNumbers, columns) {\n        this._charCodes = charCodes;\n        this._lineNumbers = lineNumbers;\n        this._columns = columns;\n    }\n    toString() {\n        return ('[' + ( this._charCodes.map(\n            (s, idx) => (s === CharCode.LineFeed ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`\n        )).join(', ') + ']');\n    }\n    _assertIndex(index, arr) {\n        if (index < 0 || index >= arr.length) {\n            throw ( new Error(`Illegal index`));\n        }\n    }\n    getElements() {\n        return this._charCodes;\n    }\n    getStartLineNumber(i) {\n        if (i > 0 && i === this._lineNumbers.length) {\n            return this.getEndLineNumber(i - 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        return this._lineNumbers[i];\n    }\n    getEndLineNumber(i) {\n        if (i === -1) {\n            return this.getStartLineNumber(i + 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        if (this._charCodes[i] === CharCode.LineFeed) {\n            return this._lineNumbers[i] + 1;\n        }\n        return this._lineNumbers[i];\n    }\n    getStartColumn(i) {\n        if (i > 0 && i === this._columns.length) {\n            return this.getEndColumn(i - 1);\n        }\n        this._assertIndex(i, this._columns);\n        return this._columns[i];\n    }\n    getEndColumn(i) {\n        if (i === -1) {\n            return this.getStartColumn(i + 1);\n        }\n        this._assertIndex(i, this._columns);\n        if (this._charCodes[i] === CharCode.LineFeed) {\n            return 1;\n        }\n        return this._columns[i] + 1;\n    }\n}\nclass CharChange {\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n        const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n        const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n        const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n        const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n        const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        return ( new CharChange(\n            originalStartLineNumber,\n            originalStartColumn,\n            originalEndLineNumber,\n            originalEndColumn,\n            modifiedStartLineNumber,\n            modifiedStartColumn,\n            modifiedEndLineNumber,\n            modifiedEndColumn\n        ));\n    }\n}\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    const result = [rawChanges[0]];\n    let prevChange = result[0];\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\n        const currChange = rawChanges[i];\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nclass LineChange {\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n        let originalStartLineNumber;\n        let originalEndLineNumber;\n        let modifiedStartLineNumber;\n        let modifiedEndLineNumber;\n        let charChanges = undefined;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n                let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n                if (shouldPostProcessCharChanges) {\n                    rawChanges = postProcessCharChanges(rawChanges);\n                }\n                charChanges = [];\n                for (let i = 0, length = rawChanges.length; i < length; i++) {\n                    charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n                }\n            }\n        }\n        return ( new LineChange(\n            originalStartLineNumber,\n            originalEndLineNumber,\n            modifiedStartLineNumber,\n            modifiedEndLineNumber,\n            charChanges\n        ));\n    }\n}\nclass DiffComputer {\n    constructor(originalLines, modifiedLines, opts) {\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = ( new LineSequence(originalLines));\n        this.modified = ( new LineSequence(modifiedLines));\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000));\n    }\n    computeDiff() {\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n                return {\n                    quitEarly: false,\n                    changes: []\n                };\n            }\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: 1,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: this.modified.lines.length,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: this.original.lines.length,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: 1,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n        const rawChanges = diffResult.changes;\n        const quitEarly = diffResult.quitEarly;\n        if (this.shouldIgnoreTrimWhitespace) {\n            const lineChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n            }\n            return {\n                quitEarly: quitEarly,\n                changes: lineChanges\n            };\n        }\n        const result = [];\n        let originalLineIndex = 0;\n        let modifiedLineIndex = 0;\n        for (let i = -1 , len = rawChanges.length; i < len; i++) {\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                const originalLine = this.originalLines[originalLineIndex];\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    {\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    {\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n                        const originalMaxColumn = originalLine.length + 1;\n                        const modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return {\n            quitEarly: quitEarly,\n            changes: result\n        };\n    }\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            return;\n        }\n        let charChanges = undefined;\n        if (this.shouldComputeCharChanges) {\n            charChanges = [( new CharChange(\n                originalLineNumber,\n                originalStartColumn,\n                originalLineNumber,\n                originalEndColumn,\n                modifiedLineNumber,\n                modifiedStartColumn,\n                modifiedLineNumber,\n                modifiedEndColumn\n            ))];\n        }\n        result.push(( new LineChange(\n            originalLineNumber,\n            originalLineNumber,\n            modifiedLineNumber,\n            modifiedLineNumber,\n            charChanges\n        )));\n    }\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        const len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        const prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            return false;\n        }\n        if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(( new CharChange(\n                    originalLineNumber,\n                    originalStartColumn,\n                    originalLineNumber,\n                    originalEndColumn,\n                    modifiedLineNumber,\n                    modifiedStartColumn,\n                    modifiedLineNumber,\n                    modifiedEndColumn\n                )));\n            }\n            return true;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(( new CharChange(\n                    originalLineNumber,\n                    originalStartColumn,\n                    originalLineNumber,\n                    originalEndColumn,\n                    modifiedLineNumber,\n                    modifiedStartColumn,\n                    modifiedLineNumber,\n                    modifiedEndColumn\n                )));\n            }\n            return true;\n        }\n        return false;\n    }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n    const r = firstNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n    const r = lastNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n    if (maximumRuntime === 0) {\n        return () => true;\n    }\n    const startTime = Date.now();\n    return () => {\n        return Date.now() - startTime < maximumRuntime;\n    };\n}\nexport { DiffComputer, LegacyLinesDiffComputer };\n","class LinesDiff {\n    constructor(changes,\n    moves,\n    hitTimeout) {\n        this.changes = changes;\n        this.moves = moves;\n        this.hitTimeout = hitTimeout;\n    }\n}\nclass MovedText {\n    constructor(lineRangeMapping, changes) {\n        this.lineRangeMapping = lineRangeMapping;\n        this.changes = changes;\n    }\n    flip() {\n        return ( new MovedText(this.lineRangeMapping.flip(), ( this.changes.map(c => c.flip()))));\n    }\n}\nexport { LinesDiff, MovedText };\n","import { LegacyLinesDiffComputer } from './legacyLinesDiffComputer.js';\nimport { DefaultLinesDiffComputer } from './defaultLinesDiffComputer/defaultLinesDiffComputer.js';\nconst linesDiffComputers = {\n    getLegacy: () => ( new LegacyLinesDiffComputer()),\n    getDefault: () => ( new DefaultLinesDiffComputer()),\n};\nexport { linesDiffComputers };\n","import { BugIndicatingError } from '../../../base/common/errors.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Range } from '../core/range.js';\nimport { SingleTextEdit } from '../core/textEdit.js';\nclass LineRangeMapping {\n    static inverse(mapping, originalLineCount, modifiedLineCount) {\n        const result = [];\n        let lastOriginalEndLineNumber = 1;\n        let lastModifiedEndLineNumber = 1;\n        for (const m of mapping) {\n            const r = ( new LineRangeMapping(( new LineRange(lastOriginalEndLineNumber, m.original.startLineNumber)), ( new LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber))));\n            if (!r.modified.isEmpty) {\n                result.push(r);\n            }\n            lastOriginalEndLineNumber = m.original.endLineNumberExclusive;\n            lastModifiedEndLineNumber = m.modified.endLineNumberExclusive;\n        }\n        const r = ( new LineRangeMapping(( new LineRange(lastOriginalEndLineNumber, originalLineCount + 1)), ( new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1))));\n        if (!r.modified.isEmpty) {\n            result.push(r);\n        }\n        return result;\n    }\n    static clip(mapping, originalRange, modifiedRange) {\n        const result = [];\n        for (const m of mapping) {\n            const original = m.original.intersect(originalRange);\n            const modified = m.modified.intersect(modifiedRange);\n            if (original && !original.isEmpty && modified && !modified.isEmpty) {\n                result.push(( new LineRangeMapping(original, modified)));\n            }\n        }\n        return result;\n    }\n    constructor(originalRange, modifiedRange) {\n        this.original = originalRange;\n        this.modified = modifiedRange;\n    }\n    toString() {\n        return `{${( this.original.toString())}->${( this.modified.toString())}}`;\n    }\n    flip() {\n        return ( new LineRangeMapping(this.modified, this.original));\n    }\n    join(other) {\n        return ( new LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified)));\n    }\n    get changedLineCount() {\n        return Math.max(this.original.length, this.modified.length);\n    }\n    toRangeMapping() {\n        const origInclusiveRange = this.original.toInclusiveRange();\n        const modInclusiveRange = this.modified.toInclusiveRange();\n        if (origInclusiveRange && modInclusiveRange) {\n            return ( new RangeMapping(origInclusiveRange, modInclusiveRange));\n        }\n        else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {\n            if (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) {\n                throw ( new BugIndicatingError('not a valid diff'));\n            }\n            return ( new RangeMapping(( new Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1)), ( new Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1))));\n        }\n        else {\n            return ( new RangeMapping(( new Range(\n                this.original.startLineNumber - 1,\n                Number.MAX_SAFE_INTEGER,\n                this.original.endLineNumberExclusive - 1,\n                Number.MAX_SAFE_INTEGER\n            )), ( new Range(\n                this.modified.startLineNumber - 1,\n                Number.MAX_SAFE_INTEGER,\n                this.modified.endLineNumberExclusive - 1,\n                Number.MAX_SAFE_INTEGER\n            ))));\n        }\n    }\n}\nclass DetailedLineRangeMapping extends LineRangeMapping {\n    static fromRangeMappings(rangeMappings) {\n        const originalRange = LineRange.join(( rangeMappings.map(r => LineRange.fromRangeInclusive(r.originalRange))));\n        const modifiedRange = LineRange.join(( rangeMappings.map(r => LineRange.fromRangeInclusive(r.modifiedRange))));\n        return ( new DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings));\n    }\n    constructor(originalRange, modifiedRange, innerChanges) {\n        super(originalRange, modifiedRange);\n        this.innerChanges = innerChanges;\n    }\n    flip() {\n        return ( new DetailedLineRangeMapping(this.modified, this.original, this.innerChanges?.map(c => c.flip())));\n    }\n    withInnerChangesFromLineRanges() {\n        return ( new DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]));\n    }\n}\nclass RangeMapping {\n    constructor(originalRange, modifiedRange) {\n        this.originalRange = originalRange;\n        this.modifiedRange = modifiedRange;\n    }\n    toString() {\n        return `{${( this.originalRange.toString())}->${( this.modifiedRange.toString())}}`;\n    }\n    flip() {\n        return ( new RangeMapping(this.modifiedRange, this.originalRange));\n    }\n    toTextEdit(modified) {\n        const newText = modified.getValueOfRange(this.modifiedRange);\n        return ( new SingleTextEdit(this.originalRange, newText));\n    }\n}\nexport { DetailedLineRangeMapping, LineRangeMapping, RangeMapping };\n","import { Color, HSLA } from '../../../base/common/color.js';\nfunction _parseCaptureGroups(captureGroups) {\n    const values = [];\n    for (const captureGroup of captureGroups) {\n        const parsedNumber = Number(captureGroup);\n        if (parsedNumber || parsedNumber === 0 && captureGroup.replace(/\\s/g, '') !== '') {\n            values.push(parsedNumber);\n        }\n    }\n    return values;\n}\nfunction _toIColor(r, g, b, a) {\n    return {\n        red: r / 255,\n        blue: b / 255,\n        green: g / 255,\n        alpha: a\n    };\n}\nfunction _findRange(model, match) {\n    const index = match.index;\n    const length = match[0].length;\n    if (!index) {\n        return;\n    }\n    const startPosition = model.positionAt(index);\n    const range = {\n        startLineNumber: startPosition.lineNumber,\n        startColumn: startPosition.column,\n        endLineNumber: startPosition.lineNumber,\n        endColumn: startPosition.column + length\n    };\n    return range;\n}\nfunction _findHexColorInformation(range, hexValue) {\n    if (!range) {\n        return;\n    }\n    const parsedHexColor = Color.Format.CSS.parseHex(hexValue);\n    if (!parsedHexColor) {\n        return;\n    }\n    return {\n        range: range,\n        color: _toIColor(parsedHexColor.rgba.r, parsedHexColor.rgba.g, parsedHexColor.rgba.b, parsedHexColor.rgba.a)\n    };\n}\nfunction _findRGBColorInformation(range, matches, isAlpha) {\n    if (!range || matches.length !== 1) {\n        return;\n    }\n    const match = matches[0];\n    const captureGroups = ( match.values());\n    const parsedRegex = _parseCaptureGroups(captureGroups);\n    return {\n        range: range,\n        color: _toIColor(parsedRegex[0], parsedRegex[1], parsedRegex[2], isAlpha ? parsedRegex[3] : 1)\n    };\n}\nfunction _findHSLColorInformation(range, matches, isAlpha) {\n    if (!range || matches.length !== 1) {\n        return;\n    }\n    const match = matches[0];\n    const captureGroups = ( match.values());\n    const parsedRegex = _parseCaptureGroups(captureGroups);\n    const colorEquivalent = ( new Color(( new HSLA(\n        parsedRegex[0],\n        parsedRegex[1] / 100,\n        parsedRegex[2] / 100,\n        isAlpha ? parsedRegex[3] : 1\n    ))));\n    return {\n        range: range,\n        color: _toIColor(colorEquivalent.rgba.r, colorEquivalent.rgba.g, colorEquivalent.rgba.b, colorEquivalent.rgba.a)\n    };\n}\nfunction _findMatches(model, regex) {\n    if (typeof model === 'string') {\n        return [...model.matchAll(regex)];\n    }\n    else {\n        return model.findMatches(regex);\n    }\n}\nfunction computeColors(model) {\n    const result = [];\n    const initialValidationRegex = /\\b(rgb|rgba|hsl|hsla)(\\([0-9\\s,.\\%]*\\))|(#)([A-Fa-f0-9]{3})\\b|(#)([A-Fa-f0-9]{4})\\b|(#)([A-Fa-f0-9]{6})\\b|(#)([A-Fa-f0-9]{8})\\b/gm;\n    const initialValidationMatches = _findMatches(model, initialValidationRegex);\n    if (initialValidationMatches.length > 0) {\n        for (const initialMatch of initialValidationMatches) {\n            const initialCaptureGroups = initialMatch.filter(captureGroup => captureGroup !== undefined);\n            const colorScheme = initialCaptureGroups[1];\n            const colorParameters = initialCaptureGroups[2];\n            if (!colorParameters) {\n                continue;\n            }\n            let colorInformation;\n            if (colorScheme === 'rgb') {\n                const regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*\\)$/gm;\n                colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\n            }\n            else if (colorScheme === 'rgba') {\n                const regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\\s*\\)$/gm;\n                colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\n            }\n            else if (colorScheme === 'hsl') {\n                const regexParameters = /^\\(\\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*\\)$/gm;\n                colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\n            }\n            else if (colorScheme === 'hsla') {\n                const regexParameters = /^\\(\\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\\s*\\)$/gm;\n                colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\n            }\n            else if (colorScheme === '#') {\n                colorInformation = _findHexColorInformation(_findRange(model, initialMatch), colorScheme + colorParameters);\n            }\n            if (colorInformation) {\n                result.push(colorInformation);\n            }\n        }\n    }\n    return result;\n}\nfunction computeDefaultDocumentColors(model) {\n    if (!model || typeof model.getValue !== 'function' || typeof model.positionAt !== 'function') {\n        return [];\n    }\n    return computeColors(model);\n}\nexport { computeDefaultDocumentColors };\n","class BasicInplaceReplace {\n    constructor() {\n        this._defaultValueSet = [\n            ['true', 'false'],\n            ['True', 'False'],\n            ['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],\n            ['public', 'protected', 'private'],\n        ];\n    }\n    static { this.INSTANCE = ( new BasicInplaceReplace()); }\n    navigateValueSet(range1, text1, range2, text2, up) {\n        if (range1 && text1) {\n            const result = this.doNavigateValueSet(text1, up);\n            if (result) {\n                return {\n                    range: range1,\n                    value: result\n                };\n            }\n        }\n        if (range2 && text2) {\n            const result = this.doNavigateValueSet(text2, up);\n            if (result) {\n                return {\n                    range: range2,\n                    value: result\n                };\n            }\n        }\n        return null;\n    }\n    doNavigateValueSet(text, up) {\n        const numberResult = this.numberReplace(text, up);\n        if (numberResult !== null) {\n            return numberResult;\n        }\n        return this.textReplace(text, up);\n    }\n    numberReplace(value, up) {\n        const precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1));\n        let n1 = Number(value);\n        const n2 = parseFloat(value);\n        if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {\n            if (n1 === 0 && !up) {\n                return null;\n            }\n            else {\n                n1 = Math.floor(n1 * precision);\n                n1 += up ? precision : -precision;\n                return String(n1 / precision);\n            }\n        }\n        return null;\n    }\n    textReplace(value, up) {\n        return this.valueSetsReplace(this._defaultValueSet, value, up);\n    }\n    valueSetsReplace(valueSets, value, up) {\n        let result = null;\n        for (let i = 0, len = valueSets.length; result === null && i < len; i++) {\n            result = this.valueSetReplace(valueSets[i], value, up);\n        }\n        return result;\n    }\n    valueSetReplace(valueSet, value, up) {\n        let idx = valueSet.indexOf(value);\n        if (idx >= 0) {\n            idx += up ? +1 : -1;\n            if (idx < 0) {\n                idx = valueSet.length - 1;\n            }\n            else {\n                idx %= valueSet.length;\n            }\n            return valueSet[idx];\n        }\n        return null;\n    }\n}\nexport { BasicInplaceReplace };\n","import { CancellationTokenSource } from '../../../base/common/cancellation.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { KeyMod as KeyMod$1, KeyChord } from '../../../base/common/keyCodes.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { Token } from '../languages.js';\nimport { KeyCode, SelectionDirection, MarkerSeverity, MarkerTag } from '../standalone/standaloneEnums.js';\nclass KeyMod {\n    static { this.CtrlCmd = KeyMod$1.CtrlCmd; }\n    static { this.Shift = KeyMod$1.Shift; }\n    static { this.Alt = KeyMod$1.Alt; }\n    static { this.WinCtrl = KeyMod$1.WinCtrl; }\n    static chord(firstPart, secondPart) {\n        return KeyChord(firstPart, secondPart);\n    }\n}\nfunction createMonacoBaseAPI() {\n    return {\n        editor: undefined,\n        languages: undefined,\n        CancellationTokenSource: CancellationTokenSource,\n        Emitter: Emitter,\n        KeyCode: KeyCode,\n        KeyMod: KeyMod,\n        Position: Position,\n        Range: Range,\n        Selection: Selection,\n        SelectionDirection: SelectionDirection,\n        MarkerSeverity: MarkerSeverity,\n        MarkerTag: MarkerTag,\n        Uri: URI,\n        Token: Token\n    };\n}\nexport { KeyMod, createMonacoBaseAPI };\n","import { stringDiff } from '../../../base/common/diff/diff.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { MirrorTextModel } from '../model/mirrorTextModel.js';\nimport { getWordAtText, ensureValidWordDefinition } from '../core/wordHelper.js';\nimport { computeLinks } from '../languages/linkComputer.js';\nimport { BasicInplaceReplace } from '../languages/supports/inplaceReplaceSupport.js';\nimport { createMonacoBaseAPI } from './editorBaseApi.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { UnicodeTextModelHighlighter } from './unicodeTextModelHighlighter.js';\nimport { DiffComputer } from '../diff/legacyLinesDiffComputer.js';\nimport { linesDiffComputers } from '../diff/linesDiffComputers.js';\nimport { createProxyObject, getAllMethodNames } from '../../../base/common/objects.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { computeDefaultDocumentColors } from '../languages/defaultDocumentColorsComputer.js';\nimport { findSectionHeaders } from './findSectionHeaders.js';\nclass MirrorModel extends MirrorTextModel {\n    get uri() {\n        return this._uri;\n    }\n    get eol() {\n        return this._eol;\n    }\n    getValue() {\n        return this.getText();\n    }\n    findMatches(regex) {\n        const matches = [];\n        for (let i = 0; i < this._lines.length; i++) {\n            const line = this._lines[i];\n            const offsetToAdd = this.offsetAt(( new Position(i + 1, 1)));\n            const iteratorOverMatches = line.matchAll(regex);\n            for (const match of iteratorOverMatches) {\n                if (match.index || match.index === 0) {\n                    match.index = match.index + offsetToAdd;\n                }\n                matches.push(match);\n            }\n        }\n        return matches;\n    }\n    getLinesContent() {\n        return this._lines.slice(0);\n    }\n    getLineCount() {\n        return this._lines.length;\n    }\n    getLineContent(lineNumber) {\n        return this._lines[lineNumber - 1];\n    }\n    getWordAtPosition(position, wordDefinition) {\n        const wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);\n        if (wordAtText) {\n            return ( new Range(\n                position.lineNumber,\n                wordAtText.startColumn,\n                position.lineNumber,\n                wordAtText.endColumn\n            ));\n        }\n        return null;\n    }\n    getWordUntilPosition(position, wordDefinition) {\n        const wordAtPosition = this.getWordAtPosition(position, wordDefinition);\n        if (!wordAtPosition) {\n            return {\n                word: '',\n                startColumn: position.column,\n                endColumn: position.column\n            };\n        }\n        return {\n            word: this._lines[position.lineNumber - 1].substring(wordAtPosition.startColumn - 1, position.column - 1),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column\n        };\n    }\n    words(wordDefinition) {\n        const lines = this._lines;\n        const wordenize = this._wordenize.bind(this);\n        let lineNumber = 0;\n        let lineText = '';\n        let wordRangesIdx = 0;\n        let wordRanges = [];\n        return {\n            *[Symbol.iterator]() {\n                while (true) {\n                    if (wordRangesIdx < wordRanges.length) {\n                        const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);\n                        wordRangesIdx += 1;\n                        yield value;\n                    }\n                    else {\n                        if (lineNumber < lines.length) {\n                            lineText = lines[lineNumber];\n                            wordRanges = wordenize(lineText, wordDefinition);\n                            wordRangesIdx = 0;\n                            lineNumber += 1;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                }\n            }\n        };\n    }\n    getLineWords(lineNumber, wordDefinition) {\n        const content = this._lines[lineNumber - 1];\n        const ranges = this._wordenize(content, wordDefinition);\n        const words = [];\n        for (const range of ranges) {\n            words.push({\n                word: content.substring(range.start, range.end),\n                startColumn: range.start + 1,\n                endColumn: range.end + 1\n            });\n        }\n        return words;\n    }\n    _wordenize(content, wordDefinition) {\n        const result = [];\n        let match;\n        wordDefinition.lastIndex = 0;\n        while (match = wordDefinition.exec(content)) {\n            if (match[0].length === 0) {\n                break;\n            }\n            result.push({ start: match.index, end: match.index + match[0].length });\n        }\n        return result;\n    }\n    getValueInRange(range) {\n        range = this._validateRange(range);\n        if (range.startLineNumber === range.endLineNumber) {\n            return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\n        }\n        const lineEnding = this._eol;\n        const startLineIndex = range.startLineNumber - 1;\n        const endLineIndex = range.endLineNumber - 1;\n        const resultLines = [];\n        resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\n        for (let i = startLineIndex + 1; i < endLineIndex; i++) {\n            resultLines.push(this._lines[i]);\n        }\n        resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\n        return resultLines.join(lineEnding);\n    }\n    offsetAt(position) {\n        position = this._validatePosition(position);\n        this._ensureLineStarts();\n        return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);\n    }\n    positionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        this._ensureLineStarts();\n        const out = this._lineStarts.getIndexOf(offset);\n        const lineLength = this._lines[out.index].length;\n        return {\n            lineNumber: 1 + out.index,\n            column: 1 + Math.min(out.remainder, lineLength)\n        };\n    }\n    _validateRange(range) {\n        const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });\n        const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });\n        if (start.lineNumber !== range.startLineNumber\n            || start.column !== range.startColumn\n            || end.lineNumber !== range.endLineNumber\n            || end.column !== range.endColumn) {\n            return {\n                startLineNumber: start.lineNumber,\n                startColumn: start.column,\n                endLineNumber: end.lineNumber,\n                endColumn: end.column\n            };\n        }\n        return range;\n    }\n    _validatePosition(position) {\n        if (!Position.isIPosition(position)) {\n            throw ( new Error('bad position'));\n        }\n        let { lineNumber, column } = position;\n        let hasChanged = false;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            column = 1;\n            hasChanged = true;\n        }\n        else if (lineNumber > this._lines.length) {\n            lineNumber = this._lines.length;\n            column = this._lines[lineNumber - 1].length + 1;\n            hasChanged = true;\n        }\n        else {\n            const maxCharacter = this._lines[lineNumber - 1].length + 1;\n            if (column < 1) {\n                column = 1;\n                hasChanged = true;\n            }\n            else if (column > maxCharacter) {\n                column = maxCharacter;\n                hasChanged = true;\n            }\n        }\n        if (!hasChanged) {\n            return position;\n        }\n        else {\n            return { lineNumber, column };\n        }\n    }\n}\nclass EditorSimpleWorker {\n    constructor(host, foreignModuleFactory) {\n        this._host = host;\n        this._models = Object.create(null);\n        this._foreignModuleFactory = foreignModuleFactory;\n        this._foreignModule = null;\n    }\n    dispose() {\n        this._models = Object.create(null);\n    }\n    _getModel(uri) {\n        return this._models[uri];\n    }\n    _getModels() {\n        const all = [];\n        ( Object.keys(this._models)).forEach((key) => all.push(this._models[key]));\n        return all;\n    }\n    acceptNewModel(data) {\n        this._models[data.url] = ( new MirrorModel(( URI.parse(data.url)), data.lines, data.EOL, data.versionId));\n    }\n    acceptModelChanged(strURL, e) {\n        if (!this._models[strURL]) {\n            return;\n        }\n        const model = this._models[strURL];\n        model.onEvents(e);\n    }\n    acceptRemovedModel(strURL) {\n        if (!this._models[strURL]) {\n            return;\n        }\n        delete this._models[strURL];\n    }\n    async computeUnicodeHighlights(url, options, range) {\n        const model = this._getModel(url);\n        if (!model) {\n            return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };\n        }\n        return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);\n    }\n    async findSectionHeaders(url, options) {\n        const model = this._getModel(url);\n        if (!model) {\n            return [];\n        }\n        return findSectionHeaders(model, options);\n    }\n    async computeDiff(originalUrl, modifiedUrl, options, algorithm) {\n        const original = this._getModel(originalUrl);\n        const modified = this._getModel(modifiedUrl);\n        if (!original || !modified) {\n            return null;\n        }\n        const result = EditorSimpleWorker.computeDiff(original, modified, options, algorithm);\n        return result;\n    }\n    static computeDiff(originalTextModel, modifiedTextModel, options, algorithm) {\n        const diffAlgorithm = algorithm === 'advanced' ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();\n        const originalLines = originalTextModel.getLinesContent();\n        const modifiedLines = modifiedTextModel.getLinesContent();\n        const result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);\n        const identical = (result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel));\n        function getLineChanges(changes) {\n            return ( changes.map(\n                m => ([m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, m.innerChanges?.map(m => [\n                        m.originalRange.startLineNumber,\n                        m.originalRange.startColumn,\n                        m.originalRange.endLineNumber,\n                        m.originalRange.endColumn,\n                        m.modifiedRange.startLineNumber,\n                        m.modifiedRange.startColumn,\n                        m.modifiedRange.endLineNumber,\n                        m.modifiedRange.endColumn,\n                    ])])\n            ));\n        }\n        return {\n            identical,\n            quitEarly: result.hitTimeout,\n            changes: getLineChanges(result.changes),\n            moves: ( result.moves.map(m => ([\n                m.lineRangeMapping.original.startLineNumber,\n                m.lineRangeMapping.original.endLineNumberExclusive,\n                m.lineRangeMapping.modified.startLineNumber,\n                m.lineRangeMapping.modified.endLineNumberExclusive,\n                getLineChanges(m.changes)\n            ]))),\n        };\n    }\n    static _modelsAreIdentical(original, modified) {\n        const originalLineCount = original.getLineCount();\n        const modifiedLineCount = modified.getLineCount();\n        if (originalLineCount !== modifiedLineCount) {\n            return false;\n        }\n        for (let line = 1; line <= originalLineCount; line++) {\n            const originalLine = original.getLineContent(line);\n            const modifiedLine = modified.getLineContent(line);\n            if (originalLine !== modifiedLine) {\n                return false;\n            }\n        }\n        return true;\n    }\n    async computeDirtyDiff(originalUrl, modifiedUrl, ignoreTrimWhitespace) {\n        const original = this._getModel(originalUrl);\n        const modified = this._getModel(modifiedUrl);\n        if (!original || !modified) {\n            return null;\n        }\n        const originalLines = original.getLinesContent();\n        const modifiedLines = modified.getLinesContent();\n        const diffComputer = ( new DiffComputer(originalLines, modifiedLines, {\n            shouldComputeCharChanges: false,\n            shouldPostProcessCharChanges: false,\n            shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\n            shouldMakePrettyDiff: true,\n            maxComputationTime: 1000\n        }));\n        return diffComputer.computeDiff().changes;\n    }\n    static { this._diffLimit = 100000; }\n    async computeMoreMinimalEdits(modelUrl, edits, pretty) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return edits;\n        }\n        const result = [];\n        let lastEol = undefined;\n        edits = edits.slice(0).sort((a, b) => {\n            if (a.range && b.range) {\n                return Range.compareRangesUsingStarts(a.range, b.range);\n            }\n            const aRng = a.range ? 0 : 1;\n            const bRng = b.range ? 0 : 1;\n            return aRng - bRng;\n        });\n        let writeIndex = 0;\n        for (let readIndex = 1; readIndex < edits.length; readIndex++) {\n            if (Range.getEndPosition(edits[writeIndex].range).equals(Range.getStartPosition(edits[readIndex].range))) {\n                edits[writeIndex].range = Range.fromPositions(Range.getStartPosition(edits[writeIndex].range), Range.getEndPosition(edits[readIndex].range));\n                edits[writeIndex].text += edits[readIndex].text;\n            }\n            else {\n                writeIndex++;\n                edits[writeIndex] = edits[readIndex];\n            }\n        }\n        edits.length = writeIndex + 1;\n        for (let { range, text, eol } of edits) {\n            if (typeof eol === 'number') {\n                lastEol = eol;\n            }\n            if (Range.isEmpty(range) && !text) {\n                continue;\n            }\n            const original = model.getValueInRange(range);\n            text = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n            if (original === text) {\n                continue;\n            }\n            if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {\n                result.push({ range, text });\n                continue;\n            }\n            const changes = stringDiff(original, text, pretty);\n            const editOffset = model.offsetAt(Range.lift(range).getStartPosition());\n            for (const change of changes) {\n                const start = model.positionAt(editOffset + change.originalStart);\n                const end = model.positionAt(editOffset + change.originalStart + change.originalLength);\n                const newEdit = {\n                    text: text.substr(change.modifiedStart, change.modifiedLength),\n                    range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }\n                };\n                if (model.getValueInRange(newEdit.range) !== newEdit.text) {\n                    result.push(newEdit);\n                }\n            }\n        }\n        if (typeof lastEol === 'number') {\n            result.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\n        }\n        return result;\n    }\n    computeHumanReadableDiff(modelUrl, edits, options) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return edits;\n        }\n        const result = [];\n        let lastEol = undefined;\n        edits = edits.slice(0).sort((a, b) => {\n            if (a.range && b.range) {\n                return Range.compareRangesUsingStarts(a.range, b.range);\n            }\n            const aRng = a.range ? 0 : 1;\n            const bRng = b.range ? 0 : 1;\n            return aRng - bRng;\n        });\n        for (let { range, text, eol } of edits) {\n            if (typeof eol === 'number') {\n                lastEol = eol;\n            }\n            if (Range.isEmpty(range) && !text) {\n                continue;\n            }\n            const original = model.getValueInRange(range);\n            text = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n            if (original === text) {\n                continue;\n            }\n            if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {\n                result.push({ range, text });\n                continue;\n            }\n            const originalLines = original.split(/\\r\\n|\\n|\\r/);\n            const modifiedLines = text.split(/\\r\\n|\\n|\\r/);\n            const diff = linesDiffComputers.getDefault().computeDiff(originalLines, modifiedLines, options);\n            const start = Range.lift(range).getStartPosition();\n            function addPositions(pos1, pos2) {\n                return ( new Position(\n                    pos1.lineNumber + pos2.lineNumber - 1,\n                    pos2.lineNumber === 1 ? pos1.column + pos2.column - 1 : pos2.column\n                ));\n            }\n            function getText(lines, range) {\n                const result = [];\n                for (let i = range.startLineNumber; i <= range.endLineNumber; i++) {\n                    const line = lines[i - 1];\n                    if (i === range.startLineNumber && i === range.endLineNumber) {\n                        result.push(line.substring(range.startColumn - 1, range.endColumn - 1));\n                    }\n                    else if (i === range.startLineNumber) {\n                        result.push(line.substring(range.startColumn - 1));\n                    }\n                    else if (i === range.endLineNumber) {\n                        result.push(line.substring(0, range.endColumn - 1));\n                    }\n                    else {\n                        result.push(line);\n                    }\n                }\n                return result;\n            }\n            for (const c of diff.changes) {\n                if (c.innerChanges) {\n                    for (const x of c.innerChanges) {\n                        result.push({\n                            range: Range.fromPositions(addPositions(start, x.originalRange.getStartPosition()), addPositions(start, x.originalRange.getEndPosition())),\n                            text: getText(modifiedLines, x.modifiedRange).join(model.eol)\n                        });\n                    }\n                }\n                else {\n                    throw ( new BugIndicatingError('The experimental diff algorithm always produces inner changes'));\n                }\n            }\n        }\n        if (typeof lastEol === 'number') {\n            result.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\n        }\n        return result;\n    }\n    async computeLinks(modelUrl) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return null;\n        }\n        return computeLinks(model);\n    }\n    async computeDefaultDocumentColors(modelUrl) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return null;\n        }\n        return computeDefaultDocumentColors(model);\n    }\n    static { this._suggestionsLimit = 10000; }\n    async textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {\n        const sw = ( new StopWatch());\n        const wordDefRegExp = ( new RegExp(wordDef, wordDefFlags));\n        const seen = ( new Set());\n        outer: for (const url of modelUrls) {\n            const model = this._getModel(url);\n            if (!model) {\n                continue;\n            }\n            for (const word of model.words(wordDefRegExp)) {\n                if (word === leadingWord || !isNaN(Number(word))) {\n                    continue;\n                }\n                seen.add(word);\n                if (seen.size > EditorSimpleWorker._suggestionsLimit) {\n                    break outer;\n                }\n            }\n        }\n        return { words: Array.from(seen), duration: sw.elapsed() };\n    }\n    async computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return Object.create(null);\n        }\n        const wordDefRegExp = ( new RegExp(wordDef, wordDefFlags));\n        const result = Object.create(null);\n        for (let line = range.startLineNumber; line < range.endLineNumber; line++) {\n            const words = model.getLineWords(line, wordDefRegExp);\n            for (const word of words) {\n                if (!isNaN(Number(word.word))) {\n                    continue;\n                }\n                let array = result[word.word];\n                if (!array) {\n                    array = [];\n                    result[word.word] = array;\n                }\n                array.push({\n                    startLineNumber: line,\n                    startColumn: word.startColumn,\n                    endLineNumber: line,\n                    endColumn: word.endColumn\n                });\n            }\n        }\n        return result;\n    }\n    async navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return null;\n        }\n        const wordDefRegExp = ( new RegExp(wordDef, wordDefFlags));\n        if (range.startColumn === range.endColumn) {\n            range = {\n                startLineNumber: range.startLineNumber,\n                startColumn: range.startColumn,\n                endLineNumber: range.endLineNumber,\n                endColumn: range.endColumn + 1\n            };\n        }\n        const selectionText = model.getValueInRange(range);\n        const wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\n        if (!wordRange) {\n            return null;\n        }\n        const word = model.getValueInRange(wordRange);\n        const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\n        return result;\n    }\n    loadForeignModule(moduleId, createData, foreignHostMethods) {\n        const proxyMethodRequest = (method, args) => {\n            return this._host.fhr(method, args);\n        };\n        const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);\n        const ctx = {\n            host: foreignHost,\n            getMirrorModels: () => {\n                return this._getModels();\n            }\n        };\n        if (this._foreignModuleFactory) {\n            this._foreignModule = this._foreignModuleFactory(ctx, createData);\n            return Promise.resolve(getAllMethodNames(this._foreignModule));\n        }\n        return Promise.reject(( new Error(`Unexpected usage`)));\n    }\n    fmr(method, args) {\n        if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {\n            return Promise.reject(( new Error('Missing requestHandler or method: ' + method)));\n        }\n        try {\n            return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n}\nif (typeof importScripts === 'function') {\n    globalThis.monaco = createMonacoBaseAPI();\n}\nexport { EditorSimpleWorker };\n","const markRegex = ( new RegExp('\\\\bMARK:\\\\s*(.*)$', 'd'));\nconst trimDashesRegex = /^-+|-+$/g;\nfunction findSectionHeaders(model, options) {\n    let headers = [];\n    if (options.findRegionSectionHeaders && options.foldingRules?.markers) {\n        const regionHeaders = collectRegionHeaders(model, options);\n        headers = headers.concat(regionHeaders);\n    }\n    if (options.findMarkSectionHeaders) {\n        const markHeaders = collectMarkHeaders(model);\n        headers = headers.concat(markHeaders);\n    }\n    return headers;\n}\nfunction collectRegionHeaders(model, options) {\n    const regionHeaders = [];\n    const endLineNumber = model.getLineCount();\n    for (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {\n        const lineContent = model.getLineContent(lineNumber);\n        const match = lineContent.match(options.foldingRules.markers.start);\n        if (match) {\n            const range = { startLineNumber: lineNumber, startColumn: match[0].length + 1, endLineNumber: lineNumber, endColumn: lineContent.length + 1 };\n            if (range.endColumn > range.startColumn) {\n                const sectionHeader = {\n                    range,\n                    ...getHeaderText(lineContent.substring(match[0].length)),\n                    shouldBeInComments: false\n                };\n                if (sectionHeader.text || sectionHeader.hasSeparatorLine) {\n                    regionHeaders.push(sectionHeader);\n                }\n            }\n        }\n    }\n    return regionHeaders;\n}\nfunction collectMarkHeaders(model) {\n    const markHeaders = [];\n    const endLineNumber = model.getLineCount();\n    for (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {\n        const lineContent = model.getLineContent(lineNumber);\n        addMarkHeaderIfFound(lineContent, lineNumber, markHeaders);\n    }\n    return markHeaders;\n}\nfunction addMarkHeaderIfFound(lineContent, lineNumber, sectionHeaders) {\n    markRegex.lastIndex = 0;\n    const match = markRegex.exec(lineContent);\n    if (match) {\n        const column = match.indices[1][0] + 1;\n        const endColumn = match.indices[1][1] + 1;\n        const range = { startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: endColumn };\n        if (range.endColumn > range.startColumn) {\n            const sectionHeader = {\n                range,\n                ...getHeaderText(match[1]),\n                shouldBeInComments: true\n            };\n            if (sectionHeader.text || sectionHeader.hasSeparatorLine) {\n                sectionHeaders.push(sectionHeader);\n            }\n        }\n    }\n}\nfunction getHeaderText(text) {\n    text = text.trim();\n    const hasSeparatorLine = text.startsWith('-');\n    text = text.replace(trimDashesRegex, '');\n    return { text, hasSeparatorLine };\n}\nexport { findSectionHeaders };\n","import { Range } from '../core/range.js';\nimport { Searcher } from '../model/textModelSearch.js';\nimport { isHighSurrogate, AmbiguousCharacters, escapeRegExpCharacters, InvisibleCharacters, isBasicASCII } from '../../../base/common/strings.js';\nimport { assertNever } from '../../../base/common/assert.js';\nimport { getWordAtText, DEFAULT_WORD_REGEXP } from '../core/wordHelper.js';\nclass UnicodeTextModelHighlighter {\n    static computeUnicodeHighlights(model, options, range) {\n        const startLine = range ? range.startLineNumber : 1;\n        const endLine = range ? range.endLineNumber : model.getLineCount();\n        const codePointHighlighter = ( new CodePointHighlighter(options));\n        const candidates = codePointHighlighter.getCandidateCodePoints();\n        let regex;\n        if (candidates === 'allNonBasicAscii') {\n            regex = ( new RegExp('[^\\\\t\\\\n\\\\r\\\\x20-\\\\x7E]', 'g'));\n        }\n        else {\n            regex = ( new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, 'g'));\n        }\n        const searcher = ( new Searcher(null, regex));\n        const ranges = [];\n        let hasMore = false;\n        let m;\n        let ambiguousCharacterCount = 0;\n        let invisibleCharacterCount = 0;\n        let nonBasicAsciiCharacterCount = 0;\n        forLoop: for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {\n            const lineContent = model.getLineContent(lineNumber);\n            const lineLength = lineContent.length;\n            searcher.reset(0);\n            do {\n                m = searcher.next(lineContent);\n                if (m) {\n                    let startIndex = m.index;\n                    let endIndex = m.index + m[0].length;\n                    if (startIndex > 0) {\n                        const charCodeBefore = lineContent.charCodeAt(startIndex - 1);\n                        if (isHighSurrogate(charCodeBefore)) {\n                            startIndex--;\n                        }\n                    }\n                    if (endIndex + 1 < lineLength) {\n                        const charCodeBefore = lineContent.charCodeAt(endIndex - 1);\n                        if (isHighSurrogate(charCodeBefore)) {\n                            endIndex++;\n                        }\n                    }\n                    const str = lineContent.substring(startIndex, endIndex);\n                    let word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);\n                    if (word && word.endColumn <= startIndex + 1) {\n                        word = null;\n                    }\n                    const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);\n                    if (highlightReason !== SimpleHighlightReason.None) {\n                        if (highlightReason === SimpleHighlightReason.Ambiguous) {\n                            ambiguousCharacterCount++;\n                        }\n                        else if (highlightReason === SimpleHighlightReason.Invisible) {\n                            invisibleCharacterCount++;\n                        }\n                        else if (highlightReason === SimpleHighlightReason.NonBasicASCII) {\n                            nonBasicAsciiCharacterCount++;\n                        }\n                        else {\n                            assertNever();\n                        }\n                        const MAX_RESULT_LENGTH = 1000;\n                        if (ranges.length >= MAX_RESULT_LENGTH) {\n                            hasMore = true;\n                            break forLoop;\n                        }\n                        ranges.push(( new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1)));\n                    }\n                }\n            } while (m);\n        }\n        return {\n            ranges,\n            hasMore,\n            ambiguousCharacterCount,\n            invisibleCharacterCount,\n            nonBasicAsciiCharacterCount\n        };\n    }\n    static computeUnicodeHighlightReason(char, options) {\n        const codePointHighlighter = ( new CodePointHighlighter(options));\n        const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);\n        switch (reason) {\n            case SimpleHighlightReason.None:\n                return null;\n            case SimpleHighlightReason.Invisible:\n                return { kind: UnicodeHighlighterReasonKind.Invisible };\n            case SimpleHighlightReason.Ambiguous: {\n                const codePoint = char.codePointAt(0);\n                const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);\n                const notAmbiguousInLocales = AmbiguousCharacters.getLocales().filter((l) => !AmbiguousCharacters.getInstance(( new Set([...options.allowedLocales, l]))).isAmbiguous(codePoint));\n                return { kind: UnicodeHighlighterReasonKind.Ambiguous, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };\n            }\n            case SimpleHighlightReason.NonBasicASCII:\n                return { kind: UnicodeHighlighterReasonKind.NonBasicAscii };\n        }\n    }\n}\nfunction buildRegExpCharClassExpr(codePoints, flags) {\n    const src = `[${escapeRegExpCharacters(( codePoints.map((i) => String.fromCodePoint(i))).join(''))}]`;\n    return src;\n}\nvar UnicodeHighlighterReasonKind;\n( (function(UnicodeHighlighterReasonKind) {\n    UnicodeHighlighterReasonKind[UnicodeHighlighterReasonKind[\"Ambiguous\"] = 0] = \"Ambiguous\";\n    UnicodeHighlighterReasonKind[UnicodeHighlighterReasonKind[\"Invisible\"] = 1] = \"Invisible\";\n    UnicodeHighlighterReasonKind[UnicodeHighlighterReasonKind[\"NonBasicAscii\"] = 2] = \"NonBasicAscii\";\n})(UnicodeHighlighterReasonKind || (UnicodeHighlighterReasonKind = {})));\nclass CodePointHighlighter {\n    constructor(options) {\n        this.options = options;\n        this.allowedCodePoints = ( new Set(options.allowedCodePoints));\n        this.ambiguousCharacters = AmbiguousCharacters.getInstance(( new Set(options.allowedLocales)));\n    }\n    getCandidateCodePoints() {\n        if (this.options.nonBasicASCII) {\n            return 'allNonBasicAscii';\n        }\n        const set = ( new Set());\n        if (this.options.invisibleCharacters) {\n            for (const cp of InvisibleCharacters.codePoints) {\n                if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {\n                    set.add(cp);\n                }\n            }\n        }\n        if (this.options.ambiguousCharacters) {\n            for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {\n                set.add(cp);\n            }\n        }\n        for (const cp of this.allowedCodePoints) {\n            set.delete(cp);\n        }\n        return set;\n    }\n    shouldHighlightNonBasicASCII(character, wordContext) {\n        const codePoint = character.codePointAt(0);\n        if (( this.allowedCodePoints.has(codePoint))) {\n            return SimpleHighlightReason.None;\n        }\n        if (this.options.nonBasicASCII) {\n            return SimpleHighlightReason.NonBasicASCII;\n        }\n        let hasBasicASCIICharacters = false;\n        let hasNonConfusableNonBasicAsciiCharacter = false;\n        if (wordContext) {\n            for (const char of wordContext) {\n                const codePoint = char.codePointAt(0);\n                const isBasicASCII$1 = isBasicASCII(char);\n                hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII$1;\n                if (!isBasicASCII$1 &&\n                    !this.ambiguousCharacters.isAmbiguous(codePoint) &&\n                    !InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n                    hasNonConfusableNonBasicAsciiCharacter = true;\n                }\n            }\n        }\n        if (\n         !hasBasicASCIICharacters &&\n             hasNonConfusableNonBasicAsciiCharacter) {\n            return SimpleHighlightReason.None;\n        }\n        if (this.options.invisibleCharacters) {\n            if (!isAllowedInvisibleCharacter(character) && InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n                return SimpleHighlightReason.Invisible;\n            }\n        }\n        if (this.options.ambiguousCharacters) {\n            if (this.ambiguousCharacters.isAmbiguous(codePoint)) {\n                return SimpleHighlightReason.Ambiguous;\n            }\n        }\n        return SimpleHighlightReason.None;\n    }\n}\nfunction isAllowedInvisibleCharacter(character) {\n    return character === ' ' || character === '\\n' || character === '\\t';\n}\nvar SimpleHighlightReason;\n( (function(SimpleHighlightReason) {\n    SimpleHighlightReason[SimpleHighlightReason[\"None\"] = 0] = \"None\";\n    SimpleHighlightReason[SimpleHighlightReason[\"NonBasicASCII\"] = 1] = \"NonBasicASCII\";\n    SimpleHighlightReason[SimpleHighlightReason[\"Invisible\"] = 2] = \"Invisible\";\n    SimpleHighlightReason[SimpleHighlightReason[\"Ambiguous\"] = 3] = \"Ambiguous\";\n})(SimpleHighlightReason || (SimpleHighlightReason = {})));\nexport { UnicodeHighlighterReasonKind, UnicodeTextModelHighlighter };\n","var AccessibilitySupport;\n( (function(AccessibilitySupport) {\n    AccessibilitySupport[AccessibilitySupport[\"Unknown\"] = 0] = \"Unknown\";\n    AccessibilitySupport[AccessibilitySupport[\"Disabled\"] = 1] = \"Disabled\";\n    AccessibilitySupport[AccessibilitySupport[\"Enabled\"] = 2] = \"Enabled\";\n})(AccessibilitySupport || (AccessibilitySupport = {})));\nvar CodeActionTriggerType;\n( (function(CodeActionTriggerType) {\n    CodeActionTriggerType[CodeActionTriggerType[\"Invoke\"] = 1] = \"Invoke\";\n    CodeActionTriggerType[CodeActionTriggerType[\"Auto\"] = 2] = \"Auto\";\n})(CodeActionTriggerType || (CodeActionTriggerType = {})));\nvar CompletionItemInsertTextRule;\n( (function(CompletionItemInsertTextRule) {\n    CompletionItemInsertTextRule[CompletionItemInsertTextRule[\"None\"] = 0] = \"None\";\n    CompletionItemInsertTextRule[CompletionItemInsertTextRule[\"KeepWhitespace\"] = 1] = \"KeepWhitespace\";\n    CompletionItemInsertTextRule[CompletionItemInsertTextRule[\"InsertAsSnippet\"] = 4] = \"InsertAsSnippet\";\n})(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {})));\nvar CompletionItemKind;\n( (function(CompletionItemKind) {\n    CompletionItemKind[CompletionItemKind[\"Method\"] = 0] = \"Method\";\n    CompletionItemKind[CompletionItemKind[\"Function\"] = 1] = \"Function\";\n    CompletionItemKind[CompletionItemKind[\"Constructor\"] = 2] = \"Constructor\";\n    CompletionItemKind[CompletionItemKind[\"Field\"] = 3] = \"Field\";\n    CompletionItemKind[CompletionItemKind[\"Variable\"] = 4] = \"Variable\";\n    CompletionItemKind[CompletionItemKind[\"Class\"] = 5] = \"Class\";\n    CompletionItemKind[CompletionItemKind[\"Struct\"] = 6] = \"Struct\";\n    CompletionItemKind[CompletionItemKind[\"Interface\"] = 7] = \"Interface\";\n    CompletionItemKind[CompletionItemKind[\"Module\"] = 8] = \"Module\";\n    CompletionItemKind[CompletionItemKind[\"Property\"] = 9] = \"Property\";\n    CompletionItemKind[CompletionItemKind[\"Event\"] = 10] = \"Event\";\n    CompletionItemKind[CompletionItemKind[\"Operator\"] = 11] = \"Operator\";\n    CompletionItemKind[CompletionItemKind[\"Unit\"] = 12] = \"Unit\";\n    CompletionItemKind[CompletionItemKind[\"Value\"] = 13] = \"Value\";\n    CompletionItemKind[CompletionItemKind[\"Constant\"] = 14] = \"Constant\";\n    CompletionItemKind[CompletionItemKind[\"Enum\"] = 15] = \"Enum\";\n    CompletionItemKind[CompletionItemKind[\"EnumMember\"] = 16] = \"EnumMember\";\n    CompletionItemKind[CompletionItemKind[\"Keyword\"] = 17] = \"Keyword\";\n    CompletionItemKind[CompletionItemKind[\"Text\"] = 18] = \"Text\";\n    CompletionItemKind[CompletionItemKind[\"Color\"] = 19] = \"Color\";\n    CompletionItemKind[CompletionItemKind[\"File\"] = 20] = \"File\";\n    CompletionItemKind[CompletionItemKind[\"Reference\"] = 21] = \"Reference\";\n    CompletionItemKind[CompletionItemKind[\"Customcolor\"] = 22] = \"Customcolor\";\n    CompletionItemKind[CompletionItemKind[\"Folder\"] = 23] = \"Folder\";\n    CompletionItemKind[CompletionItemKind[\"TypeParameter\"] = 24] = \"TypeParameter\";\n    CompletionItemKind[CompletionItemKind[\"User\"] = 25] = \"User\";\n    CompletionItemKind[CompletionItemKind[\"Issue\"] = 26] = \"Issue\";\n    CompletionItemKind[CompletionItemKind[\"Snippet\"] = 27] = \"Snippet\";\n})(CompletionItemKind || (CompletionItemKind = {})));\nvar CompletionItemTag;\n( (function(CompletionItemTag) {\n    CompletionItemTag[CompletionItemTag[\"Deprecated\"] = 1] = \"Deprecated\";\n})(CompletionItemTag || (CompletionItemTag = {})));\nvar CompletionTriggerKind;\n( (function(CompletionTriggerKind) {\n    CompletionTriggerKind[CompletionTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\n    CompletionTriggerKind[CompletionTriggerKind[\"TriggerCharacter\"] = 1] = \"TriggerCharacter\";\n    CompletionTriggerKind[CompletionTriggerKind[\"TriggerForIncompleteCompletions\"] = 2] = \"TriggerForIncompleteCompletions\";\n})(CompletionTriggerKind || (CompletionTriggerKind = {})));\nvar ContentWidgetPositionPreference;\n( (function(ContentWidgetPositionPreference) {\n    ContentWidgetPositionPreference[ContentWidgetPositionPreference[\"EXACT\"] = 0] = \"EXACT\";\n    ContentWidgetPositionPreference[ContentWidgetPositionPreference[\"ABOVE\"] = 1] = \"ABOVE\";\n    ContentWidgetPositionPreference[ContentWidgetPositionPreference[\"BELOW\"] = 2] = \"BELOW\";\n})(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {})));\nvar CursorChangeReason;\n( (function(CursorChangeReason) {\n    CursorChangeReason[CursorChangeReason[\"NotSet\"] = 0] = \"NotSet\";\n    CursorChangeReason[CursorChangeReason[\"ContentFlush\"] = 1] = \"ContentFlush\";\n    CursorChangeReason[CursorChangeReason[\"RecoverFromMarkers\"] = 2] = \"RecoverFromMarkers\";\n    CursorChangeReason[CursorChangeReason[\"Explicit\"] = 3] = \"Explicit\";\n    CursorChangeReason[CursorChangeReason[\"Paste\"] = 4] = \"Paste\";\n    CursorChangeReason[CursorChangeReason[\"Undo\"] = 5] = \"Undo\";\n    CursorChangeReason[CursorChangeReason[\"Redo\"] = 6] = \"Redo\";\n})(CursorChangeReason || (CursorChangeReason = {})));\nvar DefaultEndOfLine;\n( (function(DefaultEndOfLine) {\n    DefaultEndOfLine[DefaultEndOfLine[\"LF\"] = 1] = \"LF\";\n    DefaultEndOfLine[DefaultEndOfLine[\"CRLF\"] = 2] = \"CRLF\";\n})(DefaultEndOfLine || (DefaultEndOfLine = {})));\nvar DocumentHighlightKind;\n( (function(DocumentHighlightKind) {\n    DocumentHighlightKind[DocumentHighlightKind[\"Text\"] = 0] = \"Text\";\n    DocumentHighlightKind[DocumentHighlightKind[\"Read\"] = 1] = \"Read\";\n    DocumentHighlightKind[DocumentHighlightKind[\"Write\"] = 2] = \"Write\";\n})(DocumentHighlightKind || (DocumentHighlightKind = {})));\nvar EditorAutoIndentStrategy;\n( (function(EditorAutoIndentStrategy) {\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"None\"] = 0] = \"None\";\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"Keep\"] = 1] = \"Keep\";\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"Brackets\"] = 2] = \"Brackets\";\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"Advanced\"] = 3] = \"Advanced\";\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"Full\"] = 4] = \"Full\";\n})(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {})));\nvar EditorOption;\n( (function(EditorOption) {\n    EditorOption[EditorOption[\"acceptSuggestionOnCommitCharacter\"] = 0] = \"acceptSuggestionOnCommitCharacter\";\n    EditorOption[EditorOption[\"acceptSuggestionOnEnter\"] = 1] = \"acceptSuggestionOnEnter\";\n    EditorOption[EditorOption[\"accessibilitySupport\"] = 2] = \"accessibilitySupport\";\n    EditorOption[EditorOption[\"accessibilityPageSize\"] = 3] = \"accessibilityPageSize\";\n    EditorOption[EditorOption[\"ariaLabel\"] = 4] = \"ariaLabel\";\n    EditorOption[EditorOption[\"ariaRequired\"] = 5] = \"ariaRequired\";\n    EditorOption[EditorOption[\"autoClosingBrackets\"] = 6] = \"autoClosingBrackets\";\n    EditorOption[EditorOption[\"autoClosingComments\"] = 7] = \"autoClosingComments\";\n    EditorOption[EditorOption[\"screenReaderAnnounceInlineSuggestion\"] = 8] = \"screenReaderAnnounceInlineSuggestion\";\n    EditorOption[EditorOption[\"autoClosingDelete\"] = 9] = \"autoClosingDelete\";\n    EditorOption[EditorOption[\"autoClosingOvertype\"] = 10] = \"autoClosingOvertype\";\n    EditorOption[EditorOption[\"autoClosingQuotes\"] = 11] = \"autoClosingQuotes\";\n    EditorOption[EditorOption[\"autoIndent\"] = 12] = \"autoIndent\";\n    EditorOption[EditorOption[\"automaticLayout\"] = 13] = \"automaticLayout\";\n    EditorOption[EditorOption[\"autoSurround\"] = 14] = \"autoSurround\";\n    EditorOption[EditorOption[\"bracketPairColorization\"] = 15] = \"bracketPairColorization\";\n    EditorOption[EditorOption[\"guides\"] = 16] = \"guides\";\n    EditorOption[EditorOption[\"codeLens\"] = 17] = \"codeLens\";\n    EditorOption[EditorOption[\"codeLensFontFamily\"] = 18] = \"codeLensFontFamily\";\n    EditorOption[EditorOption[\"codeLensFontSize\"] = 19] = \"codeLensFontSize\";\n    EditorOption[EditorOption[\"colorDecorators\"] = 20] = \"colorDecorators\";\n    EditorOption[EditorOption[\"colorDecoratorsLimit\"] = 21] = \"colorDecoratorsLimit\";\n    EditorOption[EditorOption[\"columnSelection\"] = 22] = \"columnSelection\";\n    EditorOption[EditorOption[\"comments\"] = 23] = \"comments\";\n    EditorOption[EditorOption[\"contextmenu\"] = 24] = \"contextmenu\";\n    EditorOption[EditorOption[\"copyWithSyntaxHighlighting\"] = 25] = \"copyWithSyntaxHighlighting\";\n    EditorOption[EditorOption[\"cursorBlinking\"] = 26] = \"cursorBlinking\";\n    EditorOption[EditorOption[\"cursorSmoothCaretAnimation\"] = 27] = \"cursorSmoothCaretAnimation\";\n    EditorOption[EditorOption[\"cursorStyle\"] = 28] = \"cursorStyle\";\n    EditorOption[EditorOption[\"cursorSurroundingLines\"] = 29] = \"cursorSurroundingLines\";\n    EditorOption[EditorOption[\"cursorSurroundingLinesStyle\"] = 30] = \"cursorSurroundingLinesStyle\";\n    EditorOption[EditorOption[\"cursorWidth\"] = 31] = \"cursorWidth\";\n    EditorOption[EditorOption[\"disableLayerHinting\"] = 32] = \"disableLayerHinting\";\n    EditorOption[EditorOption[\"disableMonospaceOptimizations\"] = 33] = \"disableMonospaceOptimizations\";\n    EditorOption[EditorOption[\"domReadOnly\"] = 34] = \"domReadOnly\";\n    EditorOption[EditorOption[\"dragAndDrop\"] = 35] = \"dragAndDrop\";\n    EditorOption[EditorOption[\"dropIntoEditor\"] = 36] = \"dropIntoEditor\";\n    EditorOption[EditorOption[\"emptySelectionClipboard\"] = 37] = \"emptySelectionClipboard\";\n    EditorOption[EditorOption[\"experimentalWhitespaceRendering\"] = 38] = \"experimentalWhitespaceRendering\";\n    EditorOption[EditorOption[\"extraEditorClassName\"] = 39] = \"extraEditorClassName\";\n    EditorOption[EditorOption[\"fastScrollSensitivity\"] = 40] = \"fastScrollSensitivity\";\n    EditorOption[EditorOption[\"find\"] = 41] = \"find\";\n    EditorOption[EditorOption[\"fixedOverflowWidgets\"] = 42] = \"fixedOverflowWidgets\";\n    EditorOption[EditorOption[\"folding\"] = 43] = \"folding\";\n    EditorOption[EditorOption[\"foldingStrategy\"] = 44] = \"foldingStrategy\";\n    EditorOption[EditorOption[\"foldingHighlight\"] = 45] = \"foldingHighlight\";\n    EditorOption[EditorOption[\"foldingImportsByDefault\"] = 46] = \"foldingImportsByDefault\";\n    EditorOption[EditorOption[\"foldingMaximumRegions\"] = 47] = \"foldingMaximumRegions\";\n    EditorOption[EditorOption[\"unfoldOnClickAfterEndOfLine\"] = 48] = \"unfoldOnClickAfterEndOfLine\";\n    EditorOption[EditorOption[\"fontFamily\"] = 49] = \"fontFamily\";\n    EditorOption[EditorOption[\"fontInfo\"] = 50] = \"fontInfo\";\n    EditorOption[EditorOption[\"fontLigatures\"] = 51] = \"fontLigatures\";\n    EditorOption[EditorOption[\"fontSize\"] = 52] = \"fontSize\";\n    EditorOption[EditorOption[\"fontWeight\"] = 53] = \"fontWeight\";\n    EditorOption[EditorOption[\"fontVariations\"] = 54] = \"fontVariations\";\n    EditorOption[EditorOption[\"formatOnPaste\"] = 55] = \"formatOnPaste\";\n    EditorOption[EditorOption[\"formatOnType\"] = 56] = \"formatOnType\";\n    EditorOption[EditorOption[\"glyphMargin\"] = 57] = \"glyphMargin\";\n    EditorOption[EditorOption[\"gotoLocation\"] = 58] = \"gotoLocation\";\n    EditorOption[EditorOption[\"hideCursorInOverviewRuler\"] = 59] = \"hideCursorInOverviewRuler\";\n    EditorOption[EditorOption[\"hover\"] = 60] = \"hover\";\n    EditorOption[EditorOption[\"inDiffEditor\"] = 61] = \"inDiffEditor\";\n    EditorOption[EditorOption[\"inlineSuggest\"] = 62] = \"inlineSuggest\";\n    EditorOption[EditorOption[\"inlineEdit\"] = 63] = \"inlineEdit\";\n    EditorOption[EditorOption[\"letterSpacing\"] = 64] = \"letterSpacing\";\n    EditorOption[EditorOption[\"lightbulb\"] = 65] = \"lightbulb\";\n    EditorOption[EditorOption[\"lineDecorationsWidth\"] = 66] = \"lineDecorationsWidth\";\n    EditorOption[EditorOption[\"lineHeight\"] = 67] = \"lineHeight\";\n    EditorOption[EditorOption[\"lineNumbers\"] = 68] = \"lineNumbers\";\n    EditorOption[EditorOption[\"lineNumbersMinChars\"] = 69] = \"lineNumbersMinChars\";\n    EditorOption[EditorOption[\"linkedEditing\"] = 70] = \"linkedEditing\";\n    EditorOption[EditorOption[\"links\"] = 71] = \"links\";\n    EditorOption[EditorOption[\"matchBrackets\"] = 72] = \"matchBrackets\";\n    EditorOption[EditorOption[\"minimap\"] = 73] = \"minimap\";\n    EditorOption[EditorOption[\"mouseStyle\"] = 74] = \"mouseStyle\";\n    EditorOption[EditorOption[\"mouseWheelScrollSensitivity\"] = 75] = \"mouseWheelScrollSensitivity\";\n    EditorOption[EditorOption[\"mouseWheelZoom\"] = 76] = \"mouseWheelZoom\";\n    EditorOption[EditorOption[\"multiCursorMergeOverlapping\"] = 77] = \"multiCursorMergeOverlapping\";\n    EditorOption[EditorOption[\"multiCursorModifier\"] = 78] = \"multiCursorModifier\";\n    EditorOption[EditorOption[\"multiCursorPaste\"] = 79] = \"multiCursorPaste\";\n    EditorOption[EditorOption[\"multiCursorLimit\"] = 80] = \"multiCursorLimit\";\n    EditorOption[EditorOption[\"occurrencesHighlight\"] = 81] = \"occurrencesHighlight\";\n    EditorOption[EditorOption[\"overviewRulerBorder\"] = 82] = \"overviewRulerBorder\";\n    EditorOption[EditorOption[\"overviewRulerLanes\"] = 83] = \"overviewRulerLanes\";\n    EditorOption[EditorOption[\"padding\"] = 84] = \"padding\";\n    EditorOption[EditorOption[\"pasteAs\"] = 85] = \"pasteAs\";\n    EditorOption[EditorOption[\"parameterHints\"] = 86] = \"parameterHints\";\n    EditorOption[EditorOption[\"peekWidgetDefaultFocus\"] = 87] = \"peekWidgetDefaultFocus\";\n    EditorOption[EditorOption[\"placeholder\"] = 88] = \"placeholder\";\n    EditorOption[EditorOption[\"definitionLinkOpensInPeek\"] = 89] = \"definitionLinkOpensInPeek\";\n    EditorOption[EditorOption[\"quickSuggestions\"] = 90] = \"quickSuggestions\";\n    EditorOption[EditorOption[\"quickSuggestionsDelay\"] = 91] = \"quickSuggestionsDelay\";\n    EditorOption[EditorOption[\"readOnly\"] = 92] = \"readOnly\";\n    EditorOption[EditorOption[\"readOnlyMessage\"] = 93] = \"readOnlyMessage\";\n    EditorOption[EditorOption[\"renameOnType\"] = 94] = \"renameOnType\";\n    EditorOption[EditorOption[\"renderControlCharacters\"] = 95] = \"renderControlCharacters\";\n    EditorOption[EditorOption[\"renderFinalNewline\"] = 96] = \"renderFinalNewline\";\n    EditorOption[EditorOption[\"renderLineHighlight\"] = 97] = \"renderLineHighlight\";\n    EditorOption[EditorOption[\"renderLineHighlightOnlyWhenFocus\"] = 98] = \"renderLineHighlightOnlyWhenFocus\";\n    EditorOption[EditorOption[\"renderValidationDecorations\"] = 99] = \"renderValidationDecorations\";\n    EditorOption[EditorOption[\"renderWhitespace\"] = 100] = \"renderWhitespace\";\n    EditorOption[EditorOption[\"revealHorizontalRightPadding\"] = 101] = \"revealHorizontalRightPadding\";\n    EditorOption[EditorOption[\"roundedSelection\"] = 102] = \"roundedSelection\";\n    EditorOption[EditorOption[\"rulers\"] = 103] = \"rulers\";\n    EditorOption[EditorOption[\"scrollbar\"] = 104] = \"scrollbar\";\n    EditorOption[EditorOption[\"scrollBeyondLastColumn\"] = 105] = \"scrollBeyondLastColumn\";\n    EditorOption[EditorOption[\"scrollBeyondLastLine\"] = 106] = \"scrollBeyondLastLine\";\n    EditorOption[EditorOption[\"scrollPredominantAxis\"] = 107] = \"scrollPredominantAxis\";\n    EditorOption[EditorOption[\"selectionClipboard\"] = 108] = \"selectionClipboard\";\n    EditorOption[EditorOption[\"selectionHighlight\"] = 109] = \"selectionHighlight\";\n    EditorOption[EditorOption[\"selectOnLineNumbers\"] = 110] = \"selectOnLineNumbers\";\n    EditorOption[EditorOption[\"showFoldingControls\"] = 111] = \"showFoldingControls\";\n    EditorOption[EditorOption[\"showUnused\"] = 112] = \"showUnused\";\n    EditorOption[EditorOption[\"snippetSuggestions\"] = 113] = \"snippetSuggestions\";\n    EditorOption[EditorOption[\"smartSelect\"] = 114] = \"smartSelect\";\n    EditorOption[EditorOption[\"smoothScrolling\"] = 115] = \"smoothScrolling\";\n    EditorOption[EditorOption[\"stickyScroll\"] = 116] = \"stickyScroll\";\n    EditorOption[EditorOption[\"stickyTabStops\"] = 117] = \"stickyTabStops\";\n    EditorOption[EditorOption[\"stopRenderingLineAfter\"] = 118] = \"stopRenderingLineAfter\";\n    EditorOption[EditorOption[\"suggest\"] = 119] = \"suggest\";\n    EditorOption[EditorOption[\"suggestFontSize\"] = 120] = \"suggestFontSize\";\n    EditorOption[EditorOption[\"suggestLineHeight\"] = 121] = \"suggestLineHeight\";\n    EditorOption[EditorOption[\"suggestOnTriggerCharacters\"] = 122] = \"suggestOnTriggerCharacters\";\n    EditorOption[EditorOption[\"suggestSelection\"] = 123] = \"suggestSelection\";\n    EditorOption[EditorOption[\"tabCompletion\"] = 124] = \"tabCompletion\";\n    EditorOption[EditorOption[\"tabIndex\"] = 125] = \"tabIndex\";\n    EditorOption[EditorOption[\"unicodeHighlighting\"] = 126] = \"unicodeHighlighting\";\n    EditorOption[EditorOption[\"unusualLineTerminators\"] = 127] = \"unusualLineTerminators\";\n    EditorOption[EditorOption[\"useShadowDOM\"] = 128] = \"useShadowDOM\";\n    EditorOption[EditorOption[\"useTabStops\"] = 129] = \"useTabStops\";\n    EditorOption[EditorOption[\"wordBreak\"] = 130] = \"wordBreak\";\n    EditorOption[EditorOption[\"wordSegmenterLocales\"] = 131] = \"wordSegmenterLocales\";\n    EditorOption[EditorOption[\"wordSeparators\"] = 132] = \"wordSeparators\";\n    EditorOption[EditorOption[\"wordWrap\"] = 133] = \"wordWrap\";\n    EditorOption[EditorOption[\"wordWrapBreakAfterCharacters\"] = 134] = \"wordWrapBreakAfterCharacters\";\n    EditorOption[EditorOption[\"wordWrapBreakBeforeCharacters\"] = 135] = \"wordWrapBreakBeforeCharacters\";\n    EditorOption[EditorOption[\"wordWrapColumn\"] = 136] = \"wordWrapColumn\";\n    EditorOption[EditorOption[\"wordWrapOverride1\"] = 137] = \"wordWrapOverride1\";\n    EditorOption[EditorOption[\"wordWrapOverride2\"] = 138] = \"wordWrapOverride2\";\n    EditorOption[EditorOption[\"wrappingIndent\"] = 139] = \"wrappingIndent\";\n    EditorOption[EditorOption[\"wrappingStrategy\"] = 140] = \"wrappingStrategy\";\n    EditorOption[EditorOption[\"showDeprecated\"] = 141] = \"showDeprecated\";\n    EditorOption[EditorOption[\"inlayHints\"] = 142] = \"inlayHints\";\n    EditorOption[EditorOption[\"editorClassName\"] = 143] = \"editorClassName\";\n    EditorOption[EditorOption[\"pixelRatio\"] = 144] = \"pixelRatio\";\n    EditorOption[EditorOption[\"tabFocusMode\"] = 145] = \"tabFocusMode\";\n    EditorOption[EditorOption[\"layoutInfo\"] = 146] = \"layoutInfo\";\n    EditorOption[EditorOption[\"wrappingInfo\"] = 147] = \"wrappingInfo\";\n    EditorOption[EditorOption[\"defaultColorDecorators\"] = 148] = \"defaultColorDecorators\";\n    EditorOption[EditorOption[\"colorDecoratorsActivatedOn\"] = 149] = \"colorDecoratorsActivatedOn\";\n    EditorOption[EditorOption[\"inlineCompletionsAccessibilityVerbose\"] = 150] = \"inlineCompletionsAccessibilityVerbose\";\n})(EditorOption || (EditorOption = {})));\nvar EndOfLinePreference;\n( (function(EndOfLinePreference) {\n    EndOfLinePreference[EndOfLinePreference[\"TextDefined\"] = 0] = \"TextDefined\";\n    EndOfLinePreference[EndOfLinePreference[\"LF\"] = 1] = \"LF\";\n    EndOfLinePreference[EndOfLinePreference[\"CRLF\"] = 2] = \"CRLF\";\n})(EndOfLinePreference || (EndOfLinePreference = {})));\nvar EndOfLineSequence;\n( (function(EndOfLineSequence) {\n    EndOfLineSequence[EndOfLineSequence[\"LF\"] = 0] = \"LF\";\n    EndOfLineSequence[EndOfLineSequence[\"CRLF\"] = 1] = \"CRLF\";\n})(EndOfLineSequence || (EndOfLineSequence = {})));\nvar GlyphMarginLane;\n( (function(GlyphMarginLane) {\n    GlyphMarginLane[GlyphMarginLane[\"Left\"] = 1] = \"Left\";\n    GlyphMarginLane[GlyphMarginLane[\"Center\"] = 2] = \"Center\";\n    GlyphMarginLane[GlyphMarginLane[\"Right\"] = 3] = \"Right\";\n})(GlyphMarginLane || (GlyphMarginLane = {})));\nvar HoverVerbosityAction;\n( (function(HoverVerbosityAction) {\n    HoverVerbosityAction[HoverVerbosityAction[\"Increase\"] = 0] = \"Increase\";\n    HoverVerbosityAction[HoverVerbosityAction[\"Decrease\"] = 1] = \"Decrease\";\n})(HoverVerbosityAction || (HoverVerbosityAction = {})));\nvar IndentAction;\n( (function(IndentAction) {\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {})));\nvar InjectedTextCursorStops;\n( (function(InjectedTextCursorStops) {\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Both\"] = 0] = \"Both\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Right\"] = 1] = \"Right\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Left\"] = 2] = \"Left\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"None\"] = 3] = \"None\";\n})(InjectedTextCursorStops || (InjectedTextCursorStops = {})));\nvar InlayHintKind;\n( (function(InlayHintKind) {\n    InlayHintKind[InlayHintKind[\"Type\"] = 1] = \"Type\";\n    InlayHintKind[InlayHintKind[\"Parameter\"] = 2] = \"Parameter\";\n})(InlayHintKind || (InlayHintKind = {})));\nvar InlineCompletionTriggerKind;\n( (function(InlineCompletionTriggerKind) {\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Automatic\"] = 0] = \"Automatic\";\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Explicit\"] = 1] = \"Explicit\";\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {})));\nvar InlineEditTriggerKind;\n( (function(InlineEditTriggerKind) {\n    InlineEditTriggerKind[InlineEditTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\n    InlineEditTriggerKind[InlineEditTriggerKind[\"Automatic\"] = 1] = \"Automatic\";\n})(InlineEditTriggerKind || (InlineEditTriggerKind = {})));\nvar KeyCode;\n( (function(KeyCode) {\n    KeyCode[KeyCode[\"DependsOnKbLayout\"] = -1] = \"DependsOnKbLayout\";\n    KeyCode[KeyCode[\"Unknown\"] = 0] = \"Unknown\";\n    KeyCode[KeyCode[\"Backspace\"] = 1] = \"Backspace\";\n    KeyCode[KeyCode[\"Tab\"] = 2] = \"Tab\";\n    KeyCode[KeyCode[\"Enter\"] = 3] = \"Enter\";\n    KeyCode[KeyCode[\"Shift\"] = 4] = \"Shift\";\n    KeyCode[KeyCode[\"Ctrl\"] = 5] = \"Ctrl\";\n    KeyCode[KeyCode[\"Alt\"] = 6] = \"Alt\";\n    KeyCode[KeyCode[\"PauseBreak\"] = 7] = \"PauseBreak\";\n    KeyCode[KeyCode[\"CapsLock\"] = 8] = \"CapsLock\";\n    KeyCode[KeyCode[\"Escape\"] = 9] = \"Escape\";\n    KeyCode[KeyCode[\"Space\"] = 10] = \"Space\";\n    KeyCode[KeyCode[\"PageUp\"] = 11] = \"PageUp\";\n    KeyCode[KeyCode[\"PageDown\"] = 12] = \"PageDown\";\n    KeyCode[KeyCode[\"End\"] = 13] = \"End\";\n    KeyCode[KeyCode[\"Home\"] = 14] = \"Home\";\n    KeyCode[KeyCode[\"LeftArrow\"] = 15] = \"LeftArrow\";\n    KeyCode[KeyCode[\"UpArrow\"] = 16] = \"UpArrow\";\n    KeyCode[KeyCode[\"RightArrow\"] = 17] = \"RightArrow\";\n    KeyCode[KeyCode[\"DownArrow\"] = 18] = \"DownArrow\";\n    KeyCode[KeyCode[\"Insert\"] = 19] = \"Insert\";\n    KeyCode[KeyCode[\"Delete\"] = 20] = \"Delete\";\n    KeyCode[KeyCode[\"Digit0\"] = 21] = \"Digit0\";\n    KeyCode[KeyCode[\"Digit1\"] = 22] = \"Digit1\";\n    KeyCode[KeyCode[\"Digit2\"] = 23] = \"Digit2\";\n    KeyCode[KeyCode[\"Digit3\"] = 24] = \"Digit3\";\n    KeyCode[KeyCode[\"Digit4\"] = 25] = \"Digit4\";\n    KeyCode[KeyCode[\"Digit5\"] = 26] = \"Digit5\";\n    KeyCode[KeyCode[\"Digit6\"] = 27] = \"Digit6\";\n    KeyCode[KeyCode[\"Digit7\"] = 28] = \"Digit7\";\n    KeyCode[KeyCode[\"Digit8\"] = 29] = \"Digit8\";\n    KeyCode[KeyCode[\"Digit9\"] = 30] = \"Digit9\";\n    KeyCode[KeyCode[\"KeyA\"] = 31] = \"KeyA\";\n    KeyCode[KeyCode[\"KeyB\"] = 32] = \"KeyB\";\n    KeyCode[KeyCode[\"KeyC\"] = 33] = \"KeyC\";\n    KeyCode[KeyCode[\"KeyD\"] = 34] = \"KeyD\";\n    KeyCode[KeyCode[\"KeyE\"] = 35] = \"KeyE\";\n    KeyCode[KeyCode[\"KeyF\"] = 36] = \"KeyF\";\n    KeyCode[KeyCode[\"KeyG\"] = 37] = \"KeyG\";\n    KeyCode[KeyCode[\"KeyH\"] = 38] = \"KeyH\";\n    KeyCode[KeyCode[\"KeyI\"] = 39] = \"KeyI\";\n    KeyCode[KeyCode[\"KeyJ\"] = 40] = \"KeyJ\";\n    KeyCode[KeyCode[\"KeyK\"] = 41] = \"KeyK\";\n    KeyCode[KeyCode[\"KeyL\"] = 42] = \"KeyL\";\n    KeyCode[KeyCode[\"KeyM\"] = 43] = \"KeyM\";\n    KeyCode[KeyCode[\"KeyN\"] = 44] = \"KeyN\";\n    KeyCode[KeyCode[\"KeyO\"] = 45] = \"KeyO\";\n    KeyCode[KeyCode[\"KeyP\"] = 46] = \"KeyP\";\n    KeyCode[KeyCode[\"KeyQ\"] = 47] = \"KeyQ\";\n    KeyCode[KeyCode[\"KeyR\"] = 48] = \"KeyR\";\n    KeyCode[KeyCode[\"KeyS\"] = 49] = \"KeyS\";\n    KeyCode[KeyCode[\"KeyT\"] = 50] = \"KeyT\";\n    KeyCode[KeyCode[\"KeyU\"] = 51] = \"KeyU\";\n    KeyCode[KeyCode[\"KeyV\"] = 52] = \"KeyV\";\n    KeyCode[KeyCode[\"KeyW\"] = 53] = \"KeyW\";\n    KeyCode[KeyCode[\"KeyX\"] = 54] = \"KeyX\";\n    KeyCode[KeyCode[\"KeyY\"] = 55] = \"KeyY\";\n    KeyCode[KeyCode[\"KeyZ\"] = 56] = \"KeyZ\";\n    KeyCode[KeyCode[\"Meta\"] = 57] = \"Meta\";\n    KeyCode[KeyCode[\"ContextMenu\"] = 58] = \"ContextMenu\";\n    KeyCode[KeyCode[\"F1\"] = 59] = \"F1\";\n    KeyCode[KeyCode[\"F2\"] = 60] = \"F2\";\n    KeyCode[KeyCode[\"F3\"] = 61] = \"F3\";\n    KeyCode[KeyCode[\"F4\"] = 62] = \"F4\";\n    KeyCode[KeyCode[\"F5\"] = 63] = \"F5\";\n    KeyCode[KeyCode[\"F6\"] = 64] = \"F6\";\n    KeyCode[KeyCode[\"F7\"] = 65] = \"F7\";\n    KeyCode[KeyCode[\"F8\"] = 66] = \"F8\";\n    KeyCode[KeyCode[\"F9\"] = 67] = \"F9\";\n    KeyCode[KeyCode[\"F10\"] = 68] = \"F10\";\n    KeyCode[KeyCode[\"F11\"] = 69] = \"F11\";\n    KeyCode[KeyCode[\"F12\"] = 70] = \"F12\";\n    KeyCode[KeyCode[\"F13\"] = 71] = \"F13\";\n    KeyCode[KeyCode[\"F14\"] = 72] = \"F14\";\n    KeyCode[KeyCode[\"F15\"] = 73] = \"F15\";\n    KeyCode[KeyCode[\"F16\"] = 74] = \"F16\";\n    KeyCode[KeyCode[\"F17\"] = 75] = \"F17\";\n    KeyCode[KeyCode[\"F18\"] = 76] = \"F18\";\n    KeyCode[KeyCode[\"F19\"] = 77] = \"F19\";\n    KeyCode[KeyCode[\"F20\"] = 78] = \"F20\";\n    KeyCode[KeyCode[\"F21\"] = 79] = \"F21\";\n    KeyCode[KeyCode[\"F22\"] = 80] = \"F22\";\n    KeyCode[KeyCode[\"F23\"] = 81] = \"F23\";\n    KeyCode[KeyCode[\"F24\"] = 82] = \"F24\";\n    KeyCode[KeyCode[\"NumLock\"] = 83] = \"NumLock\";\n    KeyCode[KeyCode[\"ScrollLock\"] = 84] = \"ScrollLock\";\n    KeyCode[KeyCode[\"Semicolon\"] = 85] = \"Semicolon\";\n    KeyCode[KeyCode[\"Equal\"] = 86] = \"Equal\";\n    KeyCode[KeyCode[\"Comma\"] = 87] = \"Comma\";\n    KeyCode[KeyCode[\"Minus\"] = 88] = \"Minus\";\n    KeyCode[KeyCode[\"Period\"] = 89] = \"Period\";\n    KeyCode[KeyCode[\"Slash\"] = 90] = \"Slash\";\n    KeyCode[KeyCode[\"Backquote\"] = 91] = \"Backquote\";\n    KeyCode[KeyCode[\"BracketLeft\"] = 92] = \"BracketLeft\";\n    KeyCode[KeyCode[\"Backslash\"] = 93] = \"Backslash\";\n    KeyCode[KeyCode[\"BracketRight\"] = 94] = \"BracketRight\";\n    KeyCode[KeyCode[\"Quote\"] = 95] = \"Quote\";\n    KeyCode[KeyCode[\"OEM_8\"] = 96] = \"OEM_8\";\n    KeyCode[KeyCode[\"IntlBackslash\"] = 97] = \"IntlBackslash\";\n    KeyCode[KeyCode[\"Numpad0\"] = 98] = \"Numpad0\";\n    KeyCode[KeyCode[\"Numpad1\"] = 99] = \"Numpad1\";\n    KeyCode[KeyCode[\"Numpad2\"] = 100] = \"Numpad2\";\n    KeyCode[KeyCode[\"Numpad3\"] = 101] = \"Numpad3\";\n    KeyCode[KeyCode[\"Numpad4\"] = 102] = \"Numpad4\";\n    KeyCode[KeyCode[\"Numpad5\"] = 103] = \"Numpad5\";\n    KeyCode[KeyCode[\"Numpad6\"] = 104] = \"Numpad6\";\n    KeyCode[KeyCode[\"Numpad7\"] = 105] = \"Numpad7\";\n    KeyCode[KeyCode[\"Numpad8\"] = 106] = \"Numpad8\";\n    KeyCode[KeyCode[\"Numpad9\"] = 107] = \"Numpad9\";\n    KeyCode[KeyCode[\"NumpadMultiply\"] = 108] = \"NumpadMultiply\";\n    KeyCode[KeyCode[\"NumpadAdd\"] = 109] = \"NumpadAdd\";\n    KeyCode[KeyCode[\"NUMPAD_SEPARATOR\"] = 110] = \"NUMPAD_SEPARATOR\";\n    KeyCode[KeyCode[\"NumpadSubtract\"] = 111] = \"NumpadSubtract\";\n    KeyCode[KeyCode[\"NumpadDecimal\"] = 112] = \"NumpadDecimal\";\n    KeyCode[KeyCode[\"NumpadDivide\"] = 113] = \"NumpadDivide\";\n    KeyCode[KeyCode[\"KEY_IN_COMPOSITION\"] = 114] = \"KEY_IN_COMPOSITION\";\n    KeyCode[KeyCode[\"ABNT_C1\"] = 115] = \"ABNT_C1\";\n    KeyCode[KeyCode[\"ABNT_C2\"] = 116] = \"ABNT_C2\";\n    KeyCode[KeyCode[\"AudioVolumeMute\"] = 117] = \"AudioVolumeMute\";\n    KeyCode[KeyCode[\"AudioVolumeUp\"] = 118] = \"AudioVolumeUp\";\n    KeyCode[KeyCode[\"AudioVolumeDown\"] = 119] = \"AudioVolumeDown\";\n    KeyCode[KeyCode[\"BrowserSearch\"] = 120] = \"BrowserSearch\";\n    KeyCode[KeyCode[\"BrowserHome\"] = 121] = \"BrowserHome\";\n    KeyCode[KeyCode[\"BrowserBack\"] = 122] = \"BrowserBack\";\n    KeyCode[KeyCode[\"BrowserForward\"] = 123] = \"BrowserForward\";\n    KeyCode[KeyCode[\"MediaTrackNext\"] = 124] = \"MediaTrackNext\";\n    KeyCode[KeyCode[\"MediaTrackPrevious\"] = 125] = \"MediaTrackPrevious\";\n    KeyCode[KeyCode[\"MediaStop\"] = 126] = \"MediaStop\";\n    KeyCode[KeyCode[\"MediaPlayPause\"] = 127] = \"MediaPlayPause\";\n    KeyCode[KeyCode[\"LaunchMediaPlayer\"] = 128] = \"LaunchMediaPlayer\";\n    KeyCode[KeyCode[\"LaunchMail\"] = 129] = \"LaunchMail\";\n    KeyCode[KeyCode[\"LaunchApp2\"] = 130] = \"LaunchApp2\";\n    KeyCode[KeyCode[\"Clear\"] = 131] = \"Clear\";\n    KeyCode[KeyCode[\"MAX_VALUE\"] = 132] = \"MAX_VALUE\";\n})(KeyCode || (KeyCode = {})));\nvar MarkerSeverity;\n( (function(MarkerSeverity) {\n    MarkerSeverity[MarkerSeverity[\"Hint\"] = 1] = \"Hint\";\n    MarkerSeverity[MarkerSeverity[\"Info\"] = 2] = \"Info\";\n    MarkerSeverity[MarkerSeverity[\"Warning\"] = 4] = \"Warning\";\n    MarkerSeverity[MarkerSeverity[\"Error\"] = 8] = \"Error\";\n})(MarkerSeverity || (MarkerSeverity = {})));\nvar MarkerTag;\n( (function(MarkerTag) {\n    MarkerTag[MarkerTag[\"Unnecessary\"] = 1] = \"Unnecessary\";\n    MarkerTag[MarkerTag[\"Deprecated\"] = 2] = \"Deprecated\";\n})(MarkerTag || (MarkerTag = {})));\nvar MinimapPosition;\n( (function(MinimapPosition) {\n    MinimapPosition[MinimapPosition[\"Inline\"] = 1] = \"Inline\";\n    MinimapPosition[MinimapPosition[\"Gutter\"] = 2] = \"Gutter\";\n})(MinimapPosition || (MinimapPosition = {})));\nvar MinimapSectionHeaderStyle;\n( (function(MinimapSectionHeaderStyle) {\n    MinimapSectionHeaderStyle[MinimapSectionHeaderStyle[\"Normal\"] = 1] = \"Normal\";\n    MinimapSectionHeaderStyle[MinimapSectionHeaderStyle[\"Underlined\"] = 2] = \"Underlined\";\n})(MinimapSectionHeaderStyle || (MinimapSectionHeaderStyle = {})));\nvar MouseTargetType;\n( (function(MouseTargetType) {\n    MouseTargetType[MouseTargetType[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    MouseTargetType[MouseTargetType[\"TEXTAREA\"] = 1] = \"TEXTAREA\";\n    MouseTargetType[MouseTargetType[\"GUTTER_GLYPH_MARGIN\"] = 2] = \"GUTTER_GLYPH_MARGIN\";\n    MouseTargetType[MouseTargetType[\"GUTTER_LINE_NUMBERS\"] = 3] = \"GUTTER_LINE_NUMBERS\";\n    MouseTargetType[MouseTargetType[\"GUTTER_LINE_DECORATIONS\"] = 4] = \"GUTTER_LINE_DECORATIONS\";\n    MouseTargetType[MouseTargetType[\"GUTTER_VIEW_ZONE\"] = 5] = \"GUTTER_VIEW_ZONE\";\n    MouseTargetType[MouseTargetType[\"CONTENT_TEXT\"] = 6] = \"CONTENT_TEXT\";\n    MouseTargetType[MouseTargetType[\"CONTENT_EMPTY\"] = 7] = \"CONTENT_EMPTY\";\n    MouseTargetType[MouseTargetType[\"CONTENT_VIEW_ZONE\"] = 8] = \"CONTENT_VIEW_ZONE\";\n    MouseTargetType[MouseTargetType[\"CONTENT_WIDGET\"] = 9] = \"CONTENT_WIDGET\";\n    MouseTargetType[MouseTargetType[\"OVERVIEW_RULER\"] = 10] = \"OVERVIEW_RULER\";\n    MouseTargetType[MouseTargetType[\"SCROLLBAR\"] = 11] = \"SCROLLBAR\";\n    MouseTargetType[MouseTargetType[\"OVERLAY_WIDGET\"] = 12] = \"OVERLAY_WIDGET\";\n    MouseTargetType[MouseTargetType[\"OUTSIDE_EDITOR\"] = 13] = \"OUTSIDE_EDITOR\";\n})(MouseTargetType || (MouseTargetType = {})));\nvar NewSymbolNameTag;\n( (function(NewSymbolNameTag) {\n    NewSymbolNameTag[NewSymbolNameTag[\"AIGenerated\"] = 1] = \"AIGenerated\";\n})(NewSymbolNameTag || (NewSymbolNameTag = {})));\nvar NewSymbolNameTriggerKind;\n( (function(NewSymbolNameTriggerKind) {\n    NewSymbolNameTriggerKind[NewSymbolNameTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\n    NewSymbolNameTriggerKind[NewSymbolNameTriggerKind[\"Automatic\"] = 1] = \"Automatic\";\n})(NewSymbolNameTriggerKind || (NewSymbolNameTriggerKind = {})));\nvar OverlayWidgetPositionPreference;\n( (function(OverlayWidgetPositionPreference) {\n    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference[\"TOP_RIGHT_CORNER\"] = 0] = \"TOP_RIGHT_CORNER\";\n    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference[\"BOTTOM_RIGHT_CORNER\"] = 1] = \"BOTTOM_RIGHT_CORNER\";\n    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference[\"TOP_CENTER\"] = 2] = \"TOP_CENTER\";\n})(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {})));\nvar OverviewRulerLane;\n( (function(OverviewRulerLane) {\n    OverviewRulerLane[OverviewRulerLane[\"Left\"] = 1] = \"Left\";\n    OverviewRulerLane[OverviewRulerLane[\"Center\"] = 2] = \"Center\";\n    OverviewRulerLane[OverviewRulerLane[\"Right\"] = 4] = \"Right\";\n    OverviewRulerLane[OverviewRulerLane[\"Full\"] = 7] = \"Full\";\n})(OverviewRulerLane || (OverviewRulerLane = {})));\nvar PartialAcceptTriggerKind;\n( (function(PartialAcceptTriggerKind) {\n    PartialAcceptTriggerKind[PartialAcceptTriggerKind[\"Word\"] = 0] = \"Word\";\n    PartialAcceptTriggerKind[PartialAcceptTriggerKind[\"Line\"] = 1] = \"Line\";\n    PartialAcceptTriggerKind[PartialAcceptTriggerKind[\"Suggest\"] = 2] = \"Suggest\";\n})(PartialAcceptTriggerKind || (PartialAcceptTriggerKind = {})));\nvar PositionAffinity;\n( (function(PositionAffinity) {\n    PositionAffinity[PositionAffinity[\"Left\"] = 0] = \"Left\";\n    PositionAffinity[PositionAffinity[\"Right\"] = 1] = \"Right\";\n    PositionAffinity[PositionAffinity[\"None\"] = 2] = \"None\";\n    PositionAffinity[PositionAffinity[\"LeftOfInjectedText\"] = 3] = \"LeftOfInjectedText\";\n    PositionAffinity[PositionAffinity[\"RightOfInjectedText\"] = 4] = \"RightOfInjectedText\";\n})(PositionAffinity || (PositionAffinity = {})));\nvar RenderLineNumbersType;\n( (function(RenderLineNumbersType) {\n    RenderLineNumbersType[RenderLineNumbersType[\"Off\"] = 0] = \"Off\";\n    RenderLineNumbersType[RenderLineNumbersType[\"On\"] = 1] = \"On\";\n    RenderLineNumbersType[RenderLineNumbersType[\"Relative\"] = 2] = \"Relative\";\n    RenderLineNumbersType[RenderLineNumbersType[\"Interval\"] = 3] = \"Interval\";\n    RenderLineNumbersType[RenderLineNumbersType[\"Custom\"] = 4] = \"Custom\";\n})(RenderLineNumbersType || (RenderLineNumbersType = {})));\nvar RenderMinimap;\n( (function(RenderMinimap) {\n    RenderMinimap[RenderMinimap[\"None\"] = 0] = \"None\";\n    RenderMinimap[RenderMinimap[\"Text\"] = 1] = \"Text\";\n    RenderMinimap[RenderMinimap[\"Blocks\"] = 2] = \"Blocks\";\n})(RenderMinimap || (RenderMinimap = {})));\nvar ScrollType;\n( (function(ScrollType) {\n    ScrollType[ScrollType[\"Smooth\"] = 0] = \"Smooth\";\n    ScrollType[ScrollType[\"Immediate\"] = 1] = \"Immediate\";\n})(ScrollType || (ScrollType = {})));\nvar ScrollbarVisibility;\n( (function(ScrollbarVisibility) {\n    ScrollbarVisibility[ScrollbarVisibility[\"Auto\"] = 1] = \"Auto\";\n    ScrollbarVisibility[ScrollbarVisibility[\"Hidden\"] = 2] = \"Hidden\";\n    ScrollbarVisibility[ScrollbarVisibility[\"Visible\"] = 3] = \"Visible\";\n})(ScrollbarVisibility || (ScrollbarVisibility = {})));\nvar SelectionDirection;\n( (function(SelectionDirection) {\n    SelectionDirection[SelectionDirection[\"LTR\"] = 0] = \"LTR\";\n    SelectionDirection[SelectionDirection[\"RTL\"] = 1] = \"RTL\";\n})(SelectionDirection || (SelectionDirection = {})));\nvar ShowLightbulbIconMode;\n( (function(ShowLightbulbIconMode) {\n    ShowLightbulbIconMode[\"Off\"] = \"off\";\n    ShowLightbulbIconMode[\"OnCode\"] = \"onCode\";\n    ShowLightbulbIconMode[\"On\"] = \"on\";\n})(ShowLightbulbIconMode || (ShowLightbulbIconMode = {})));\nvar SignatureHelpTriggerKind;\n( (function(SignatureHelpTriggerKind) {\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"Invoke\"] = 1] = \"Invoke\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"TriggerCharacter\"] = 2] = \"TriggerCharacter\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"ContentChange\"] = 3] = \"ContentChange\";\n})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {})));\nvar SymbolKind;\n( (function(SymbolKind) {\n    SymbolKind[SymbolKind[\"File\"] = 0] = \"File\";\n    SymbolKind[SymbolKind[\"Module\"] = 1] = \"Module\";\n    SymbolKind[SymbolKind[\"Namespace\"] = 2] = \"Namespace\";\n    SymbolKind[SymbolKind[\"Package\"] = 3] = \"Package\";\n    SymbolKind[SymbolKind[\"Class\"] = 4] = \"Class\";\n    SymbolKind[SymbolKind[\"Method\"] = 5] = \"Method\";\n    SymbolKind[SymbolKind[\"Property\"] = 6] = \"Property\";\n    SymbolKind[SymbolKind[\"Field\"] = 7] = \"Field\";\n    SymbolKind[SymbolKind[\"Constructor\"] = 8] = \"Constructor\";\n    SymbolKind[SymbolKind[\"Enum\"] = 9] = \"Enum\";\n    SymbolKind[SymbolKind[\"Interface\"] = 10] = \"Interface\";\n    SymbolKind[SymbolKind[\"Function\"] = 11] = \"Function\";\n    SymbolKind[SymbolKind[\"Variable\"] = 12] = \"Variable\";\n    SymbolKind[SymbolKind[\"Constant\"] = 13] = \"Constant\";\n    SymbolKind[SymbolKind[\"String\"] = 14] = \"String\";\n    SymbolKind[SymbolKind[\"Number\"] = 15] = \"Number\";\n    SymbolKind[SymbolKind[\"Boolean\"] = 16] = \"Boolean\";\n    SymbolKind[SymbolKind[\"Array\"] = 17] = \"Array\";\n    SymbolKind[SymbolKind[\"Object\"] = 18] = \"Object\";\n    SymbolKind[SymbolKind[\"Key\"] = 19] = \"Key\";\n    SymbolKind[SymbolKind[\"Null\"] = 20] = \"Null\";\n    SymbolKind[SymbolKind[\"EnumMember\"] = 21] = \"EnumMember\";\n    SymbolKind[SymbolKind[\"Struct\"] = 22] = \"Struct\";\n    SymbolKind[SymbolKind[\"Event\"] = 23] = \"Event\";\n    SymbolKind[SymbolKind[\"Operator\"] = 24] = \"Operator\";\n    SymbolKind[SymbolKind[\"TypeParameter\"] = 25] = \"TypeParameter\";\n})(SymbolKind || (SymbolKind = {})));\nvar SymbolTag;\n( (function(SymbolTag) {\n    SymbolTag[SymbolTag[\"Deprecated\"] = 1] = \"Deprecated\";\n})(SymbolTag || (SymbolTag = {})));\nvar TextEditorCursorBlinkingStyle;\n( (function(TextEditorCursorBlinkingStyle) {\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Hidden\"] = 0] = \"Hidden\";\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Blink\"] = 1] = \"Blink\";\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Smooth\"] = 2] = \"Smooth\";\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Phase\"] = 3] = \"Phase\";\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Expand\"] = 4] = \"Expand\";\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Solid\"] = 5] = \"Solid\";\n})(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {})));\nvar TextEditorCursorStyle;\n( (function(TextEditorCursorStyle) {\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Line\"] = 1] = \"Line\";\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Block\"] = 2] = \"Block\";\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Underline\"] = 3] = \"Underline\";\n    TextEditorCursorStyle[TextEditorCursorStyle[\"LineThin\"] = 4] = \"LineThin\";\n    TextEditorCursorStyle[TextEditorCursorStyle[\"BlockOutline\"] = 5] = \"BlockOutline\";\n    TextEditorCursorStyle[TextEditorCursorStyle[\"UnderlineThin\"] = 6] = \"UnderlineThin\";\n})(TextEditorCursorStyle || (TextEditorCursorStyle = {})));\nvar TrackedRangeStickiness;\n( (function(TrackedRangeStickiness) {\n    TrackedRangeStickiness[TrackedRangeStickiness[\"AlwaysGrowsWhenTypingAtEdges\"] = 0] = \"AlwaysGrowsWhenTypingAtEdges\";\n    TrackedRangeStickiness[TrackedRangeStickiness[\"NeverGrowsWhenTypingAtEdges\"] = 1] = \"NeverGrowsWhenTypingAtEdges\";\n    TrackedRangeStickiness[TrackedRangeStickiness[\"GrowsOnlyWhenTypingBefore\"] = 2] = \"GrowsOnlyWhenTypingBefore\";\n    TrackedRangeStickiness[TrackedRangeStickiness[\"GrowsOnlyWhenTypingAfter\"] = 3] = \"GrowsOnlyWhenTypingAfter\";\n})(TrackedRangeStickiness || (TrackedRangeStickiness = {})));\nvar WrappingIndent;\n( (function(WrappingIndent) {\n    WrappingIndent[WrappingIndent[\"None\"] = 0] = \"None\";\n    WrappingIndent[WrappingIndent[\"Same\"] = 1] = \"Same\";\n    WrappingIndent[WrappingIndent[\"Indent\"] = 2] = \"Indent\";\n    WrappingIndent[WrappingIndent[\"DeepIndent\"] = 3] = \"DeepIndent\";\n})(WrappingIndent || (WrappingIndent = {})));\nexport { AccessibilitySupport, CodeActionTriggerType, CompletionItemInsertTextRule, CompletionItemKind, CompletionItemTag, CompletionTriggerKind, ContentWidgetPositionPreference, CursorChangeReason, DefaultEndOfLine, DocumentHighlightKind, EditorAutoIndentStrategy, EditorOption, EndOfLinePreference, EndOfLineSequence, GlyphMarginLane, HoverVerbosityAction, IndentAction, InjectedTextCursorStops, InlayHintKind, InlineCompletionTriggerKind, InlineEditTriggerKind, KeyCode, MarkerSeverity, MarkerTag, MinimapPosition, MinimapSectionHeaderStyle, MouseTargetType, NewSymbolNameTag, NewSymbolNameTriggerKind, OverlayWidgetPositionPreference, OverviewRulerLane, PartialAcceptTriggerKind, PositionAffinity, RenderLineNumbersType, RenderMinimap, ScrollType, ScrollbarVisibility, SelectionDirection, ShowLightbulbIconMode, SignatureHelpTriggerKind, SymbolKind, SymbolTag, TextEditorCursorBlinkingStyle, TextEditorCursorStyle, TrackedRangeStickiness, WrappingIndent };\n","import { SimpleWorkerServer } from '../base/common/worker/simpleWorker.js';\nimport { EditorSimpleWorker } from './common/services/editorSimpleWorker.js';\nlet initialized = false;\nfunction initialize(foreignModule) {\n    if (initialized) {\n        return;\n    }\n    initialized = true;\n    const simpleWorker = ( new SimpleWorkerServer((msg) => {\n        globalThis.postMessage(msg);\n    }, (host) => ( new EditorSimpleWorker(host, foreignModule))));\n    globalThis.onmessage = (e) => {\n        simpleWorker.onmessage(e.data);\n    };\n}\nglobalThis.onmessage = (e) => {\n    if (!initialized) {\n        initialize(null);\n    }\n};\nexport { initialize };\n","export { initialize } from '../vscode/src/vs/editor/editor.worker.js';\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [\"vendors-node_modules_vscode_vscode_src_vs_base_common_assert_js-node_modules_vscode_vscode_sr-d1ce6a\"], () => (__webpack_require__(\"./node_modules/monaco-editor/esm/vs/editor/editor.worker.js\")))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".main.js\";\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (typeof import.meta.url === \"string\") scriptUrl = import.meta.url\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t\"vendors-node_modules_monaco-editor_esm_vs_editor_editor_worker_js\": 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkexample_client_webpack\"] = self[\"webpackChunkexample_client_webpack\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(\"vendors-node_modules_vscode_vscode_src_vs_base_common_assert_js-node_modules_vscode_vscode_sr-d1ce6a\").then(next);\n};","","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n",""],"names":[],"sourceRoot":""}